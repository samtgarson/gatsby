(function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
            var code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, message, i;
            message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), arg;
                if (index + 2 < templateArgs.length) {
                    return toDebugString(templateArgs[index + 2]);
                }
                return match;
            });
            message = message + "\nhttp://errors.angularjs.org/1.3.15/" + (module ? module + "/" : "") + code;
            for (i = 2; i < arguments.length; i++) {
                message = message + (i == 2 ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(toDebugString(arguments[i]));
            }
            return new ErrorConstructor(message);
        };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = "validity";
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
    };
    var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
    };
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }
    var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
    msie = document.documentMode;
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
            return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = typeof obj !== "object";
                for (key = 0, length = obj.length; key < length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context, obj);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        }
        return obj;
    }
    function sortedKeys(obj) {
        return Object.keys(obj).sort();
    }
    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        for (var i = 1, ii = arguments.length; i < ii; i++) {
            var obj = arguments[i];
            if (obj) {
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    dst[key] = obj[key];
                }
            }
        }
        setHashKey(dst, h);
        return dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value !== null && typeof value === "object";
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    var isArray = Array.isArray;
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var trim = function(value) {
        return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) array.splice(index, 1);
        return value;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, [], stackSource, stackDest);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    destination.lastIndex = source.lastIndex;
                } else if (isObject(source)) {
                    var emptyObject = Object.create(Object.getPrototypeOf(source));
                    destination = copy(source, emptyObject, stackSource, stackDest);
                }
            }
        } else {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [];
            stackDest = stackDest || [];
            if (isObject(source)) {
                var index = stackSource.indexOf(source);
                if (index !== -1) return stackDest[index];
                stackSource.push(source);
                stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) {
                    result = copy(source[i], null, stackSource, stackDest);
                    if (isObject(source[i])) {
                        stackSource.push(source[i]);
                        stackDest.push(result);
                    }
                    destination.push(result);
                }
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function(value, key) {
                        delete destination[key];
                    });
                }
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result = copy(source[key], null, stackSource, stackDest);
                        if (isObject(source[key])) {
                            stackSource.push(source[key]);
                            stackDest.push(result);
                        }
                        destination[key] = result;
                    }
                }
                setHashKey(destination, h);
            }
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == "object") {
                if (isArray(o1)) {
                    if (!isArray(o2)) return false;
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2)) return false;
                    return equals(o1.getTime(), o2.getTime());
                } else if (isRegExp(o1)) {
                    return isRegExp(o2) ? o1.toString() == o2.toString() : false;
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
                    keySet = {};
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }
    var csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"));
        if (!active) {
            try {
                new Function("");
            } catch (e) {
                active = true;
            }
        }
        return csp.isActive_ = active;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (typeof obj === "undefined") return undefined;
        if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue) {
                key_value = keyValue.replace(/\+/g, "%20").split("=");
                key = tryDecodeURIComponent(key_value[0]);
                if (isDefined(key)) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        element = jqLite(element);
        for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element.attr(attr))) {
                return attr;
            }
        }
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                appElement = element;
                module = element.getAttribute(name);
            }
        });
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        });
        if (appElement) {
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        if (!isObject(config)) config = {};
        var defaultConfig = {
            strictDi: false
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            if (config.debugInfoEnabled) {
                modules.push([ "$compileProvider", function($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                } ]);
            }
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
            config.debugInfoEnabled = true;
            window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
            angular.resumeDeferredBootstrap();
        }
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
        window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        }
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = false;
    var skipDestroyOnNextJQueryCleanData;
    function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        jQuery = window.jQuery;
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            originalCleanData = jQuery.cleanData;
            jQuery.cleanData = function(elems) {
                var events;
                if (!skipDestroyOnNextJQueryCleanData) {
                    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                        events = jQuery._data(elem, "events");
                        if (events && events.$destroy) {
                            jQuery(elem).triggerHandler("$destroy");
                        }
                    }
                } else {
                    skipDestroyOnNextJQueryCleanData = false;
                }
                originalCleanData(elems);
            };
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [ node ];
        do {
            node = node.nextSibling;
            if (!node) break;
            blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
    }
    function createMap() {
        return Object.create(null);
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke", "push", configBlocks);
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        if (!queue) queue = invokeQueue;
                        return function() {
                            queue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            val = toJsonReplacer(key, val);
            if (isObject(val)) {
                if (seen.indexOf(val) >= 0) return "<<already seen>>";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (typeof obj === "undefined") {
            return "undefined";
        } else if (typeof obj !== "string") {
            return serializeObject(obj);
        }
        return obj;
    }
    var version = {
        full: "1.3.15",
        major: 1,
        minor: 3,
        dot: 15,
        codeName: "locality-filtration"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider,
                $$jqLite: $$jqLiteProvider
            });
        } ]);
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, false);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, false);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr("jqLite");
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
            fragment.appendChild(node);
        });
        return fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
        }
        return [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        var argIsString;
        if (isString(element)) {
            element = trim(element);
            argIsString = true;
        }
        if (!(this instanceof JQLite)) {
            if (argIsString && element.charAt(0) != "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants) jqLiteRemoveData(element);
        if (element.querySelectorAll) {
            var descendants = element.querySelectorAll("*");
            for (var i = 0, l = descendants.length; i < l; i++) {
                jqLiteRemoveData(descendants[i]);
            }
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle) return;
        if (!type) {
            for (type in events) {
                if (type !== "$destroy") {
                    removeEventListenerFn(element, type, handle);
                }
                delete events[type];
            }
        } else {
            forEach(type.split(" "), function(type) {
                if (isDefined(fn)) {
                    var listenerFns = events[type];
                    arrayRemove(listenerFns || [], fn);
                    if (listenerFns && listenerFns.length > 0) {
                        return;
                    }
                }
                removeEventListenerFn(element, type, handle);
                delete events[type];
            });
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete expandoStore.data[name];
                return;
            }
            if (expandoStore.handle) {
                if (expandoStore.events.$destroy) {
                    expandoStore.handle({}, "$destroy");
                }
                jqLiteOff(element);
            }
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
            element.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: undefined
            };
        }
        return expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
            var massGetter = !key;
            var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
                data[key] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        return data && data[key];
                    } else {
                        extend(data, key);
                    }
                }
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function(cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
            });
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " ";
                }
            });
            element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            if (elements.nodeType) {
                root[root.length++] = elements;
            } else {
                var length = elements.length;
                if (typeof length === "number" && elements.window !== elements) {
                    if (length) {
                        for (var i = 0; i < length; i++) {
                            root[root.length++] = elements[i];
                        }
                    }
                } else {
                    root[root.length++] = elements;
                }
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            }
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    function jqLiteRemove(element, keepData) {
        if (!keepData) jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent) parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === "complete") {
            win.setTimeout(action);
        } else {
            jqLite(win).on("load", action);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;
            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }
            if (document.readyState === "complete") {
                setTimeout(trigger);
            } else {
                this.on("DOMContentLoaded", trigger);
                JQLite(window).on("load", trigger);
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === "INPUT" || nodeName === "TEXTAREA") && ALIASED_ATTR[name];
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = camelCase(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                return element.style[name];
            }
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && nodeName_(element) === "select") {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result.length === 0 ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            jqLiteDealoc(element, true);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength) return;
            if (isUndefined(event.immediatePropagationStopped)) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = true;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (originalStopImmediatePropagation) {
                        originalStopImmediatePropagation.call(event);
                    }
                };
            }
            event.isImmediatePropagationStopped = function() {
                return event.immediatePropagationStopped === true;
            };
            if (eventFnsLength > 1) {
                eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
                if (!event.isImmediatePropagationStopped()) {
                    eventFns[i].call(element, event);
                }
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element)) {
                return;
            }
            var expandoStore = jqLiteExpandoStore(element, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
                handle = expandoStore.handle = createEventHandler(element, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
            var i = types.length;
            while (i--) {
                type = types[i];
                var eventFns = events[type];
                if (!eventFns) {
                    events[type] = [];
                    if (type === "mouseenter" || type === "mouseleave") {
                        jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            if (!related || related !== target && !target.contains(related)) {
                                handle(event, type);
                            }
                        });
                    } else {
                        if (type !== "$destroy") {
                            addEventListenerFn(element, type, handle);
                        }
                    }
                    eventFns = events[type];
                }
                eventFns.push(fn);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === NODE_TYPE_ELEMENT) children.push(element);
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling);
                index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = true;
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    if (!dummyEvent.isImmediatePropagationStopped()) {
                        fn.apply(element, handlerArgs);
                    }
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
    });
    function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
            if (typeof key === "function") {
                key = obj.$$hashKey();
            }
            return key;
        }
        var objType = typeof obj;
        if (objType == "function" || objType == "object" && obj !== null) {
            key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
        } else {
            key = objType + ":" + obj;
        }
        return key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            delete this[key];
            return value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
        }
        return "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    if (strictDi) {
                        if (!isString(name) || !name) {
                            name = fn.name || anonFn(fn);
                        }
                        throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    }
                    fnText = fn.toString().replace(STRIP_COMMENTS, "");
                    argDecl = fnText.match(FN_ARGS);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        });
        forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        });
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) {
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                }
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var runBlocks = [], moduleFn;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        runInvokeQueue(moduleFn._invokeQueue);
                        runInvokeQueue(moduleFn._configBlocks);
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName, caller);
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function invoke(fn, self, locals, serviceName) {
                if (typeof locals === "string") {
                    serviceName = locals;
                    locals = null;
                }
                var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), length, i, key;
                for (i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                if (isArray(fn)) {
                    fn = fn[length];
                }
                return fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
                var returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function(element) {
                    if (nodeName_(element) === "a") {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== "fixed") {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll() {
                var hash = $location.hash(), elm;
                if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === "") return;
                    jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {};
        this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && name.charAt(0) != ".") throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null;
            }
            return this.$$classNameFilter;
        };
        this.$get = [ "$$q", "$$asyncCallback", "$rootScope", function($$q, $$asyncCallback, $rootScope) {
            var currentDefer;
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function ngAnimateMaybeCancel() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function ngAnimatePostDigest() {
                    cancelFn = fn(function ngAnimateNotifyComplete() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function resolveElementClasses(element, classes) {
                var toAdd = [], toRemove = [];
                var hasClasses = createMap();
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                forEach(classes, function(status, className) {
                    var hasClass = hasClasses[className];
                    if (status === false && hasClass) {
                        toRemove.push(className);
                    } else if (status === true && !hasClass) {
                        toAdd.push(className);
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.length ? toAdd : null, toRemove.length ? toRemove : null ];
            }
            function cachedClassManipulation(cache, classes, op) {
                for (var i = 0, ii = classes.length; i < ii; ++i) {
                    var className = classes[i];
                    cache[className] = op;
                }
            }
            function asyncPromise() {
                if (!currentDefer) {
                    currentDefer = $$q.defer();
                    $$asyncCallback(function() {
                        currentDefer.resolve();
                        currentDefer = null;
                    });
                }
                return currentDefer.promise;
            }
            function applyStyles(element, options) {
                if (angular.isObject(options)) {
                    var styles = extend(options.from || {}, options.to || {});
                    element.css(styles);
                }
            }
            return {
                animate: function(element, from, to) {
                    applyStyles(element, {
                        from: from,
                        to: to
                    });
                    return asyncPromise();
                },
                enter: function(element, parent, after, options) {
                    applyStyles(element, options);
                    after ? after.after(element) : parent.prepend(element);
                    return asyncPromise();
                },
                leave: function(element, options) {
                    applyStyles(element, options);
                    element.remove();
                    return asyncPromise();
                },
                move: function(element, parent, after, options) {
                    return this.enter(element, parent, after, options);
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                $$addClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                $$removeClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                setClass: function(element, add, remove, options) {
                    var self = this;
                    var STORAGE_KEY = "$$animateClasses";
                    var createdCache = false;
                    element = jqLite(element);
                    var cache = element.data(STORAGE_KEY);
                    if (!cache) {
                        cache = {
                            classes: {},
                            options: options
                        };
                        createdCache = true;
                    } else if (options && cache.options) {
                        cache.options = angular.extend(cache.options || {}, options);
                    }
                    var classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    remove = isArray(remove) ? remove : remove.split(" ");
                    cachedClassManipulation(classes, add, true);
                    cachedClassManipulation(classes, remove, false);
                    if (createdCache) {
                        cache.promise = runAnimationPostDigest(function(done) {
                            var cache = element.data(STORAGE_KEY);
                            element.removeData(STORAGE_KEY);
                            if (cache) {
                                var classes = resolveElementClasses(element, cache.classes);
                                if (classes) {
                                    self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
                                }
                            }
                            done();
                        });
                        element.data(STORAGE_KEY, cache);
                    }
                    return cache.promise;
                },
                $$setClassImmediately: function(element, add, remove, options) {
                    add && this.$$addClassImmediately(element, add);
                    remove && this.$$removeClassImmediately(element, remove);
                    applyStyles(element, options);
                    return asyncPromise();
                },
                enabled: noop,
                cancel: noop
            };
        } ];
    } ];
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, false);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? "" : url.substr(index + 1);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            });
            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };
        var pollFns = [], pollTimeout;
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                });
                pollTimeout = setTimeout(check, interval);
            })();
        }
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
            if (isUndefined(state)) {
                state = null;
            }
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                    return self;
                }
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                lastBrowserUrl = url;
                lastHistoryState = state;
                if ($sniffer.history && (!sameBase || !sameState)) {
                    history[replace ? "replaceState" : "pushState"](state, "", url);
                    cacheState();
                    lastHistoryState = cachedState;
                } else {
                    if (!sameBase) {
                        reloadLocation = url;
                    }
                    if (replace) {
                        location.replace(url);
                    } else if (!sameBase) {
                        location.href = url;
                    } else {
                        location.hash = getHash(url);
                    }
                }
                return self;
            } else {
                return reloadLocation || location.href.replace(/%27/g, "'");
            }
        };
        self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
            cacheState();
            fireUrlChange();
        }
        function getCurrentState() {
            try {
                return history.state;
            } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
            cachedState = getCurrentState();
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
        }
        function fireUrlChange() {
            if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {};
        var lastCookieString = "";
        var cookiePath = self.baseHref();
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1;
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf("=");
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            }
        };
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (isUndefined(value)) return;
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
            var bindings = {};
            forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) {
                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition);
                }
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: match[2] === "*",
                    optional: match[3] === "?",
                    attrName: match[4] || scopeName
                };
            });
            return bindings;
        }
        this.directive = function registerDirective(name, directiveFactory) {
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = directive.require || directive.controller && directive.name;
                                directive.restrict = directive.restrict || "EA";
                                if (isObject(directive.scope)) {
                                    directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name);
                                }
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "a" && key === "href" || nodeName === "img" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src");
                    } else if (nodeName === "img" && key === "srcset") {
                        var result = "";
                        var trimmedSrcset = trim(value);
                        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                        var rawUris = trimmedSrcset.split(pattern);
                        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                        for (var i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = i * 2;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                            result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), true);
                        if (lastTuple.length === 2) {
                            result += " " + trim(lastTuple[1]);
                        }
                        this[key] = value = result;
                    }
                    if (writeAttr !== false) {
                        if (value === null || value === undefined) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            this.$$element.attr(attrName, value);
                        }
                    }
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
                            fn(attrs[key]);
                        }
                    });
                    return function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data("$binding", bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop;
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                forEach($compileNodes, function(node, index) {
                    if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                        $compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0];
                    }
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope");
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== "html") {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return "html";
                } else {
                    return nodeName_(node) !== "foreignobject" && node.toString().match(/SVG/) ? "svg" : "html";
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii; ) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = trim(attr.value);
                        ngAttrName = directiveNormalize(name);
                        if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                            name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                                return letter.toUpperCase();
                            });
                        }
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        if (directiveIsMultiElement(directiveNName)) {
                            if (ngAttrName === directiveNName + "Start") {
                                attrStartName = name;
                                attrEndName = name.substr(0, name.length - 5) + "end";
                                name = name.substr(0, name.length - 6);
                            }
                        }
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                            attrs[nName] = value;
                            if (getBooleanAttrName(node, nName)) {
                                attrs[nName] = true;
                            }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    className = node.className;
                    if (isObject(className)) {
                        className = className.animVal;
                    }
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                        if (match) {
                            nName = directiveNormalize(match[1]);
                            if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[2]);
                            }
                        }
                    } catch (e) {}
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType == NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, controllers, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    if (directiveValue = directive.scope) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!directive.templateUrl && directive.controller) {
                        directiveValue = directive.controller;
                        controllerDirectives = controllerDirectives || {};
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    if (directiveValue = directive.transclude) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue == "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                            $compileNode.empty();
                            childTranscludeFn = compile($template, transcludeFn);
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective) {
                                markDirectivesAsIsolate(templateDirectives);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            if (isFunction(linkFn)) {
                                addLinkFns(null, linkFn, attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = false;
                    var $searchElement = $element;
                    var match;
                    if (isString(require)) {
                        match = require.match(REQUIRE_PREFIX_REGEXP);
                        require = require.substring(match[0].length);
                        if (match[3]) {
                            if (match[1]) match[3] = null; else match[1] = match[3];
                        }
                        if (match[1] === "^") {
                            retrievalMethod = "inheritedData";
                        } else if (match[1] === "^^") {
                            retrievalMethod = "inheritedData";
                            $searchElement = $element.parent();
                        }
                        if (match[2] === "?") {
                            optional = true;
                        }
                        value = null;
                        if (elementControllers && retrievalMethod === "data") {
                            if (value = elementControllers[require]) {
                                value = value.instance;
                            }
                        }
                        value = value || $searchElement[retrievalMethod]("$" + require + "Controller");
                        if (!value && !optional) {
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        }
                        return value || null;
                    } else if (isArray(require)) {
                        value = [];
                        forEach(require, function(require) {
                            value.push(getControllers(directiveName, require, $element, elementControllers));
                        });
                    }
                    return value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                    }
                    if (controllerDirectives) {
                        controllers = {};
                        elementControllers = {};
                        forEach(controllerDirectives, function(directive) {
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controllerInstance;
                            controller = directive.controller;
                            if (controller == "@") {
                                controller = attrs[directive.name];
                            }
                            controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance;
                            if (!hasElementTranscludeDirective) {
                                $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                            }
                            controllers[directive.name] = controllerInstance;
                        });
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name];
                        var isolateBindingContext = isolateScope;
                        if (isolateScopeController && isolateScopeController.identifier && newIsolateScopeDirective.bindToController === true) {
                            isolateBindingContext = isolateScopeController.instance;
                        }
                        forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function(definition, scopeName) {
                            var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare;
                            switch (mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateBindingContext[scopeName] = value;
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                if (attrs[attrName]) {
                                    isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope);
                                }
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) {
                                    return;
                                }
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = function(a, b) {
                                        return a === b || a !== a && b !== b;
                                    };
                                }
                                parentSet = parentGet.assign || function() {
                                    lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                    throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                };
                                lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                var parentValueWatch = function parentValueWatch(parentValue) {
                                    if (!compare(parentValue, isolateBindingContext[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            isolateBindingContext[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = isolateBindingContext[scopeName]);
                                        }
                                    }
                                    return lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = true;
                                var unwatch;
                                if (definition.collection) {
                                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                } else {
                                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                }
                                isolateScope.$on("$destroy", unwatch);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]);
                                isolateBindingContext[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;
                            }
                        });
                    }
                    if (controllers) {
                        forEach(controllers, function(controller) {
                            controller();
                        });
                        controllers = null;
                    }
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                }
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: true
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        try {
                            directive = directives[i];
                            if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                if (startAttrName) {
                                    directive = inherit(directive, {
                                        $$start: startAttrName,
                                        $$end: endAttrName
                                    });
                                }
                                tDirectives.push(directive);
                                match = directive;
                            }
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) != "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key];
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (key == "class") {
                        safeAddClass($element, value);
                        dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
                    } else if (key == "style") {
                        $element.attr("style", $element.attr("style") + ";" + value);
                        dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
                    } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
                        dst[key] = value;
                        dstAttr[key] = srcAttr[key];
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest($sce.getTrustedResourceUrl(templateUrl)).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectivesAsIsolate(templateDirectives);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node == compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed) continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed) return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent) compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName == "srcdoc") {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName == "xlinkHref" || tag == "form" && attrNormalizedName == "action" || tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName_(node) === "select") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = {});
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                                }
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue != oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove);
                jqLite(newNode).data(jqLite(firstElementToRemove).data());
                if (!jQuery) {
                    delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                } else {
                    skipDestroyOnNextJQueryCleanData = true;
                    jQuery.cleanData([ firstElementToRemove ]);
                }
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove();
                    fragment.appendChild(element);
                    delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
        } ];
    }
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
            return jqNodes;
        }
        while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT) {
                splice.call(jqNodes, i, 1);
            }
        }
        return jqNodes;
    }
    var $controllerMinErr = minErr("$controller");
    function $ControllerProvider() {
        var controllers = {}, globals = false, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.allowGlobals = function() {
            globals = true;
        };
        this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG);
                    if (!match) {
                        throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                    }
                    constructor = match[1], identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    return extend(function() {
                        $injector.invoke(expression, instance, locals, constructor);
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    var APPLICATION_JSON = "application/json";
    var CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    };
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                    data = fromJson(tempData);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        var parsed = createMap(), key, val, i;
        if (!headers) return parsed;
        forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":");
            key = lowercase(trim(line.substr(0, i)));
            val = trim(line.substr(i + 1));
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        });
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                var value = headersObj[lowercase(name)];
                if (value === void 0) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        if (isFunction(fns)) return fns(data, headers, status);
        forEach(fns, function(fn) {
            data = fn(data, headers, status);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
            if (isDefined(value)) {
                useApplyAsync = !!value;
                return this;
            }
            return useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http");
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            function $http(requestConfig) {
                if (!angular.isObject(requestConfig)) {
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                };
                var chain = [ serverRequest, undefined ];
                var promise = $q.when(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        chain.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        chain.push(interceptor.response, interceptor.responseError);
                    }
                });
                while (chain.length) {
                    var thenFn = chain.shift();
                    var rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                promise.success = function(fn) {
                    promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                promise.error = function(fn) {
                    promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                return promise;
                function transformResponse(response) {
                    var resp = extend({}, response);
                    if (!response.data) {
                        resp.data = response.data;
                    } else {
                        resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    }
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function executeHeaderFns(headers) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function(headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn();
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders);
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.params);
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0);
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value)) return;
                    if (!isArray(value)) value = [ value ];
                    forEach(value, function(v) {
                        if (isObject(v)) {
                            if (isDate(v)) {
                                v = v.toISOString();
                            } else {
                                v = toJson(v);
                            }
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                if (parts.length > 0) {
                    url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&");
                }
                return url;
            }
        } ];
    }
    function createXhr() {
        return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();
            if (lowercase(method) == "jsonp") {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                    callbacks[callbackId].called = true;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text);
                    callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr();
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onload = function requestLoaded() {
                    var statusText = xhr.statusText || "";
                    var response = "response" in xhr ? xhr.response : xhr.responseText;
                    var status = xhr.status === 1223 ? 204 : xhr.status;
                    if (status === 0) {
                        status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0;
                    }
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                xhr.onerror = requestError;
                xhr.onabort = requestError;
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(post || null);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest);
            }
            function timeoutRequest() {
                jsonpDone && jsonpDone();
                xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                if (timeoutId !== undefined) {
                    $browserDefer.cancel(timeoutId);
                }
                jsonpDone = xhr = null;
                callback(status, response, headersString, statusText);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                removeEventListenerFn(script, "load", callback);
                removeEventListenerFn(script, "error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks[callbackId].called) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            addEventListenerFn(script, "load", callback);
            addEventListenerFn(script, "error", callback);
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = minErr("$interpolate");
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        parseFns.push($parse(exp, parseStringifyInterceptor));
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push("");
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                if (trustedContext && concat.length > 1) {
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
                }
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    };
                    var getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    var stringify = function(value) {
                        if (value == null) {
                            return "";
                        }
                        switch (typeof value) {
                          case "string":
                            break;

                          case "number":
                            value = "" + value;
                            break;

                          default:
                            value = toJson(value);
                        }
                        return value;
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (;i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr);
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener, objectEquality) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                if (isFunction(listener)) {
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                }
                                lastValue = currValue;
                            }, objectEquality);
                        }
                    });
                }
                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = getValue(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                count = isDefined(count) ? count : 0;
                promise.then(null, null, fn);
                promise.$$intervalId = setInterval(function tick() {
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
            }
            interval.cancel = function(promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled");
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "",
                        posSuf: "",
                        negPre: "(",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a",
                    ERANAMES: [ "Before Christ", "Anno Domini" ],
                    ERAS: [ "BC", "AD" ]
                },
                pluralCat: function(num) {
                    if (num === 1) {
                        return "one";
                    }
                    return "other";
                }
            };
        };
    }
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = relativeUrl.charAt(0) !== "/";
        if (prefixed) {
            relativeUrl = "/" + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
            return whole.substr(begin.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index == -1 ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if ((appUrl = beginsWith(appBase, url)) !== undefined) {
                prevAppUrl = appUrl;
                if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
                    rewrittenUrl = appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
                rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile == url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            var withoutHashUrl;
            if (withoutBaseUrl.charAt(0) === "#") {
                withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                if (isUndefined(withoutHashUrl)) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                withoutHashUrl = this.$$html5 ? withoutBaseUrl : "";
            }
            parseAppUrl(withoutHashUrl, this);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (url.indexOf(base) === 0) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) == stripHash(url)) {
                this.$$parse(url);
                return true;
            }
            return false;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase == stripHash(url)) {
                rewrittenUrl = url;
            } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "") this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) == "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    search = copy(search, {});
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) {
                throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            return this;
        };
    });
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) return this[property];
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
                html5Mode.enabled = mode;
                return this;
            } else if (isObject(mode)) {
                if (isBoolean(mode.enabled)) {
                    html5Mode.enabled = mode.enabled;
                }
                if (isBoolean(mode.requireBase)) {
                    html5Mode.requireBase = mode.requireBase;
                }
                if (isBoolean(mode.rewriteLinks)) {
                    html5Mode.rewriteLinks = mode.rewriteLinks;
                }
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            $location = new LocationMode(appBase, "#" + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on("click", function(event) {
                if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() != $browser.url()) {
                            $rootScope.$apply();
                            $window.angular["ff-684208-preventDefault"] = true;
                        }
                    }
                }
            });
            if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function(newUrl, newState) {
                $rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl) return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase) $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = trimEmptyHash($browser.url());
                var newUrl = trimEmptyHash($location.absUrl());
                var oldState = $browser.state();
                var currentReplace = $location.$$replace;
                var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl();
                        var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        if ($location.absUrl() !== newUrl) return;
                        if (defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $location.$$state = oldState;
                        } else {
                            if (urlOrStateChanged) {
                                setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                            }
                            afterLocationChange(oldUrl, oldState);
                        }
                    });
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                if (hasApply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function(arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.window === obj) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
        return obj;
    }
    var CALL = Function.prototype.call;
    var APPLY = Function.prototype.apply;
    var BIND = Function.prototype.bind;
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === CALL || obj === APPLY || obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    var CONSTANTS = createMap();
    forEach({
        "null": function() {
            return null;
        },
        "true": function() {
            return true;
        },
        "false": function() {
            return false;
        },
        undefined: function() {}
    }, function(constantGetter, name) {
        constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = true;
        CONSTANTS[name] = constantGetter;
    });
    CONSTANTS["this"] = function(self) {
        return self;
    };
    CONSTANTS["this"].sharedGetter = true;
    var OPERATORS = extend(createMap(), {
        "+": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            if (isDefined(a)) {
                if (isDefined(b)) {
                    return a + b;
                }
                return a;
            }
            return isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        },
        "=": true,
        "|": true
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    };
    var Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (ch === '"' || ch === "'") {
                    this.readString(ch);
                } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdent(ch)) {
                    this.readIdent();
                } else if (this.is(ch, "(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    });
                    this.index++;
                } else if (this.isWhitespace(ch)) {
                    this.index++;
                } else {
                    var ch2 = ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var op1 = OPERATORS[ch];
                    var op2 = OPERATORS[ch2];
                    var op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: true
                        });
                        this.index += token.length;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "" || ch === "";
        },
        isIdent: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch == "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch == "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: true,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (!(this.isIdent(ch) || this.isNumber(ch))) {
                    break;
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: true
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: true,
                        value: string
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    function isConstant(exp) {
        return exp.constant;
    }
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        sharedGetter: true,
        constant: true
    });
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.statements();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            value.literal = !!value.literal;
            value.constant = !!value.constant;
            return value;
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else if (this.peek().identifier && this.peek().text in CONSTANTS) {
                primary = CONSTANTS[this.consume().text];
            } else if (this.peek().identifier) {
                primary = this.identifier();
            } else if (this.peek().constant) {
                primary = this.constant();
            } else {
                this.throwError("not a primary expression", this.peek());
            }
            var next, context;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = this.functionCall(primary, context);
                    context = null;
                } else if (next.text === "[") {
                    context = primary;
                    primary = this.objectIndex(primary);
                } else if (next.text === ".") {
                    context = primary;
                    primary = this.fieldAccess(primary);
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (this.tokens.length === 0) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        consume: function(e1) {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
        },
        unaryFn: function(op, right) {
            var fn = OPERATORS[op];
            return extend(function $parseUnaryFn(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant,
                inputs: [ right ]
            });
        },
        binaryFn: function(left, op, right, isBranching) {
            var fn = OPERATORS[op];
            return extend(function $parseBinaryFn(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant,
                inputs: !isBranching && [ left, right ]
            });
        },
        identifier: function() {
            var id = this.consume().text;
            while (this.peek(".") && this.peekAhead(1).identifier && !this.peekAhead(2, "(")) {
                id += this.consume().text + this.consume().text;
            }
            return getterFn(id, this.options, this.text);
        },
        constant: function() {
            var value = this.consume().value;
            return extend(function $parseConstant() {
                return value;
            }, {
                constant: true,
                literal: true
            });
        },
        statements: function() {
            var statements = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) statements.push(this.filterChain());
                if (!this.expect(";")) {
                    return statements.length === 1 ? statements[0] : function $parseStatements(self, locals) {
                        var value;
                        for (var i = 0, ii = statements.length; i < ii; i++) {
                            value = statements[i](self, locals);
                        }
                        return value;
                    };
                }
            }
        },
        filterChain: function() {
            var left = this.expression();
            var token;
            while (token = this.expect("|")) {
                left = this.filter(left);
            }
            return left;
        },
        filter: function(inputFn) {
            var fn = this.$filter(this.consume().text);
            var argsFn;
            var args;
            if (this.peek(":")) {
                argsFn = [];
                args = [];
                while (this.expect(":")) {
                    argsFn.push(this.expression());
                }
            }
            var inputs = [ inputFn ].concat(argsFn || []);
            return extend(function $parseFilter(self, locals) {
                var input = inputFn(self, locals);
                if (args) {
                    args[0] = input;
                    var i = argsFn.length;
                    while (i--) {
                        args[i + 1] = argsFn[i](self, locals);
                    }
                    return fn.apply(undefined, args);
                }
                return fn(input);
            }, {
                constant: !fn.$stateful && inputs.every(isConstant),
                inputs: !fn.$stateful && inputs
            });
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var left = this.ternary();
            var right;
            var token;
            if (token = this.expect("=")) {
                if (!left.assign) {
                    this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token);
                }
                right = this.ternary();
                return extend(function $parseAssignment(scope, locals) {
                    return left.assign(scope, right(scope, locals), locals);
                }, {
                    inputs: [ left, right ]
                });
            }
            return left;
        },
        ternary: function() {
            var left = this.logicalOR();
            var middle;
            var token;
            if (token = this.expect("?")) {
                middle = this.assignment();
                if (this.consume(":")) {
                    var right = this.assignment();
                    return extend(function $parseTernary(self, locals) {
                        return left(self, locals) ? middle(self, locals) : right(self, locals);
                    }, {
                        constant: left.constant && middle.constant && right.constant
                    });
                }
            }
            return left;
        },
        logicalOR: function() {
            var left = this.logicalAND();
            var token;
            while (token = this.expect("||")) {
                left = this.binaryFn(left, token.text, this.logicalAND(), true);
            }
            return left;
        },
        logicalAND: function() {
            var left = this.equality();
            var token;
            while (token = this.expect("&&")) {
                left = this.binaryFn(left, token.text, this.equality(), true);
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
                left = this.binaryFn(left, token.text, this.relational());
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
                left = this.binaryFn(left, token.text, this.additive());
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = this.binaryFn(left, token.text, this.multiplicative());
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = this.binaryFn(left, token.text, this.unary());
            }
            return left;
        },
        unary: function() {
            var token;
            if (this.expect("+")) {
                return this.primary();
            } else if (token = this.expect("-")) {
                return this.binaryFn(Parser.ZERO, token.text, this.unary());
            } else if (token = this.expect("!")) {
                return this.unaryFn(token.text, this.unary());
            } else {
                return this.primary();
            }
        },
        fieldAccess: function(object) {
            var getter = this.identifier();
            return extend(function $parseFieldAccess(scope, locals, self) {
                var o = self || object(scope, locals);
                return o == null ? undefined : getter(o);
            }, {
                assign: function(scope, value, locals) {
                    var o = object(scope, locals);
                    if (!o) object.assign(scope, o = {}, locals);
                    return getter.assign(o, value);
                }
            });
        },
        objectIndex: function(obj) {
            var expression = this.text;
            var indexFn = this.expression();
            this.consume("]");
            return extend(function $parseObjectIndex(self, locals) {
                var o = obj(self, locals), i = indexFn(self, locals), v;
                ensureSafeMemberName(i, expression);
                if (!o) return undefined;
                v = ensureSafeObject(o[i], expression);
                return v;
            }, {
                assign: function(self, value, locals) {
                    var key = ensureSafeMemberName(indexFn(self, locals), expression);
                    var o = ensureSafeObject(obj(self, locals), expression);
                    if (!o) obj.assign(self, o = {}, locals);
                    return o[key] = value;
                }
            });
        },
        functionCall: function(fnGetter, contextGetter) {
            var argsFn = [];
            if (this.peekToken().text !== ")") {
                do {
                    argsFn.push(this.expression());
                } while (this.expect(","));
            }
            this.consume(")");
            var expressionText = this.text;
            var args = argsFn.length ? [] : null;
            return function $parseFunctionCall(scope, locals) {
                var context = contextGetter ? contextGetter(scope, locals) : isDefined(contextGetter) ? undefined : scope;
                var fn = fnGetter(scope, locals, context) || noop;
                if (args) {
                    var i = argsFn.length;
                    while (i--) {
                        args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
                    }
                }
                ensureSafeObject(context, expressionText);
                ensureSafeFunction(fn, expressionText);
                var v = fn.apply ? fn.apply(context, args) : fn(args[0], args[1], args[2], args[3], args[4]);
                if (args) {
                    args.length = 0;
                }
                return ensureSafeObject(v, expressionText);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [];
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    elementFns.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("]");
            return extend(function $parseArrayLiteral(self, locals) {
                var array = [];
                for (var i = 0, ii = elementFns.length; i < ii; i++) {
                    array.push(elementFns[i](self, locals));
                }
                return array;
            }, {
                literal: true,
                constant: elementFns.every(isConstant),
                inputs: elementFns
            });
        },
        object: function() {
            var keys = [], valueFns = [];
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    var token = this.consume();
                    if (token.constant) {
                        keys.push(token.value);
                    } else if (token.identifier) {
                        keys.push(token.text);
                    } else {
                        this.throwError("invalid key", token);
                    }
                    this.consume(":");
                    valueFns.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("}");
            return extend(function $parseObjectLiteral(self, locals) {
                var object = {};
                for (var i = 0, ii = valueFns.length; i < ii; i++) {
                    object[keys[i]] = valueFns[i](self, locals);
                }
                return object;
            }, {
                literal: true,
                constant: valueFns.every(isConstant),
                inputs: valueFns
            });
        }
    };
    function setter(obj, locals, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        ensureSafeObject(locals, fullExp);
        var element = path.split("."), key;
        for (var i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = i === 0 && locals && locals[key] || obj[key];
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = ensureSafeObject(propertyObj, fullExp);
        }
        key = ensureSafeMemberName(element.shift(), fullExp);
        ensureSafeObject(obj[key], fullExp);
        obj[key] = setValue;
        return setValue;
    }
    var getterFnCacheDefault = createMap();
    var getterFnCacheExpensive = createMap();
    function isPossiblyDangerousMemberName(name) {
        return name == "constructor";
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
        ensureSafeMemberName(key0, fullExp);
        ensureSafeMemberName(key1, fullExp);
        ensureSafeMemberName(key2, fullExp);
        ensureSafeMemberName(key3, fullExp);
        ensureSafeMemberName(key4, fullExp);
        var eso = function(o) {
            return ensureSafeObject(o, fullExp);
        };
        var eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity;
        var eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity;
        var eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity;
        var eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity;
        var eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity;
        return function cspSafeGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            if (pathVal == null) return pathVal;
            pathVal = eso0(pathVal[key0]);
            if (!key1) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso1(pathVal[key1]);
            if (!key2) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso2(pathVal[key2]);
            if (!key3) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso3(pathVal[key3]);
            if (!key4) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso4(pathVal[key4]);
            return pathVal;
        };
    }
    function getterFnWithEnsureSafeObject(fn, fullExpression) {
        return function(s, l) {
            return fn(s, l, ensureSafeObject, fullExpression);
        };
    }
    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks;
        var getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault;
        var fn = getterFnCache[path];
        if (fn) return fn;
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp) {
            if (pathKeysLength < 6) {
                fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks);
            } else {
                fn = function cspSafeGetter(scope, locals) {
                    var i = 0, val;
                    do {
                        val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, expensiveChecks)(scope, locals);
                        locals = undefined;
                        scope = val;
                    } while (i < pathKeysLength);
                    return val;
                };
            }
        } else {
            var code = "";
            if (expensiveChecks) {
                code += "s = eso(s, fe);\nl = eso(l, fe);\n";
            }
            var needsEnsureSafeObject = expensiveChecks;
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp);
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + "." + key;
                if (expensiveChecks || isPossiblyDangerousMemberName(key)) {
                    lookupJs = "eso(" + lookupJs + ", fe)";
                    needsEnsureSafeObject = true;
                }
                code += "if(s == null) return undefined;\n" + "s=" + lookupJs + ";\n";
            });
            code += "return s;";
            var evaledFnGetter = new Function("s", "l", "eso", "fe", code);
            evaledFnGetter.toString = valueFn(code);
            if (needsEnsureSafeObject) {
                evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp);
            }
            fn = evaledFnGetter;
        }
        fn.sharedGetter = true;
        fn.assign = function(self, value, locals) {
            return setter(self, locals, path, value, path);
        };
        getterFnCache[path] = fn;
        return fn;
    }
    var objectValueOf = Object.prototype.valueOf;
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = [ "$filter", "$sniffer", function($filter, $sniffer) {
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: false
            }, $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: true
            };
            function wrapSharedExpression(exp) {
                var wrapped = exp;
                if (exp.sharedGetter) {
                    wrapped = function $parseWrapper(self, locals) {
                        return exp(self, locals);
                    };
                    wrapped.literal = exp.literal;
                    wrapped.constant = exp.constant;
                    wrapped.assign = exp.assign;
                }
                return wrapped;
            }
            return function $parse(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    cacheKey = exp = exp.trim();
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                            oneTime = true;
                            exp = exp.substring(2);
                        }
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                        var lexer = new Lexer(parseOptions);
                        var parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp);
                        if (parsedExpression.constant) {
                            parsedExpression.$$watchDelegate = constantWatchDelegate;
                        } else if (oneTime) {
                            parsedExpression = wrapSharedExpression(parsedExpression);
                            parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                        } else if (parsedExpression.inputs) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            };
            function collectExpressionInputs(inputs, list) {
                for (var i = 0, ii = inputs.length; i < ii; i++) {
                    var input = inputs[i];
                    if (!input.constant) {
                        if (input.inputs) {
                            collectExpressionInputs(input.inputs, list);
                        } else if (list.indexOf(input) === -1) {
                            list.push(input);
                        }
                    }
                }
                return list;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === "object") {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === "object") {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var inputExpressions = parsedExpression.$$inputs || (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValue = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValue)) {
                            lastResult = parsedExpression(scope);
                            oldInputValue = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality);
                }
                var oldInputValueOfValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope);
                    }
                    return lastResult;
                }, listener, objectEquality);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    if (isDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isDefined(lastValue)) {
                                unwatch();
                            }
                        });
                    }
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.call(this, value, old, scope);
                    }
                    if (isAllDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isAllDefined(lastValue)) unwatch();
                        });
                    }
                }, objectEquality);
                function isAllDefined(value) {
                    var allDefined = true;
                    forEach(value, function(val) {
                        if (!isDefined(val)) allDefined = false;
                    });
                    return allDefined;
                }
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function constantWatch(scope) {
                    return parsedExpression(scope);
                }, function constantListener(value, old, scope) {
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate;
                var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                var fn = regularWatch ? function regularInterceptedExpression(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    return interceptorFn(value, scope, locals);
                } : function oneTimeInterceptedExpression(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    var result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                    fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                } else if (!interceptorFn.$stateful) {
                    fn.$$watchDelegate = inputsWatchDelegate;
                    fn.inputs = [ parsedExpression ];
                }
                return fn;
            }
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr("$q", TypeError);
        function callOnce(self, resolveFn, rejectFn) {
            var called = false;
            function wrap(fn) {
                return function(value) {
                    if (called) return;
                    called = true;
                    fn.call(self, value);
                };
            }
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        var defer = function() {
            return new Deferred();
        };
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                return result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, true, callback);
                }, function(error) {
                    return handleCallback(error, false, callback);
                }, progressBack);
            }
        };
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                promise = pending[i][0];
                fn = pending[i][state.status];
                try {
                    if (isFunction(fn)) {
                        promise.resolve(fn(state.value));
                    } else if (state.status === 1) {
                        promise.resolve(state.value);
                    } else {
                        promise.reject(state.value);
                    }
                } catch (e) {
                    promise.reject(e);
                    exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            if (state.processScheduled || !state.pending) return;
            state.processScheduled = true;
            nextTick(function() {
                processQueue(state);
            });
        }
        function Deferred() {
            this.promise = new Promise();
            this.resolve = simpleBind(this, this.resolve);
            this.reject = simpleBind(this, this.reject);
            this.notify = simpleBind(this, this.notify);
        }
        Deferred.prototype = {
            resolve: function(val) {
                if (this.promise.$$state.status) return;
                if (val === this.promise) {
                    this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                } else {
                    this.$$resolve(val);
                }
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    if (isObject(val) || isFunction(val)) then = val && val.then;
                    if (isFunction(then)) {
                        this.promise.$$state.status = -1;
                        then.call(val, fns[0], fns[1], this.notify);
                    } else {
                        this.promise.$$state.value = val;
                        this.promise.$$state.status = 1;
                        scheduleProcessQueue(this.promise.$$state);
                    }
                } catch (e) {
                    fns[1](e);
                    exceptionHandler(e);
                }
            },
            reject: function(reason) {
                if (this.promise.$$state.status) return;
                this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason;
                this.promise.$$state.status = 2;
                scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                    nextTick(function() {
                        var callback, result;
                        for (var i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0];
                            callback = callbacks[i][3];
                            try {
                                result.notify(isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
            }
        };
        var reject = function(reason) {
            var result = new Deferred();
            result.reject(reason);
            return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
            var result = new Deferred();
            if (resolved) {
                result.resolve(value);
            } else {
                result.reject(value);
            }
            return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                if (isFunction(callback)) callbackOutput = callback();
            } catch (e) {
                return makePromise(e, false);
            }
            if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                    return makePromise(value, isResolved);
                }, function(error) {
                    return makePromise(error, false);
                });
            } else {
                return makePromise(value, isResolved);
            }
        };
        var when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            result.resolve(value);
            return result.promise.then(callback, errback, progressBack);
        };
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                when(promise).then(function(value) {
                    if (results.hasOwnProperty(key)) return;
                    results[key] = value;
                    if (!--counter) deferred.resolve(results);
                }, function(reason) {
                    if (results.hasOwnProperty(key)) return;
                    deferred.reject(reason);
                });
            });
            if (counter === 0) {
                deferred.resolve(results);
            }
            return deferred.promise;
        }
        var $Q = function Q(resolver) {
            if (!isFunction(resolver)) {
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            if (!(this instanceof Q)) {
                return new Q(resolver);
            }
            var deferred = new Deferred();
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            resolver(resolveFn, rejectFn);
            return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.all = all;
        return $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$id = nextUid();
                this.$$ChildScope = null;
            }
            ChildScope.prototype = parent;
            return ChildScope;
        }
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = true;
            }
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = createChildScopeClass(this);
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent != this) child.$on("$destroy", destroyChildScope);
                    return child;
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, listener, objectEquality, get);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        watcher.fn = noop;
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                    }
                    array.unshift(watcher);
                    return function deregisterWatch() {
                        arrayRemove(array, watcher);
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function() {
                            if (shouldCall) listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                            newValues[i] = value;
                            oldValues[i] = oldValue;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        if (firstRun) {
                            firstRun = false;
                            listener(newValues, newValues, self);
                        } else {
                            listener(newValues, oldValues, self);
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function(obj, listener) {
                    $watchCollectionInterceptor.$stateful = true;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue)) return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (newValue.hasOwnProperty(key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!newValue.hasOwnProperty(key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        while (asyncQueue.length) {
                            try {
                                asyncTask = asyncQueue.shift();
                                asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) {
                                length = watchers.length;
                                while (length--) {
                                    try {
                                        watch = watchers[length];
                                        if (watch) {
                                            if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                watch.fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueue.length) {
                        try {
                            postDigestQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) return;
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                    if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function() {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function() {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        return this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null;
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            event.currentScope = null;
                            return event;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                    if (!target.$$listenerCount[name]) return event;
                    var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    });
                }
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal;
                normalizedVal = urlResolve(uri).href;
                if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                    return "unsafe:" + normalizedVal;
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", function($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function(value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
                if (android && (!transitions || !animations)) {
                    transitions = isString(document.body.style.webkitTransition);
                    animations = isString(document.body.style.webkitAnimation);
                }
            }
            return {
                history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                hasEvent: function(event) {
                    if (event === "input" && msie <= 11) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    var $compileMinErr = minErr("$compile");
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", function($templateCache, $http, $q) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions)["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return response.data;
                }, handleError);
                function handleError(resp) {
                    if (!ignoreRequestError) {
                        throw $compileMinErr("tpload", "Failed to load template: {0}", tpl);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    if (dataBinding) {
                        forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) != -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function(element, expression, opt_exactMatch) {
                var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=";
                    var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function() {
                return $location.url();
            };
            testability.setLocation = function(url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                var skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled");
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        } ];
    }
    var urlParsingNode = document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    function urlResolve(url) {
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var predicateFn;
            var matchAgainstAnyProp;
            switch (typeof expression) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "number":
              case "string":
                matchAgainstAnyProp = true;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return array.filter(predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && "$" in expression;
        var predicateFn;
        if (comparator === true) {
            comparator = equals;
        } else if (!isFunction(comparator)) {
            comparator = function(actual, expected) {
                if (isObject(actual) || isObject(expected)) {
                    return false;
                }
                actual = lowercase("" + actual);
                expected = lowercase("" + expected);
                return actual.indexOf(expected) !== -1;
            };
        }
        predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject(item)) {
                return deepCompare(item, expression.$, comparator, false);
            }
            return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = actual !== null ? typeof actual : "null";
        var expectedType = expected !== null ? typeof expected : "null";
        if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, matchAgainstAnyProp);
            });
        }
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    if (key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, true)) {
                        return true;
                    }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === "object") {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                        continue;
                    }
                    var matchAnyProperty = key === "$";
                    var actualVal = matchAnyProperty ? actual : actual[key];
                    if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                        return false;
                    }
                }
                return true;
            } else {
                return comparator(actual, expected);
            }
            break;

          case "function":
            return false;

          default:
            return comparator(actual, expected);
        }
    }
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
                fractionSize = formats.PATTERNS[1].maxFrac;
            }
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    var DECIMAL_SEP = ".";
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isFinite(number) || isObject(number)) return "";
        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [];
        var hasExponent = false;
        if (numStr.indexOf("e") !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            if (match && match[2] == "-" && match[3] > fractionSize + 1) {
                number = 0;
            } else {
                formatedText = numStr;
                hasExponent = true;
            }
        }
        if (!hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) {
                pos = whole.length - lgroup;
                for (i = 0; i < pos; i++) {
                    if ((pos - i) % group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }
            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i) % lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }
            while (fraction.length < fractionSize) {
                fraction += "0";
            }
            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
            if (fractionSize > 0 && number < 1) {
                formatedText = number.toFixed(fractionSize);
                number = parseFloat(formatedText);
            }
        }
        if (number === 0) {
            isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        if (num < 0) {
            neg = "-";
            num = -num;
        }
        num = "" + num;
        while (num.length < digits) num = "0" + num;
        if (trim) num = num.substr(num.length - digits);
        return neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) value += offset;
            if (value === 0 && offset == -12) value = 12;
            return padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name]();
            var get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset();
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, true),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = int(match[9] + match[10]);
                    tzMin = int(match[9] + match[11]);
                }
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour;
                var m = int(match[5] || 0) - tzMin;
                var s = int(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format, timezone) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date)) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            if (timezone && timezone === "UTC") {
                date = new Date(date.getTime());
                date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            if (isUndefined(spacing)) {
                spacing = 2;
            }
            return toJson(object, spacing);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit) {
            if (isNumber(input)) input = input.toString();
            if (!isArray(input) && !isString(input)) return input;
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = int(limit);
            }
            if (limit) {
                return limit > 0 ? input.slice(0, limit) : input.slice(limit);
            } else {
                return isString(input) ? "" : [];
            }
        };
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            if (!isArrayLike(array)) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ];
            if (sortPredicate.length === 0) {
                sortPredicate = [ "+" ];
            }
            sortPredicate = sortPredicate.map(function(predicate) {
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
                        descending = predicate.charAt(0) == "-";
                        predicate = predicate.substring(1);
                    }
                    if (predicate === "") {
                        return reverseComparator(compare, descending);
                    }
                    get = $parse(predicate);
                    if (get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key]);
                        }, descending);
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return descending ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function isPrimitive(value) {
                switch (typeof value) {
                  case "number":
                  case "boolean":
                  case "string":
                    return true;

                  default:
                    return false;
                }
            }
            function objectToString(value) {
                if (value === null) return "null";
                if (typeof value.valueOf === "function") {
                    value = value.valueOf();
                    if (isPrimitive(value)) return value;
                }
                if (typeof value.toString === "function") {
                    value = value.toString();
                    if (isPrimitive(value)) return value;
                }
                return "";
            }
            function compare(v1, v2) {
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 === t2 && t1 === "object") {
                    v1 = objectToString(v1);
                    v2 = objectToString(v2);
                }
                if (t1 === t2) {
                    if (t1 === "string") {
                        v1 = v1.toLowerCase();
                        v2 = v2.toLowerCase();
                    }
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        };
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref && !attr.name) {
                return function(scope, element) {
                    if (element[0].nodeName.toLowerCase() !== "a") return;
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple") return;
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: function(scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value);
                    });
                }
            };
        };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) {
                            attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            return;
                        }
                    }
                    scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [];
        var parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        };
        form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        };
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            controls.push(control);
            if (control.$name) {
                form[control.$name] = control;
            }
        };
        form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            if (form[oldName] === control) {
                delete form[oldName];
            }
            form[newName] = control;
            control.$name = newName;
        };
        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control);
            });
            arrayRemove(controls, control);
        };
        addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    object[property] = [ controller ];
                } else {
                    var index = list.indexOf(controller);
                    if (index === -1) {
                        list.push(controller);
                    }
                }
            },
            unset: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    return;
                }
                arrayRemove(list, controller);
                if (list.length === 0) {
                    delete object[property];
                }
            },
            parentForm: parentForm,
            $animate: $animate
        });
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS);
            $animate.addClass(element, DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            parentForm.$setDirty();
        };
        form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            form.$submitted = false;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
        form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        };
        form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS);
            form.$submitted = true;
            parentForm.$setSubmitted();
        };
    }
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function ngFormCompile(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, controller) {
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = controller.$$parentForm;
                            if (nameAttr) {
                                setter(scope, null, controller.$name, controller, controller.$name);
                                attr.$observe(nameAttr, function(newValue) {
                                    if (controller.$name === newValue) return;
                                    setter(scope, null, controller.$name, undefined, controller.$name);
                                    parentFormCtrl.$$renameControl(controller, newValue);
                                    setter(scope, null, controller.$name, controller, controller.$name);
                                });
                            }
                            formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller);
                                if (nameAttr) {
                                    setter(scope, null, attr[nameAttr], undefined, controller.$name);
                                }
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
    var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function(data) {
                composing = true;
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var listener = function(ev) {
            if (timeout) {
                $browser.defer.cancel(timeout);
                timeout = null;
            }
            if (composing) return;
            var value = element.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var timeout;
            var deferListener = function(ev, input, origValue) {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (!input || input.value !== origValue) {
                            listener(ev);
                        }
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener);
            }
        }
        element.on("change", listener);
        ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
            return isoWeek;
        }
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) {
                return iso;
            }
            if (isString(iso)) {
                if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                    iso = iso.substring(1, iso.length - 1);
                }
                if (ISO_DATE_REGEXP.test(iso)) {
                    return new Date(iso);
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    parts.shift();
                    if (date) {
                        map = {
                            yyyy: date.getFullYear(),
                            MM: date.getMonth() + 1,
                            dd: date.getDate(),
                            HH: date.getHours(),
                            mm: date.getMinutes(),
                            ss: date.getSeconds(),
                            sss: date.getMilliseconds() / 1e3
                        };
                    } else {
                        map = {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        };
                    }
                    forEach(parts, function(part, index) {
                        if (index < mapping.length) {
                            map[mapping[index]] = +part;
                        }
                    });
                    return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            var previousDate;
            ctrl.$$parserName = type;
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    if (timezone === "UTC") {
                        parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
                    }
                    return parsedDate;
                }
                return undefined;
            });
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) {
                    throw $ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                }
                if (isValidDate(value)) {
                    previousDate = value;
                    if (previousDate && timezone === "UTC") {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset);
                    }
                    return $filter("date")(value, format, timezone);
                } else {
                    previousDate = null;
                    return "";
                }
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                };
                attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                };
                attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined;
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput && !validity.typeMismatch ? undefined : value;
            });
        }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = "number";
        ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value)) return null;
            if (NUMBER_REGEXP.test(value)) return parseFloat(value);
            return undefined;
        });
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) {
                    throw $ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                }
                value = value.toString();
            }
            return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            };
            attr.$observe("min", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
            };
            attr.$observe("max", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "url";
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "email";
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        var listener = function(ev) {
            if (element[0].checked) {
                ctrl.$setViewValue(attr.value, ev && ev.type);
            }
        };
        element.on("click", listener);
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
                throw minErr("ngModel")("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
            }
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
        var listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener);
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value === false;
        };
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    } ];
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue));
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value);
                        });
                    };
                }
            }
        };
    };
    var ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                    return (value || "").toString();
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ];
    var ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    function classDirective(name, selector) {
        name = "ngClass" + name;
        return [ "$animate", function($animate) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, true);
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    });
                    if (name !== "ngClass") {
                        scope.$watch("$index", function($index, old$index) {
                            var mod = $index & 1;
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes);
                            }
                        });
                    }
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {};
                        var classesToUpdate = [];
                        forEach(classes, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        element.data("$classCounts", classCounts);
                        return classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses);
                        var toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1);
                        toRemove = digestClassCounts(toRemove, -1);
                        if (toAdd && toAdd.length) {
                            $animate.addClass(element, toAdd);
                        }
                        if (toRemove && toRemove.length) {
                            $animate.removeClass(element, toRemove);
                        }
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === true || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (!oldVal) {
                                addClasses(newClasses);
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal);
                                updateClasses(oldClasses, newClasses);
                            }
                        }
                        oldVal = shallowCopy(newVal);
                    }
                }
            };
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) {
                    return classVal;
                } else if (isString(classVal)) {
                    return classVal.split(" ");
                } else if (isObject(classVal)) {
                    var classes = [];
                    forEach(classVal, function(v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "));
                        }
                    });
                    return classes;
                }
                return classVal;
            }
        } ];
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, true);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function(clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ");
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).then(function() {
                                previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", "$sce", function($templateRequest, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).then(function() {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
                        var afterAnimation = function() {
                            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function(response) {
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded", src);
                                scope.$eval(onloadExp);
                            }, function() {
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit("$includeContentError", src);
                                }
                            });
                            scope.$emit("$includeContentRequested", src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (/SVG/.test($element[0].toString())) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ";
                var trimValues = attr.ngTrim !== "false";
                var separator = trimValues ? trim(ngList) : ngList;
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trimValues ? trim(value) : value);
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(ngList);
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending";
    var $ngModelMinErr = new minErr("ngModel");
    var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || "", false)($scope);
        var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
        this.$$setOptions = function(options) {
            ctrl.$options = options;
            if (options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    if (isFunction(modelValue)) {
                        modelValue = invokeModelGetter($scope);
                    }
                    return modelValue;
                };
                ngModelSet = function($scope, newValue) {
                    if (isFunction(parsedNgModel($scope))) {
                        invokeModelSetter($scope, {
                            $$$p: ctrl.$modelValue
                        });
                    } else {
                        parsedNgModelAssign($scope, ctrl.$modelValue);
                    }
                };
            } else if (!parsedNgModel.assign) {
                throw $ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
            }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = true;
            },
            unset: function(object, property) {
                delete object[property];
            },
            parentForm: parentForm,
            $animate: $animate
        });
        this.$setPristine = function() {
            ctrl.$dirty = false;
            ctrl.$pristine = true;
            $animate.removeClass($element, DIRTY_CLASS);
            $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
            ctrl.$dirty = true;
            ctrl.$pristine = false;
            $animate.removeClass($element, PRISTINE_CLASS);
            $animate.addClass($element, DIRTY_CLASS);
            parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            ctrl.$touched = false;
            ctrl.$untouched = true;
            $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
            ctrl.$touched = true;
            ctrl.$untouched = false;
            $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
            ctrl.$render();
        };
        this.$validate = function() {
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                return;
            }
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = ctrl.$$rawModelValue;
            var prevValid = ctrl.$valid;
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                if (!allowInvalid && prevValid !== allValid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    if (ctrl.$modelValue !== prevModelValue) {
                        ctrl.$$writeModelToScope();
                    }
                }
            });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            if (!processParseErrors()) {
                validationDone(false);
                return;
            }
            if (!processSyncValidators()) {
                validationDone(false);
                return;
            }
            processAsyncValidators();
            function processParseErrors() {
                var errorKey = ctrl.$$parserName || "parse";
                if (parserValid === undefined) {
                    setValidity(errorKey, null);
                } else {
                    if (!parserValid) {
                        forEach(ctrl.$validators, function(v, name) {
                            setValidity(name, null);
                        });
                        forEach(ctrl.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        });
                    }
                    setValidity(errorKey, parserValid);
                    return parserValid;
                }
                return true;
            }
            function processSyncValidators() {
                var syncValidatorsValid = true;
                forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result;
                    setValidity(name, result);
                });
                if (!syncValidatorsValid) {
                    forEach(ctrl.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    });
                    return false;
                }
                return true;
            }
            function processAsyncValidators() {
                var validatorPromises = [];
                var allValid = true;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) {
                        throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    }
                    setValidity(name, undefined);
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, true);
                    }, function(error) {
                        allValid = false;
                        setValidity(name, false);
                    }));
                });
                if (!validatorPromises.length) {
                    validationDone(true);
                } else {
                    $q.all(validatorPromises).then(function() {
                        validationDone(allValid);
                    }, noop);
                }
            }
            function setValidity(name, isValid) {
                if (localValidationRunId === currentValidationRunId) {
                    ctrl.$setValidity(name, isValid);
                }
            }
            function validationDone(allValid) {
                if (localValidationRunId === currentValidationRunId) {
                    doneCallback(allValid);
                }
            }
        };
        this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce);
            if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !ctrl.$$hasNativeValidators)) {
                return;
            }
            ctrl.$$lastCommittedViewValue = viewValue;
            if (ctrl.$pristine) {
                this.$setDirty();
            }
            this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = viewValue;
            parserValid = isUndefined(modelValue) ? undefined : true;
            if (parserValid) {
                for (var i = 0; i < ctrl.$parsers.length; i++) {
                    modelValue = ctrl.$parsers[i](modelValue);
                    if (isUndefined(modelValue)) {
                        parserValid = false;
                        break;
                    }
                }
            }
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                ctrl.$modelValue = ngModelGet($scope);
            }
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue;
            if (allowInvalid) {
                ctrl.$modelValue = modelValue;
                writeToModelIfNeeded();
            }
            ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                if (!allowInvalid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    writeToModelIfNeeded();
                }
            });
            function writeToModelIfNeeded() {
                if (ctrl.$modelValue !== prevModelValue) {
                    ctrl.$$writeModelToScope();
                }
            }
        };
        this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue);
            forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        };
        this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value;
            if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                ctrl.$$debounceViewValueCommit(trigger);
            }
        };
        this.$$debounceViewValueCommit = function(trigger) {
            var debounceDelay = 0, options = ctrl.$options, debounce;
            if (options && isDefined(options.debounce)) {
                debounce = options.debounce;
                if (isNumber(debounce)) {
                    debounceDelay = debounce;
                } else if (isNumber(debounce[trigger])) {
                    debounceDelay = debounce[trigger];
                } else if (isNumber(debounce["default"])) {
                    debounceDelay = debounce["default"];
                }
            }
            $timeout.cancel(pendingDebounce);
            if (debounceDelay) {
                pendingDebounce = $timeout(function() {
                    ctrl.$commitViewValue();
                }, debounceDelay);
            } else if ($rootScope.$$phase) {
                ctrl.$commitViewValue();
            } else {
                $scope.$apply(function() {
                    ctrl.$commitViewValue();
                });
            }
        };
        $scope.$watch(function ngModelWatch() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                parserValid = undefined;
                var formatters = ctrl.$formatters, idx = formatters.length;
                var viewValue = modelValue;
                while (idx--) {
                    viewValue = formatters[idx](viewValue);
                }
                if (ctrl.$viewValue !== viewValue) {
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                    ctrl.$render();
                    ctrl.$$runValidators(modelValue, viewValue, noop);
                }
            }
            return modelValue;
        });
    } ];
    var ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe("name", function(newValue) {
                            if (modelCtrl.$name !== newValue) {
                                formCtrl.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                            element.on(modelCtrl.$options.updateOn, function(ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                            });
                        }
                        element.on("blur", function(ev) {
                            if (modelCtrl.$touched) return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(modelCtrl.$setTouched);
                            } else {
                                scope.$apply(modelCtrl.$setTouched);
                            }
                        });
                    }
                };
            }
        };
    } ];
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    var ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = $scope.$eval($attrs.ngModelOptions);
                if (this.$options.updateOn !== undefined) {
                    this.$options.updateOnDefault = false;
                    this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                        that.$options.updateOnDefault = true;
                        return " ";
                    }));
                } else {
                    this.$options.updateOnDefault = true;
                }
            } ]
        };
    };
    function addSetValidityMethod(context) {
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
            if (state === undefined) {
                createAndSet("$pending", validationErrorKey, controller);
            } else {
                unsetAndCleanup("$pending", validationErrorKey, controller);
            }
            if (!isBoolean(state)) {
                unset(ctrl.$error, validationErrorKey, controller);
                unset(ctrl.$$success, validationErrorKey, controller);
            } else {
                if (state) {
                    unset(ctrl.$error, validationErrorKey, controller);
                    set(ctrl.$$success, validationErrorKey, controller);
                } else {
                    set(ctrl.$error, validationErrorKey, controller);
                    unset(ctrl.$$success, validationErrorKey, controller);
                }
            }
            if (ctrl.$pending) {
                cachedToggleClass(PENDING_CLASS, true);
                ctrl.$valid = ctrl.$invalid = undefined;
                toggleValidationCss("", null);
            } else {
                cachedToggleClass(PENDING_CLASS, false);
                ctrl.$valid = isObjectEmpty(ctrl.$error);
                ctrl.$invalid = !ctrl.$valid;
                toggleValidationCss("", ctrl.$valid);
            }
            var combinedState;
            if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                combinedState = undefined;
            } else if (ctrl.$error[validationErrorKey]) {
                combinedState = false;
            } else if (ctrl.$$success[validationErrorKey]) {
                combinedState = true;
            } else {
                combinedState = null;
            }
            toggleValidationCss(validationErrorKey, combinedState);
            parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
            if (!ctrl[name]) {
                ctrl[name] = {};
            }
            set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
            if (ctrl[name]) {
                unset(ctrl[name], value, controller);
            }
            if (isObjectEmpty(ctrl[name])) {
                ctrl[name] = undefined;
            }
        }
        function cachedToggleClass(className, switchValue) {
            if (switchValue && !classCache[className]) {
                $animate.addClass($element, className);
                classCache[className] = true;
            } else if (!switchValue && classCache[className]) {
                $animate.removeClass($element, className);
                classCache[className] = false;
            }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
    }
    function isObjectEmpty(obj) {
        if (obj) {
            for (var prop in obj) {
                return false;
            }
        }
        return true;
    }
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNaN(lastCount))) {
                        watchRemover();
                        watchRemover = scope.$watch(whensExpFns[count], updateElementText);
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || "");
                }
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
            return block.clone[0];
        };
        var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " ");
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                }
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                var hashFnLocals = {
                    $id: hashKey
                };
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    if (trackByExpGetter) {
                        trackByIdExpFn = function(key, value, index) {
                            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    }
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != "$") {
                                    collectionKeys.push(itemKey);
                                }
                            }
                            collectionKeys.sort();
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.scope) lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) != nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, jqLite(previousNode));
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ];
    var NG_HIDE_CLASS = "ng-hide";
    var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
    var ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watchCollection(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        });
    });
    var ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function ngSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                        $animate.cancel(previousLeaveAnimations[i]);
                    }
                    previousLeaveAnimations.length = 0;
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            selectedTransclude.transclude(function(caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [];
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
            }
            $transclude(function(clone) {
                $element.empty();
                $element.append(clone);
            });
        }
    });
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var ngOptionsMinErr = minErr("ngOptions");
    var ngOptionsDirective = valueFn({
        restrict: "A",
        terminal: true
    });
    var selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
                self.databound = $attrs.ngModel;
                self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_;
                    nullOption = nullOption_;
                    unknownOption = unknownOption_;
                };
                self.addOption = function(value, element) {
                    assertNotHasOwnProperty(value, '"option value"');
                    optionsMap[value] = true;
                    if (ngModelCtrl.$viewValue == value) {
                        $element.val(value);
                        if (unknownOption.parent()) unknownOption.remove();
                    }
                    if (element && element[0].hasAttribute("selected")) {
                        element[0].selected = true;
                    }
                };
                self.removeOption = function(value) {
                    if (this.hasOption(value)) {
                        delete optionsMap[value];
                        if (ngModelCtrl.$viewValue === value) {
                            this.renderUnknownOption(value);
                        }
                    }
                };
                self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal);
                    $element.prepend(unknownOption);
                    $element.val(unknownVal);
                    unknownOption.prop("selected", true);
                };
                self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                };
                $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                if (!ctrls[1]) return;
                var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, renderScheduled = false, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone();
                for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
                    if (children[i].value === "") {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                }
                selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
                if (multiple) {
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                }
                if (optionsExp) setupAsOptions(scope, element, ngModelCtrl); else if (multiple) setupAsMultiple(scope, element, ngModelCtrl); else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        if (selectCtrl.hasOption(viewValue)) {
                            if (unknownOption.parent()) unknownOption.remove();
                            selectElement.val(viewValue);
                            if (viewValue === "") emptyOption.prop("selected", true);
                        } else {
                            if (isUndefined(viewValue) && emptyOption) {
                                selectElement.val("");
                            } else {
                                selectCtrl.renderUnknownOption(viewValue);
                            }
                        }
                    };
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            if (unknownOption.parent()) unknownOption.remove();
                            ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = shallowCopy(ctrl.$viewValue);
                            ctrl.$render();
                        }
                    });
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    }
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], selectAs = / as /.test(match[0]) && match[1], selectAsFn = selectAs ? $parse(selectAs) : null, keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, trackKeysCache = {}, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ], locals = {};
                    if (nullOption) {
                        $compile(nullOption)(scope);
                        nullOption.removeClass("ng-scope");
                        nullOption.remove();
                    }
                    selectElement.empty();
                    selectElement.on("change", selectionChanged);
                    ctrl.$render = render;
                    scope.$watchCollection(valuesFn, scheduleRendering);
                    scope.$watchCollection(getLabels, scheduleRendering);
                    if (multiple) {
                        scope.$watchCollection(function() {
                            return ctrl.$modelValue;
                        }, scheduleRendering);
                    }
                    function callExpression(exprFn, key, value) {
                        locals[valueName] = value;
                        if (keyName) locals[keyName] = key;
                        return exprFn(scope, locals);
                    }
                    function selectionChanged() {
                        scope.$apply(function() {
                            var collection = valuesFn(scope) || [];
                            var viewValue;
                            if (multiple) {
                                viewValue = [];
                                forEach(selectElement.val(), function(selectedKey) {
                                    selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey;
                                    viewValue.push(getViewValue(selectedKey, collection[selectedKey]));
                                });
                            } else {
                                var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
                                viewValue = getViewValue(selectedKey, collection[selectedKey]);
                            }
                            ctrl.$setViewValue(viewValue);
                            render();
                        });
                    }
                    function getViewValue(key, value) {
                        if (key === "?") {
                            return undefined;
                        } else if (key === "") {
                            return null;
                        } else {
                            var viewValueFn = selectAsFn ? selectAsFn : valueFn;
                            return callExpression(viewValueFn, key, value);
                        }
                    }
                    function getLabels() {
                        var values = valuesFn(scope);
                        var toDisplay;
                        if (values && isArray(values)) {
                            toDisplay = new Array(values.length);
                            for (var i = 0, ii = values.length; i < ii; i++) {
                                toDisplay[i] = callExpression(displayFn, i, values[i]);
                            }
                            return toDisplay;
                        } else if (values) {
                            toDisplay = {};
                            for (var prop in values) {
                                if (values.hasOwnProperty(prop)) {
                                    toDisplay[prop] = callExpression(displayFn, prop, values[prop]);
                                }
                            }
                        }
                        return toDisplay;
                    }
                    function createIsSelectedFn(viewValue) {
                        var selectedSet;
                        if (multiple) {
                            if (trackFn && isArray(viewValue)) {
                                selectedSet = new HashMap([]);
                                for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++) {
                                    selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), true);
                                }
                            } else {
                                selectedSet = new HashMap(viewValue);
                            }
                        } else if (trackFn) {
                            viewValue = callExpression(trackFn, null, viewValue);
                        }
                        return function isSelected(key, value) {
                            var compareValueFn;
                            if (trackFn) {
                                compareValueFn = trackFn;
                            } else if (selectAsFn) {
                                compareValueFn = selectAsFn;
                            } else {
                                compareValueFn = valueFn;
                            }
                            if (multiple) {
                                return isDefined(selectedSet.remove(callExpression(compareValueFn, key, value)));
                            } else {
                                return viewValue === callExpression(compareValueFn, key, value);
                            }
                        };
                    }
                    function scheduleRendering() {
                        if (!renderScheduled) {
                            scope.$$postDigest(render);
                            renderScheduled = true;
                        }
                    }
                    function updateLabelMap(labelMap, label, added) {
                        labelMap[label] = labelMap[label] || 0;
                        labelMap[label] += added ? 1 : -1;
                    }
                    function render() {
                        renderScheduled = false;
                        var optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, viewValue = ctrl.$viewValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, key, value, groupLength, length, groupIndex, index, labelMap = {}, selected, isSelected = createIsSelectedFn(viewValue), anySelected = false, lastElement, element, label, optionId;
                        trackKeysCache = {};
                        for (index = 0; length = keys.length, index < length; index++) {
                            key = index;
                            if (keyName) {
                                key = keys[index];
                                if (key.charAt(0) === "$") continue;
                            }
                            value = values[key];
                            optionGroupName = callExpression(groupByFn, key, value) || "";
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = [];
                                optionGroupNames.push(optionGroupName);
                            }
                            selected = isSelected(key, value);
                            anySelected = anySelected || selected;
                            label = callExpression(displayFn, key, value);
                            label = isDefined(label) ? label : "";
                            optionId = trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index;
                            if (trackFn) {
                                trackKeysCache[optionId] = key;
                            }
                            optionGroup.push({
                                id: optionId,
                                label: label,
                                selected: selected
                            });
                        }
                        if (!multiple) {
                            if (nullOption || viewValue === null) {
                                optionGroups[""].unshift({
                                    id: "",
                                    label: "",
                                    selected: !anySelected
                                });
                            } else if (!anySelected) {
                                optionGroups[""].unshift({
                                    id: "?",
                                    label: "",
                                    selected: true
                                });
                            }
                        }
                        for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                            optionGroupName = optionGroupNames[groupIndex];
                            optionGroup = optionGroups[optionGroupName];
                            if (optionGroupsCache.length <= groupIndex) {
                                existingParent = {
                                    element: optGroupTemplate.clone().attr("label", optionGroupName),
                                    label: optionGroup.label
                                };
                                existingOptions = [ existingParent ];
                                optionGroupsCache.push(existingOptions);
                                selectElement.append(existingParent.element);
                            } else {
                                existingOptions = optionGroupsCache[groupIndex];
                                existingParent = existingOptions[0];
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr("label", existingParent.label = optionGroupName);
                                }
                            }
                            lastElement = null;
                            for (index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index];
                                if (existingOption = existingOptions[index + 1]) {
                                    lastElement = existingOption.element;
                                    if (existingOption.label !== option.label) {
                                        updateLabelMap(labelMap, existingOption.label, false);
                                        updateLabelMap(labelMap, option.label, true);
                                        lastElement.text(existingOption.label = option.label);
                                        lastElement.prop("label", existingOption.label);
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id);
                                    }
                                    if (lastElement[0].selected !== option.selected) {
                                        lastElement.prop("selected", existingOption.selected = option.selected);
                                        if (msie) {
                                            lastElement.prop("selected", existingOption.selected);
                                        }
                                    }
                                } else {
                                    if (option.id === "" && nullOption) {
                                        element = nullOption;
                                    } else {
                                        (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label);
                                    }
                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    });
                                    updateLabelMap(labelMap, option.label, true);
                                    if (lastElement) {
                                        lastElement.after(element);
                                    } else {
                                        existingParent.element.append(element);
                                    }
                                    lastElement = element;
                                }
                            }
                            index++;
                            while (existingOptions.length > index) {
                                option = existingOptions.pop();
                                updateLabelMap(labelMap, option.label, false);
                                option.element.remove();
                            }
                        }
                        while (optionGroupsCache.length > groupIndex) {
                            optionGroup = optionGroupsCache.pop();
                            for (index = 1; index < optionGroup.length; ++index) {
                                updateLabelMap(labelMap, optionGroup[index].label, false);
                            }
                            optionGroup[0].element.remove();
                        }
                        forEach(labelMap, function(count, label) {
                            if (count > 0) {
                                selectCtrl.addOption(label);
                            } else if (count < 0) {
                                selectCtrl.removeOption(label);
                            }
                        });
                    }
                }
            }
        };
    } ];
    var optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (!interpolateFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (!selectCtrl || !selectCtrl.databound) {
                        selectCtrl = nullSelectCtrl;
                    }
                    if (interpolateFn) {
                        scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                            attr.$set("value", newVal);
                            if (oldVal !== newVal) {
                                selectCtrl.removeOption(oldVal);
                            }
                            selectCtrl.addOption(newVal, element);
                        });
                    } else {
                        selectCtrl.addOption(attr.value, element);
                    }
                    element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ];
    var styleDirective = valueFn({
        restrict: "E",
        terminal: false
    });
    var requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true;
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                };
                attr.$observe("required", function() {
                    ctrl.$validate();
                });
            }
        };
    };
    var patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var regexp, patternExp = attr.ngPattern || attr.pattern;
                attr.$observe("pattern", function(regex) {
                    if (isString(regex) && regex.length > 0) {
                        regex = new RegExp("^" + regex + "$");
                    }
                    if (regex && !regex.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    }
                    regexp = regex || undefined;
                    ctrl.$validate();
                });
                ctrl.$validators.pattern = function(value) {
                    return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
                };
            }
        };
    };
    var maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var maxlength = -1;
                attr.$observe("maxlength", function(value) {
                    var intVal = int(value);
                    maxlength = isNaN(intVal) ? -1 : intVal;
                    ctrl.$validate();
                });
                ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                };
            }
        };
    };
    var minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var minlength = 0;
                attr.$observe("minlength", function(value) {
                    minlength = int(value) || 0;
                    ctrl.$validate();
                });
                ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                };
            }
        };
    };
    if (window.angular.bootstrap) {
        console.log("WARNING: Tried to load angular more than once.");
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });
})(window, document);

!window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>');
(function(window, angular, undefined) {
    "use strict";
    var $resourceMinErr = angular.$$minErr("$resource");
    var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$][0-9a-zA-Z_$]*)+$/;
    function isValidDottedPath(path) {
        return path != null && path !== "" && path !== "hasOwnProperty" && MEMBER_NAME_REGEX.test("." + path);
    }
    function lookupDottedPath(obj, path) {
        if (!isValidDottedPath(path)) {
            throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
        }
        var keys = path.split(".");
        for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {
            var key = keys[i];
            obj = obj !== null ? obj[key] : undefined;
        }
        return obj;
    }
    function shallowClearAndCopy(src, dst) {
        dst = dst || {};
        angular.forEach(dst, function(value, key) {
            delete dst[key];
        });
        for (var key in src) {
            if (src.hasOwnProperty(key) && !(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                dst[key] = src[key];
            }
        }
        return dst;
    }
    angular.module("ngResource", [ "ng" ]).provider("$resource", function() {
        var provider = this;
        this.defaults = {
            stripTrailingSlashes: true,
            actions: {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET",
                    isArray: true
                },
                remove: {
                    method: "DELETE"
                },
                "delete": {
                    method: "DELETE"
                }
            }
        };
        this.$get = [ "$http", "$q", function($http, $q) {
            var noop = angular.noop, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, isFunction = angular.isFunction;
            function encodeUriSegment(val) {
                return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
            }
            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
            }
            function Route(template, defaults) {
                this.template = template;
                this.defaults = extend({}, provider.defaults, defaults);
                this.urlParams = {};
            }
            Route.prototype = {
                setUrlParams: function(config, params, actionUrl) {
                    var self = this, url = actionUrl || self.template, val, encodedVal;
                    var urlParams = self.urlParams = {};
                    forEach(url.split(/\W/), function(param) {
                        if (param === "hasOwnProperty") {
                            throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                        }
                        if (!new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url)) {
                            urlParams[param] = true;
                        }
                    });
                    url = url.replace(/\\:/g, ":");
                    params = params || {};
                    forEach(self.urlParams, function(_, urlParam) {
                        val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
                        if (angular.isDefined(val) && val !== null) {
                            encodedVal = encodeUriSegment(val);
                            url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                                return encodedVal + p1;
                            });
                        } else {
                            url = url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                                if (tail.charAt(0) == "/") {
                                    return tail;
                                } else {
                                    return leadingSlashes + tail;
                                }
                            });
                        }
                    });
                    if (self.defaults.stripTrailingSlashes) {
                        url = url.replace(/\/+$/, "") || "/";
                    }
                    url = url.replace(/\/\.(?=\w+($|\?))/, ".");
                    config.url = url.replace(/\/\\\./, "/.");
                    forEach(params, function(value, key) {
                        if (!self.urlParams[key]) {
                            config.params = config.params || {};
                            config.params[key] = value;
                        }
                    });
                }
            };
            function resourceFactory(url, paramDefaults, actions, options) {
                var route = new Route(url, options);
                actions = extend({}, provider.defaults.actions, actions);
                function extractParams(data, actionParams) {
                    var ids = {};
                    actionParams = extend({}, paramDefaults, actionParams);
                    forEach(actionParams, function(value, key) {
                        if (isFunction(value)) {
                            value = value();
                        }
                        ids[key] = value && value.charAt && value.charAt(0) == "@" ? lookupDottedPath(data, value.substr(1)) : value;
                    });
                    return ids;
                }
                function defaultResponseInterceptor(response) {
                    return response.resource;
                }
                function Resource(value) {
                    shallowClearAndCopy(value || {}, this);
                }
                Resource.prototype.toJSON = function() {
                    var data = extend({}, this);
                    delete data.$promise;
                    delete data.$resolved;
                    return data;
                };
                forEach(actions, function(action, name) {
                    var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);
                    Resource[name] = function(a1, a2, a3, a4) {
                        var params = {}, data, success, error;
                        switch (arguments.length) {
                          case 4:
                            error = a4;
                            success = a3;

                          case 3:
                          case 2:
                            if (isFunction(a2)) {
                                if (isFunction(a1)) {
                                    success = a1;
                                    error = a2;
                                    break;
                                }
                                success = a2;
                                error = a3;
                            } else {
                                params = a1;
                                data = a2;
                                success = a3;
                                break;
                            }

                          case 1:
                            if (isFunction(a1)) success = a1; else if (hasBody) data = a1; else params = a1;
                            break;

                          case 0:
                            break;

                          default:
                            throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                        }
                        var isInstanceCall = this instanceof Resource;
                        var value = isInstanceCall ? data : action.isArray ? [] : new Resource(data);
                        var httpConfig = {};
                        var responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor;
                        var responseErrorInterceptor = action.interceptor && action.interceptor.responseError || undefined;
                        forEach(action, function(value, key) {
                            if (key != "params" && key != "isArray" && key != "interceptor") {
                                httpConfig[key] = copy(value);
                            }
                        });
                        if (hasBody) httpConfig.data = data;
                        route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                        var promise = $http(httpConfig).then(function(response) {
                            var data = response.data, promise = value.$promise;
                            if (data) {
                                if (angular.isArray(data) !== !!action.isArray) {
                                    throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to " + "contain an {1} but got an {2}", name, action.isArray ? "array" : "object", angular.isArray(data) ? "array" : "object");
                                }
                                if (action.isArray) {
                                    value.length = 0;
                                    forEach(data, function(item) {
                                        if (typeof item === "object") {
                                            value.push(new Resource(item));
                                        } else {
                                            value.push(item);
                                        }
                                    });
                                } else {
                                    shallowClearAndCopy(data, value);
                                    value.$promise = promise;
                                }
                            }
                            value.$resolved = true;
                            response.resource = value;
                            return response;
                        }, function(response) {
                            value.$resolved = true;
                            (error || noop)(response);
                            return $q.reject(response);
                        });
                        promise = promise.then(function(response) {
                            var value = responseInterceptor(response);
                            (success || noop)(value, response.headers);
                            return value;
                        }, responseErrorInterceptor);
                        if (!isInstanceCall) {
                            value.$promise = promise;
                            value.$resolved = false;
                            return value;
                        }
                        return promise;
                    };
                    Resource.prototype["$" + name] = function(params, success, error) {
                        if (isFunction(params)) {
                            error = success;
                            success = params;
                            params = {};
                        }
                        var result = Resource[name].call(this, params, this, success, error);
                        return result.$promise || result;
                    };
                });
                Resource.bind = function(additionalParamDefaults) {
                    return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
                };
                return Resource;
            }
            return resourceFactory;
        } ];
    });
})(window, window.angular);
(function(window, angular, undefined) {
    "use strict";
    angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
                element.data(NG_ANIMATE_CHILDREN, true);
            } else {
                scope.$watch(val, function(value) {
                    element.data(NG_ANIMATE_CHILDREN, !!value);
                });
            }
        };
    }).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
        var bod = $document[0].body;
        return function(fn) {
            return $$rAF(function() {
                var a = bod.offsetWidth + 1;
                fn();
            });
        };
    } ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
        var noop = angular.noop;
        var forEach = angular.forEach;
        var selectors = $animateProvider.$$selectors;
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_STATE = "$$ngAnimateState";
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        var NG_ANIMATE_CLASS_NAME = "ng-animate";
        var rootAnimateState = {
            running: true
        };
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType == ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function prepareElement(element) {
            return element && angular.element(element);
        }
        function stripCommentsFromElement(element) {
            return angular.element(extractElementNode(element));
        }
        function isMatchingElement(elm1, elm2) {
            return extractElementNode(elm1) == extractElementNode(elm2);
        }
        $provide.decorator("$animate", [ "$delegate", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", function($delegate, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document) {
            var globalAnimationCounter = 0;
            $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);
            $rootScope.$$postDigest(function() {
                $rootScope.$$postDigest(function() {
                    rootAnimateState.running = false;
                });
            });
            var classNameFilter = $animateProvider.classNameFilter();
            var isAnimatableClassName = !classNameFilter ? function() {
                return true;
            } : function(className) {
                return classNameFilter.test(className);
            };
            function blockElementAnimations(element) {
                var data = element.data(NG_ANIMATE_STATE) || {};
                data.running = true;
                element.data(NG_ANIMATE_STATE, data);
            }
            function lookup(name) {
                if (name) {
                    var matches = [], flagMap = {}, classes = name.substr(1).split(".");
                    if ($sniffer.transitions || $sniffer.animations) {
                        matches.push($injector.get(selectors[""]));
                    }
                    for (var i = 0; i < classes.length; i++) {
                        var klass = classes[i], selectorFactoryName = selectors[klass];
                        if (selectorFactoryName && !flagMap[klass]) {
                            matches.push($injector.get(selectorFactoryName));
                            flagMap[klass] = true;
                        }
                    }
                    return matches;
                }
            }
            function animationRunner(element, animationEvent, className) {
                var node = element[0];
                if (!node) {
                    return;
                }
                var isSetClassOperation = animationEvent == "setClass";
                var isClassBased = isSetClassOperation || animationEvent == "addClass" || animationEvent == "removeClass";
                var classNameAdd, classNameRemove;
                if (angular.isArray(className)) {
                    classNameAdd = className[0];
                    classNameRemove = className[1];
                    className = classNameAdd + " " + classNameRemove;
                }
                var currentClassName = element.attr("class");
                var classes = currentClassName + " " + className;
                if (!isAnimatableClassName(classes)) {
                    return;
                }
                var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [];
                var animationLookup = (" " + classes).replace(/\s+/g, ".");
                forEach(lookup(animationLookup), function(animationFactory) {
                    var created = registerAnimation(animationFactory, animationEvent);
                    if (!created && isSetClassOperation) {
                        registerAnimation(animationFactory, "addClass");
                        registerAnimation(animationFactory, "removeClass");
                    }
                });
                function registerAnimation(animationFactory, event) {
                    var afterFn = animationFactory[event];
                    var beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
                    if (afterFn || beforeFn) {
                        if (event == "leave") {
                            beforeFn = afterFn;
                            afterFn = null;
                        }
                        after.push({
                            event: event,
                            fn: afterFn
                        });
                        before.push({
                            event: event,
                            fn: beforeFn
                        });
                        return true;
                    }
                }
                function run(fns, cancellations, allCompleteFn) {
                    var animations = [];
                    forEach(fns, function(animation) {
                        animation.fn && animations.push(animation);
                    });
                    var count = 0;
                    function afterAnimationComplete(index) {
                        if (cancellations) {
                            (cancellations[index] || noop)();
                            if (++count < animations.length) return;
                            cancellations = null;
                        }
                        allCompleteFn();
                    }
                    forEach(animations, function(animation, index) {
                        var progress = function() {
                            afterAnimationComplete(index);
                        };
                        switch (animation.event) {
                          case "setClass":
                            cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress));
                            break;

                          case "addClass":
                            cancellations.push(animation.fn(element, classNameAdd || className, progress));
                            break;

                          case "removeClass":
                            cancellations.push(animation.fn(element, classNameRemove || className, progress));
                            break;

                          default:
                            cancellations.push(animation.fn(element, progress));
                            break;
                        }
                    });
                    if (cancellations && cancellations.length === 0) {
                        allCompleteFn();
                    }
                }
                return {
                    node: node,
                    event: animationEvent,
                    className: className,
                    isClassBased: isClassBased,
                    isSetClassOperation: isSetClassOperation,
                    before: function(allCompleteFn) {
                        beforeComplete = allCompleteFn;
                        run(before, beforeCancel, function() {
                            beforeComplete = noop;
                            allCompleteFn();
                        });
                    },
                    after: function(allCompleteFn) {
                        afterComplete = allCompleteFn;
                        run(after, afterCancel, function() {
                            afterComplete = noop;
                            allCompleteFn();
                        });
                    },
                    cancel: function() {
                        if (beforeCancel) {
                            forEach(beforeCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            beforeComplete(true);
                        }
                        if (afterCancel) {
                            forEach(afterCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            afterComplete(true);
                        }
                    }
                };
            }
            return {
                enter: function(element, parentElement, afterElement, doneCallback) {
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    blockElementAnimations(element);
                    $delegate.enter(element, parentElement, afterElement);
                    $rootScope.$$postDigest(function() {
                        element = stripCommentsFromElement(element);
                        performAnimation("enter", "ng-enter", element, parentElement, afterElement, noop, doneCallback);
                    });
                },
                leave: function(element, doneCallback) {
                    element = angular.element(element);
                    cancelChildAnimations(element);
                    blockElementAnimations(element);
                    $rootScope.$$postDigest(function() {
                        performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
                            $delegate.leave(element);
                        }, doneCallback);
                    });
                },
                move: function(element, parentElement, afterElement, doneCallback) {
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    cancelChildAnimations(element);
                    blockElementAnimations(element);
                    $delegate.move(element, parentElement, afterElement);
                    $rootScope.$$postDigest(function() {
                        element = stripCommentsFromElement(element);
                        performAnimation("move", "ng-move", element, parentElement, afterElement, noop, doneCallback);
                    });
                },
                addClass: function(element, className, doneCallback) {
                    element = angular.element(element);
                    element = stripCommentsFromElement(element);
                    performAnimation("addClass", className, element, null, null, function() {
                        $delegate.addClass(element, className);
                    }, doneCallback);
                },
                removeClass: function(element, className, doneCallback) {
                    element = angular.element(element);
                    element = stripCommentsFromElement(element);
                    performAnimation("removeClass", className, element, null, null, function() {
                        $delegate.removeClass(element, className);
                    }, doneCallback);
                },
                setClass: function(element, add, remove, doneCallback) {
                    element = angular.element(element);
                    element = stripCommentsFromElement(element);
                    performAnimation("setClass", [ add, remove ], element, null, null, function() {
                        $delegate.setClass(element, add, remove);
                    }, doneCallback);
                },
                enabled: function(value, element) {
                    switch (arguments.length) {
                      case 2:
                        if (value) {
                            cleanup(element);
                        } else {
                            var data = element.data(NG_ANIMATE_STATE) || {};
                            data.disabled = true;
                            element.data(NG_ANIMATE_STATE, data);
                        }
                        break;

                      case 1:
                        rootAnimateState.disabled = !value;
                        break;

                      default:
                        value = !rootAnimateState.disabled;
                        break;
                    }
                    return !!value;
                }
            };
            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
                var runner = animationRunner(element, animationEvent, className);
                if (!runner) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return;
                }
                className = runner.className;
                var elementEvents = angular.element._data(runner.node);
                elementEvents = elementEvents && elementEvents.events;
                if (!parentElement) {
                    parentElement = afterElement ? afterElement.parent() : element.parent();
                }
                var ngAnimateState = element.data(NG_ANIMATE_STATE) || {};
                var runningAnimations = ngAnimateState.active || {};
                var totalActiveAnimations = ngAnimateState.totalActive || 0;
                var lastAnimation = ngAnimateState.last;
                var skipAnimations;
                if (runner.isClassBased) {
                    skipAnimations = ngAnimateState.running || ngAnimateState.disabled || lastAnimation && !lastAnimation.isClassBased;
                }
                if (skipAnimations || animationsDisabled(element, parentElement)) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return;
                }
                var skipAnimation = false;
                if (totalActiveAnimations > 0) {
                    var animationsToCancel = [];
                    if (!runner.isClassBased) {
                        if (animationEvent == "leave" && runningAnimations["ng-leave"]) {
                            skipAnimation = true;
                        } else {
                            for (var klass in runningAnimations) {
                                animationsToCancel.push(runningAnimations[klass]);
                                cleanup(element, klass);
                            }
                            runningAnimations = {};
                            totalActiveAnimations = 0;
                        }
                    } else if (lastAnimation.event == "setClass") {
                        animationsToCancel.push(lastAnimation);
                        cleanup(element, className);
                    } else if (runningAnimations[className]) {
                        var current = runningAnimations[className];
                        if (current.event == animationEvent) {
                            skipAnimation = true;
                        } else {
                            animationsToCancel.push(current);
                            cleanup(element, className);
                        }
                    }
                    if (animationsToCancel.length > 0) {
                        forEach(animationsToCancel, function(operation) {
                            operation.cancel();
                        });
                    }
                }
                if (runner.isClassBased && !runner.isSetClassOperation && !skipAnimation) {
                    skipAnimation = animationEvent == "addClass" == element.hasClass(className);
                }
                if (skipAnimation) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    fireDoneCallbackAsync();
                    return;
                }
                if (animationEvent == "leave") {
                    element.one("$destroy", function(e) {
                        var element = angular.element(this);
                        var state = element.data(NG_ANIMATE_STATE);
                        if (state) {
                            var activeLeaveAnimation = state.active["ng-leave"];
                            if (activeLeaveAnimation) {
                                activeLeaveAnimation.cancel();
                                cleanup(element, "ng-leave");
                            }
                        }
                    });
                }
                element.addClass(NG_ANIMATE_CLASS_NAME);
                var localAnimationCount = globalAnimationCounter++;
                totalActiveAnimations++;
                runningAnimations[className] = runner;
                element.data(NG_ANIMATE_STATE, {
                    last: runner,
                    active: runningAnimations,
                    index: localAnimationCount,
                    totalActive: totalActiveAnimations
                });
                fireBeforeCallbackAsync();
                runner.before(function(cancelled) {
                    var data = element.data(NG_ANIMATE_STATE);
                    cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent;
                    fireDOMOperation();
                    if (cancelled === true) {
                        closeAnimation();
                    } else {
                        fireAfterCallbackAsync();
                        runner.after(closeAnimation);
                    }
                });
                function fireDOMCallback(animationPhase) {
                    var eventName = "$animate:" + animationPhase;
                    if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
                        $$asyncCallback(function() {
                            element.triggerHandler(eventName, {
                                event: animationEvent,
                                className: className
                            });
                        });
                    }
                }
                function fireBeforeCallbackAsync() {
                    fireDOMCallback("before");
                }
                function fireAfterCallbackAsync() {
                    fireDOMCallback("after");
                }
                function fireDoneCallbackAsync() {
                    fireDOMCallback("close");
                    if (doneCallback) {
                        $$asyncCallback(function() {
                            doneCallback();
                        });
                    }
                }
                function fireDOMOperation() {
                    if (!fireDOMOperation.hasBeenRun) {
                        fireDOMOperation.hasBeenRun = true;
                        domOperation();
                    }
                }
                function closeAnimation() {
                    if (!closeAnimation.hasBeenRun) {
                        closeAnimation.hasBeenRun = true;
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data) {
                            if (runner && runner.isClassBased) {
                                cleanup(element, className);
                            } else {
                                $$asyncCallback(function() {
                                    var data = element.data(NG_ANIMATE_STATE) || {};
                                    if (localAnimationCount == data.index) {
                                        cleanup(element, className, animationEvent);
                                    }
                                });
                                element.data(NG_ANIMATE_STATE, data);
                            }
                        }
                        fireDoneCallbackAsync();
                    }
                }
            }
            function cancelChildAnimations(element) {
                var node = extractElementNode(element);
                if (node) {
                    var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
                    forEach(nodes, function(element) {
                        element = angular.element(element);
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data && data.active) {
                            forEach(data.active, function(runner) {
                                runner.cancel();
                            });
                        }
                    });
                }
            }
            function cleanup(element, className) {
                if (isMatchingElement(element, $rootElement)) {
                    if (!rootAnimateState.disabled) {
                        rootAnimateState.running = false;
                        rootAnimateState.structural = false;
                    }
                } else if (className) {
                    var data = element.data(NG_ANIMATE_STATE) || {};
                    var removeAnimations = className === true;
                    if (!removeAnimations && data.active && data.active[className]) {
                        data.totalActive--;
                        delete data.active[className];
                    }
                    if (removeAnimations || !data.totalActive) {
                        element.removeClass(NG_ANIMATE_CLASS_NAME);
                        element.removeData(NG_ANIMATE_STATE);
                    }
                }
            }
            function animationsDisabled(element, parentElement) {
                if (rootAnimateState.disabled) {
                    return true;
                }
                if (isMatchingElement(element, $rootElement)) {
                    return rootAnimateState.running;
                }
                var allowChildAnimations, parentRunningAnimation, hasParent;
                do {
                    if (parentElement.length === 0) break;
                    var isRoot = isMatchingElement(parentElement, $rootElement);
                    var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
                    if (state.disabled) {
                        return true;
                    }
                    if (isRoot) {
                        hasParent = true;
                    }
                    if (allowChildAnimations !== false) {
                        var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
                        if (angular.isDefined(animateChildrenFlag)) {
                            allowChildAnimations = animateChildrenFlag;
                        }
                    }
                    parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
                } while (parentElement = parentElement.parent());
                return !hasParent || !allowChildAnimations && parentRunningAnimation;
            }
        } ]);
        $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
            var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
            if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
                CSS_PREFIX = "-webkit-";
                TRANSITION_PROP = "WebkitTransition";
                TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
            } else {
                TRANSITION_PROP = "transition";
                TRANSITIONEND_EVENT = "transitionend";
            }
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS_PREFIX = "-webkit-";
                ANIMATION_PROP = "WebkitAnimation";
                ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
            } else {
                ANIMATION_PROP = "animation";
                ANIMATIONEND_EVENT = "animationend";
            }
            var DURATION_KEY = "Duration";
            var PROPERTY_KEY = "Property";
            var DELAY_KEY = "Delay";
            var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
            var NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey";
            var NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data";
            var NG_ANIMATE_BLOCK_CLASS_NAME = "ng-animate-block-transitions";
            var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
            var CLOSING_TIME_BUFFER = 1.5;
            var ONE_SECOND = 1e3;
            var lookupCache = {};
            var parentCounter = 0;
            var animationReflowQueue = [];
            var cancelAnimationReflow;
            function clearCacheAfterReflow() {
                if (!cancelAnimationReflow) {
                    cancelAnimationReflow = $$animateReflow(function() {
                        animationReflowQueue = [];
                        cancelAnimationReflow = null;
                        lookupCache = {};
                    });
                }
            }
            function afterReflow(element, callback) {
                if (cancelAnimationReflow) {
                    cancelAnimationReflow();
                }
                animationReflowQueue.push(callback);
                cancelAnimationReflow = $$animateReflow(function() {
                    forEach(animationReflowQueue, function(fn) {
                        fn();
                    });
                    animationReflowQueue = [];
                    cancelAnimationReflow = null;
                    lookupCache = {};
                });
            }
            var closingTimer = null;
            var closingTimestamp = 0;
            var animationElementQueue = [];
            function animationCloseHandler(element, totalTime) {
                var node = extractElementNode(element);
                element = angular.element(node);
                animationElementQueue.push(element);
                var futureTimestamp = Date.now() + totalTime;
                if (futureTimestamp <= closingTimestamp) {
                    return;
                }
                $timeout.cancel(closingTimer);
                closingTimestamp = futureTimestamp;
                closingTimer = $timeout(function() {
                    closeAllAnimations(animationElementQueue);
                    animationElementQueue = [];
                }, totalTime, false);
            }
            function closeAllAnimations(elements) {
                forEach(elements, function(element) {
                    var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                    if (elementData) {
                        (elementData.closeAnimationFn || noop)();
                    }
                });
            }
            function getElementAnimationDetails(element, cacheKey) {
                var data = cacheKey ? lookupCache[cacheKey] : null;
                if (!data) {
                    var transitionDuration = 0;
                    var transitionDelay = 0;
                    var animationDuration = 0;
                    var animationDelay = 0;
                    var transitionDelayStyle;
                    var animationDelayStyle;
                    var transitionDurationStyle;
                    var transitionPropertyStyle;
                    forEach(element, function(element) {
                        if (element.nodeType == ELEMENT_NODE) {
                            var elementStyles = $window.getComputedStyle(element) || {};
                            transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
                            transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);
                            transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY];
                            transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
                            transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);
                            animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];
                            animationDelay = Math.max(parseMaxTime(animationDelayStyle), animationDelay);
                            var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                            if (aDuration > 0) {
                                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
                            }
                            animationDuration = Math.max(aDuration, animationDuration);
                        }
                    });
                    data = {
                        total: 0,
                        transitionPropertyStyle: transitionPropertyStyle,
                        transitionDurationStyle: transitionDurationStyle,
                        transitionDelayStyle: transitionDelayStyle,
                        transitionDelay: transitionDelay,
                        transitionDuration: transitionDuration,
                        animationDelayStyle: animationDelayStyle,
                        animationDelay: animationDelay,
                        animationDuration: animationDuration
                    };
                    if (cacheKey) {
                        lookupCache[cacheKey] = data;
                    }
                }
                return data;
            }
            function parseMaxTime(str) {
                var maxValue = 0;
                var values = angular.isString(str) ? str.split(/\s*,\s*/) : [];
                forEach(values, function(value) {
                    maxValue = Math.max(parseFloat(value) || 0, maxValue);
                });
                return maxValue;
            }
            function getCacheKey(element) {
                var parentElement = element.parent();
                var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                if (!parentID) {
                    parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
                    parentID = parentCounter;
                }
                return parentID + "-" + extractElementNode(element).getAttribute("class");
            }
            function animateSetup(animationEvent, element, className, calculationDecorator) {
                var cacheKey = getCacheKey(element);
                var eventCacheKey = cacheKey + " " + className;
                var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;
                var stagger = {};
                if (itemIndex > 0) {
                    var staggerClassName = className + "-stagger";
                    var staggerCacheKey = cacheKey + " " + staggerClassName;
                    var applyClasses = !lookupCache[staggerCacheKey];
                    applyClasses && element.addClass(staggerClassName);
                    stagger = getElementAnimationDetails(element, staggerCacheKey);
                    applyClasses && element.removeClass(staggerClassName);
                }
                calculationDecorator = calculationDecorator || function(fn) {
                    return fn();
                };
                element.addClass(className);
                var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};
                var timings = calculationDecorator(function() {
                    return getElementAnimationDetails(element, eventCacheKey);
                });
                var transitionDuration = timings.transitionDuration;
                var animationDuration = timings.animationDuration;
                if (transitionDuration === 0 && animationDuration === 0) {
                    element.removeClass(className);
                    return false;
                }
                element.data(NG_ANIMATE_CSS_DATA_KEY, {
                    running: formerData.running || 0,
                    itemIndex: itemIndex,
                    stagger: stagger,
                    timings: timings,
                    closeAnimationFn: noop
                });
                var isCurrentlyAnimating = formerData.running > 0 || animationEvent == "setClass";
                if (transitionDuration > 0) {
                    blockTransitions(element, className, isCurrentlyAnimating);
                }
                if (animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                    blockKeyframeAnimations(element);
                }
                return true;
            }
            function isStructuralAnimation(className) {
                return className == "ng-enter" || className == "ng-move" || className == "ng-leave";
            }
            function blockTransitions(element, className, isAnimating) {
                if (isStructuralAnimation(className) || !isAnimating) {
                    extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = "none";
                } else {
                    element.addClass(NG_ANIMATE_BLOCK_CLASS_NAME);
                }
            }
            function blockKeyframeAnimations(element) {
                extractElementNode(element).style[ANIMATION_PROP] = "none 0s";
            }
            function unblockTransitions(element, className) {
                var prop = TRANSITION_PROP + PROPERTY_KEY;
                var node = extractElementNode(element);
                if (node.style[prop] && node.style[prop].length > 0) {
                    node.style[prop] = "";
                }
                element.removeClass(NG_ANIMATE_BLOCK_CLASS_NAME);
            }
            function unblockKeyframeAnimations(element) {
                var prop = ANIMATION_PROP;
                var node = extractElementNode(element);
                if (node.style[prop] && node.style[prop].length > 0) {
                    node.style[prop] = "";
                }
            }
            function animateRun(animationEvent, element, className, activeAnimationComplete) {
                var node = extractElementNode(element);
                var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (node.getAttribute("class").indexOf(className) == -1 || !elementData) {
                    activeAnimationComplete();
                    return;
                }
                var activeClassName = "";
                forEach(className.split(" "), function(klass, i) {
                    activeClassName += (i > 0 ? " " : "") + klass + "-active";
                });
                var stagger = elementData.stagger;
                var timings = elementData.timings;
                var itemIndex = elementData.itemIndex;
                var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
                var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
                var maxDelayTime = maxDelay * ONE_SECOND;
                var startTime = Date.now();
                var css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT;
                var style = "", appliedStyles = [];
                if (timings.transitionDuration > 0) {
                    var propertyStyle = timings.transitionPropertyStyle;
                    if (propertyStyle.indexOf("all") == -1) {
                        style += CSS_PREFIX + "transition-property: " + propertyStyle + ";";
                        style += CSS_PREFIX + "transition-duration: " + timings.transitionDurationStyle + ";";
                        appliedStyles.push(CSS_PREFIX + "transition-property");
                        appliedStyles.push(CSS_PREFIX + "transition-duration");
                    }
                }
                if (itemIndex > 0) {
                    if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
                        var delayStyle = timings.transitionDelayStyle;
                        style += CSS_PREFIX + "transition-delay: " + prepareStaggerDelay(delayStyle, stagger.transitionDelay, itemIndex) + "; ";
                        appliedStyles.push(CSS_PREFIX + "transition-delay");
                    }
                    if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                        style += CSS_PREFIX + "animation-delay: " + prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, itemIndex) + "; ";
                        appliedStyles.push(CSS_PREFIX + "animation-delay");
                    }
                }
                if (appliedStyles.length > 0) {
                    var oldStyle = node.getAttribute("style") || "";
                    node.setAttribute("style", oldStyle + "; " + style);
                }
                element.on(css3AnimationEvents, onAnimationProgress);
                element.addClass(activeClassName);
                elementData.closeAnimationFn = function() {
                    onEnd();
                    activeAnimationComplete();
                };
                var staggerTime = itemIndex * (Math.max(stagger.animationDelay, stagger.transitionDelay) || 0);
                var animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;
                var totalTime = (staggerTime + animationTime) * ONE_SECOND;
                elementData.running++;
                animationCloseHandler(element, totalTime);
                return onEnd;
                function onEnd(cancelled) {
                    element.off(css3AnimationEvents, onAnimationProgress);
                    element.removeClass(activeClassName);
                    animateClose(element, className);
                    var node = extractElementNode(element);
                    for (var i in appliedStyles) {
                        node.style.removeProperty(appliedStyles[i]);
                    }
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event;
                    var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                    var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                        activeAnimationComplete();
                    }
                }
            }
            function prepareStaggerDelay(delayStyle, staggerDelay, index) {
                var style = "";
                forEach(delayStyle.split(","), function(val, i) {
                    style += (i > 0 ? "," : "") + (index * staggerDelay + parseInt(val, 10)) + "s";
                });
                return style;
            }
            function animateBefore(animationEvent, element, className, calculationDecorator) {
                if (animateSetup(animationEvent, element, className, calculationDecorator)) {
                    return function(cancelled) {
                        cancelled && animateClose(element, className);
                    };
                }
            }
            function animateAfter(animationEvent, element, className, afterAnimationComplete) {
                if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {
                    return animateRun(animationEvent, element, className, afterAnimationComplete);
                } else {
                    animateClose(element, className);
                    afterAnimationComplete();
                }
            }
            function animate(animationEvent, element, className, animationComplete) {
                var preReflowCancellation = animateBefore(animationEvent, element, className);
                if (!preReflowCancellation) {
                    clearCacheAfterReflow();
                    animationComplete();
                    return;
                }
                var cancel = preReflowCancellation;
                afterReflow(element, function() {
                    unblockTransitions(element, className);
                    unblockKeyframeAnimations(element);
                    cancel = animateAfter(animationEvent, element, className, animationComplete);
                });
                return function(cancelled) {
                    (cancel || noop)(cancelled);
                };
            }
            function animateClose(element, className) {
                element.removeClass(className);
                var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (data) {
                    if (data.running) {
                        data.running--;
                    }
                    if (!data.running || data.running === 0) {
                        element.removeData(NG_ANIMATE_CSS_DATA_KEY);
                    }
                }
            }
            return {
                enter: function(element, animationCompleted) {
                    return animate("enter", element, "ng-enter", animationCompleted);
                },
                leave: function(element, animationCompleted) {
                    return animate("leave", element, "ng-leave", animationCompleted);
                },
                move: function(element, animationCompleted) {
                    return animate("move", element, "ng-move", animationCompleted);
                },
                beforeSetClass: function(element, add, remove, animationCompleted) {
                    var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add");
                    var cancellationMethod = animateBefore("setClass", element, className, function(fn) {
                        var klass = element.attr("class");
                        element.removeClass(remove);
                        element.addClass(add);
                        var timings = fn();
                        element.attr("class", klass);
                        return timings;
                    });
                    if (cancellationMethod) {
                        afterReflow(element, function() {
                            unblockTransitions(element, className);
                            unblockKeyframeAnimations(element);
                            animationCompleted();
                        });
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeAddClass: function(element, className, animationCompleted) {
                    var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), function(fn) {
                        element.addClass(className);
                        var timings = fn();
                        element.removeClass(className);
                        return timings;
                    });
                    if (cancellationMethod) {
                        afterReflow(element, function() {
                            unblockTransitions(element, className);
                            unblockKeyframeAnimations(element);
                            animationCompleted();
                        });
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                setClass: function(element, add, remove, animationCompleted) {
                    remove = suffixClasses(remove, "-remove");
                    add = suffixClasses(add, "-add");
                    var className = remove + " " + add;
                    return animateAfter("setClass", element, className, animationCompleted);
                },
                addClass: function(element, className, animationCompleted) {
                    return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted);
                },
                beforeRemoveClass: function(element, className, animationCompleted) {
                    var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), function(fn) {
                        var klass = element.attr("class");
                        element.removeClass(className);
                        var timings = fn();
                        element.attr("class", klass);
                        return timings;
                    });
                    if (cancellationMethod) {
                        afterReflow(element, function() {
                            unblockTransitions(element, className);
                            unblockKeyframeAnimations(element);
                            animationCompleted();
                        });
                        return cancellationMethod;
                    }
                    animationCompleted();
                },
                removeClass: function(element, className, animationCompleted) {
                    return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted);
                }
            };
            function suffixClasses(classes, suffix) {
                var className = "";
                classes = angular.isArray(classes) ? classes : classes.split(/\s+/);
                forEach(classes, function(klass, i) {
                    if (klass && klass.length > 0) {
                        className += (i > 0 ? " " : "") + klass + suffix;
                    }
                });
                return className;
            }
        } ]);
    } ]);
})(window, window.angular);
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "ui.router";
}

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        forEach(arguments, function(obj) {
            if (obj !== dst) {
                forEach(obj, function(value, key) {
                    if (!dst.hasOwnProperty(key)) dst[key] = value;
                });
            }
        });
        return dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
            result.push(key);
        });
        return result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (;from < len; from++) {
            if (from in array && array[from] === value) return from;
        }
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i].params) continue;
            parentParams = objectKeys(parents[i].params);
            if (!parentParams.length) continue;
            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0) continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return false;
        }
        return true;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
            filtered[name] = values[name];
        });
        return filtered;
    }
    function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
            result[item[propName]] = item;
        });
        return result;
    }
    function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    }
    function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
            if (indexOf(keys, key) == -1) copy[key] = obj[key];
        }
        return copy;
    }
    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
    }
    function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val;
            }
        });
        return result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        });
        return result;
    }
    angular.module("ui.router.util", [ "ng" ]);
    angular.module("ui.router.router", [ "ui.router.util" ]);
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]);
    angular.module("ui.router", [ "ui.router.state" ]);
    angular.module("ui.router.compat", [ "ui.router" ]);
    $Resolve.$inject = [ "$q", "$injector" ];
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {});
            var plan = [], cycle = [], visited = {};
            function visit(value, key) {
                if (visited[key] === VISIT_DONE) return;
                cycle.push(key);
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key));
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                }
                visited[key] = VISIT_IN_PROGRESS;
                if (isString(value)) {
                    plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES);
                } else {
                    var params = $injector.annotate(value);
                    forEach(params, function(param) {
                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
                    });
                    plan.push(key, value, params);
                }
                cycle.pop();
                visited[key] = VISIT_DONE;
            }
            forEach(invocables, visit);
            invocables = cycle = visited = null;
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            return function(locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent;
                    parent = locals;
                    locals = null;
                }
                if (!locals) locals = NO_LOCALS; else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object");
                }
                if (!parent) parent = NO_PARENT; else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                }
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
                function done() {
                    if (!--wait) {
                        if (!merged) merge(values, parent.$$values);
                        result.$$values = values;
                        result.$$promises = result.$$promises || true;
                        delete result.$$inheritedValues;
                        resolution.resolve(values);
                    }
                }
                function fail(reason) {
                    result.$$failure = reason;
                    resolution.reject(reason);
                }
                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure);
                    return result;
                }
                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys));
                }
                extend(promises, parent.$$promises);
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys));
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                    done();
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                    }
                    parent.then(done, fail);
                }
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i])) done(); else invoke(plan[i], plan[i + 1], plan[i + 2]);
                }
                function invoke(key, invocable, params) {
                    var invocation = $q.defer(), waitParams = 0;
                    function onfailure(reason) {
                        invocation.reject(reason);
                        fail(reason);
                    }
                    forEach(params, function(dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++;
                            promises[dep].then(function(result) {
                                values[dep] = result;
                                if (!--waitParams) proceed();
                            }, onfailure);
                        }
                    });
                    if (!waitParams) proceed();
                    function proceed() {
                        if (isDefined(result.$$failure)) return;
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values));
                            invocation.promise.then(function(result) {
                                values[key] = result;
                                done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    promises[key] = invocation.promise;
                }
                return result;
            };
        };
        this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    angular.module("ui.router.util").service("$resolve", $Resolve);
    $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ];
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        };
        this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
            if (isFunction(url)) url = url(params);
            if (url == null) return null; else return $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, m, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        function addParameter(id, type, config, location) {
            paramNames.push(id);
            if (parentParams[id]) return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            params[id] = new $$UMFP.Param(id, type, config, location);
            return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case false:
                surroundPattern = [ "(", ")" + (optional ? "?" : "") ];
                break;

              case true:
                surroundPattern = [ "?(", ")?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
                break;
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode;
            id = m[2] || m[3];
            cfg = config.params[id];
            segment = pattern.substring(last, m.index);
            regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null);
            type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined)
            });
            return {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        var p, param, segment;
        while (m = placeholder.exec(pattern)) {
            p = matchDetails(m, false);
            if (p.segment.indexOf("?") >= 0) break;
            param = addParameter(p.id, p.type, p.cfg, "path");
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
            segments.push(p.segment);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i);
            this.sourcePath = pattern.substring(0, last + i);
            if (search.length > 0) {
                last = 0;
                while (m = searchPlaceholder.exec(search)) {
                    p = matchDetails(m, true);
                    param = addParameter(p.id, p.type, p.cfg, "search");
                    last = placeholder.lastIndex;
                }
            }
        } else {
            this.sourcePath = pattern;
            this.sourceSearch = "";
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$";
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
        return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {}, i, j, cfg, paramName;
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/g, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName];
            var paramVal = m[i + 1];
            for (j = 0; j < param.replace; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
            }
            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
            values[paramName] = param.value(paramVal);
        }
        for (;i < nTotal; i++) {
            paramName = paramNames[i];
            values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param)) return this.$$paramNames;
        return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath;
            var name = params[i], param = paramset[name], value = param.value(values[name]);
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
            var squash = isDefaultValue ? param.squash : false;
            var encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-");
                        } else {
                            result += encodeURIComponent(encoded);
                        }
                    }
                    result += nextSegment;
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else if (isString(squash)) {
                    result += squash + nextSegment;
                }
            } else {
                if (encoded == null || isDefaultValue && squash !== false) continue;
                if (!isArray(encoded)) encoded = [ encoded ];
                encoded = map(encoded, encodeURIComponent).join("&" + name + "=");
                result += (search ? "&" : "?") + (name + "=" + encoded);
                search = true;
            }
        }
        return result;
    };
    function Type(config) {
        extend(this, config);
    }
    Type.prototype.is = function(val, key) {
        return true;
    };
    Type.prototype.encode = function(val, key) {
        return val;
    };
    Type.prototype.decode = function(val, key) {
        return val;
    };
    Type.prototype.equals = function(a, b) {
        return a == b;
    };
    Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    };
    Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
    };
    Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode) return this;
        if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return mode === "auto" ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    if (allTruthyMode === true) return filter(result, falsey).length === 0;
                    return arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i])) return false;
                    }
                    return true;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode"));
            this.decode = arrayHandler(bindTo(type, "decode"));
            this.is = arrayHandler(bindTo(type, "is"), true);
            this.equals = arrayEqualsHandler(bindTo(type, "equals"));
            this.pattern = type.pattern;
            this.$normalize = arrayHandler(bindTo(type, "$normalize"));
            this.name = type.name;
            this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
    };
    function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;
        function valToString(val) {
            return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
            return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        function regexpMatches(val) {
            return this.pattern.test(val);
        }
        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                    return typeof val === "string";
                },
                pattern: /[^/]*/
            },
            "int": {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                    return val === true || val === false;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    if (!this.is(val)) return undefined;
                    return [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-");
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                is: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
            if (isDefined(value)) isCaseInsensitive = value;
            return isCaseInsensitive;
        };
        this.strictMode = function(value) {
            if (isDefined(value)) isStrictMode = value;
            return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            defaultSquashPolicy = value;
            return value;
        };
        this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
            if (!isObject(o)) return false;
            var result = true;
            forEach(UrlMatcher.prototype, function(val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]));
                }
            });
            return result;
        };
        this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            $types[name] = new Type(extend({
                name: name
            }, definition));
            if (definitionFn) {
                typeQueue.push({
                    name: name,
                    def: definitionFn
                });
                if (!enqueue) flushTypeQueue();
            }
            return this;
        };
        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        });
        $types = inherit($types, {});
        this.$get = [ "$injector", function($injector) {
            injector = $injector;
            enqueue = false;
            flushTypeQueue();
            forEach(defaultTypes, function(type, name) {
                if (!$types[name]) $types[name] = new Type(type);
            });
            return this;
        } ];
        this.Param = function Param(id, type, config, location) {
            var self = this;
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = "";
            var isOptional = config.value !== undefined;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                if (isShorthand) config = {
                    value: config
                };
                config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                };
                return config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                if (urlType) return urlType;
                if (!config.type) return location === "config" ? $types.any : $types.string;
                return config.type instanceof Type ? config.type : new Type(config.type);
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: location === "search" ? "auto" : false
                };
                var arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: true
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === false) return false;
                if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
                if (squash === true || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                replace = isArray(config.replace) ? config.replace : [];
                if (isString(squash)) replace.push({
                    from: squash,
                    to: undefined
                });
                configuredKeys = map(replace, function(item) {
                    return item.from;
                });
                return filter(defaultPolicy, function(item) {
                    return indexOf(configuredKeys, item.from) === -1;
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = injector.invoke(config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                return defaultValue;
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                value = $replace(value);
                return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        };
        function ParamSet(params) {
            extend(this, params || {});
        }
        ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype);
                while (parent) {
                    chain.push(parent);
                    parent = parent.$$parent;
                }
                chain.reverse();
                forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
                    });
                });
                return keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                });
                return values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = true, self = this;
                forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    if (!self[key].type.equals(left, right)) equal = false;
                });
                return equal;
            },
            $$validates: function $$validate(paramValues) {
                var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
                for (i = 0; i < keys.length; i++) {
                    param = this[keys[i]];
                    rawVal = paramValues[keys[i]];
                    if ((rawVal === undefined || rawVal === null) && param.isOptional) break;
                    normalized = param.type.$normalize(rawVal);
                    if (!param.type.is(normalized)) return false;
                    encoded = param.type.encode(normalized);
                    if (angular.isString(encoded) && !param.type.pattern.exec(encoded)) return false;
                }
                return true;
            },
            $$parent: undefined
        };
        this.ParamSet = ParamSet;
    }
    angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory);
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]);
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [], otherwise = null, interceptDeferred = false, listener;
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match[what === "$" ? 0 : Number(what)];
            });
        }
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
        };
        this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            otherwise = rule;
            return this;
        };
        function handleIfMatch($injector, handler, match) {
            if (!match) return false;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what)) what = $urlMatcherFactory.compile(what);
            if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler);
                        handler = [ "$match", function($match) {
                            return redirect.format($match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    if (handlerIsString) {
                        redirect = handler;
                        handler = [ "$match", function($match) {
                            return interpolate(redirect, $match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            };
            var check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) {
                if (check[n]) return this.rule(strategies[n](what, handler));
            }
            throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
            if (defer === undefined) defer = true;
            interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = [ "$location", "$rootScope", "$injector", "$browser" ];
        function $get($location, $rootScope, $injector, $browser) {
            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;
            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === "/") return url;
                if (isHtml5) return baseHref.slice(0, -1) + url;
                if (absolute) return baseHref.slice(1) + url;
                return url;
            }
            function update(evt) {
                if (evt && evt.defaultPrevented) return;
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                lastPushedUrl = undefined;
                if (ignoreUpdate) return true;
                function check(rule) {
                    var handled = rule($injector, $location);
                    if (!handled) return false;
                    if (isString(handled)) $location.replace().url(handled);
                    return true;
                }
                var n = rules.length, i;
                for (i = 0; i < n; i++) {
                    if (check(rules[i])) return;
                }
                if (otherwise) check(otherwise);
            }
            function listen() {
                listener = listener || $rootScope.$on("$locationChangeSuccess", update);
                return listener;
            }
            if (!interceptDeferred) listen();
            return {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    if (read) {
                        location = $location.url();
                        return;
                    }
                    if ($location.url() === location) return;
                    $location.url(location);
                    $location.replace();
                },
                push: function(urlMatcher, params, options) {
                    var url = urlMatcher.format(params || {});
                    if (url !== null && params && params["#"]) {
                        url += "#" + params["#"];
                    }
                    $location.url(url);
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                    if (options && options.replace) $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled;
                    }
                    var url = urlMatcher.format(params);
                    options = options || {};
                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url;
                    }
                    if (url !== null && params && params["#"]) {
                        url += "#" + params["#"];
                    }
                    url = appendBasePath(url, isHtml5, options.absolute);
                    if (!options.absolute || !url) {
                        return url;
                    }
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    port = port === 80 || port === 443 ? "" : ":" + port;
                    return [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
    }
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
    $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, states = {}, $state, queue = {}, abstractKey = "abstract";
        var stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = extend({}, state.parent.data, state.data);
                }
                return state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) {
                    if (url.charAt(0) == "^") return $urlMatcherFactory.compile(url.substring(1), config);
                    return (state.parent.navigable || root).url.concat(url, config);
                }
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                forEach(state.params || {}, function(config, id) {
                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
                });
                return params;
            },
            params: function(state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    if (name.indexOf("@") < 0) name += "@" + state.parent.name;
                    views[name] = view;
                });
                return views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
            },
            $delegates: {}
        };
        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                var rel = name.split("."), i = 0, pathLength = rel.length, current = base;
                for (;i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base;
                        continue;
                    }
                    if (rel[i] === "^") {
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                rel = rel.slice(i).join(".");
                name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                return state;
            }
            return undefined;
        }
        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = [];
            }
            queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || [];
            while (queued.length) {
                registerState(queued.shift());
            }
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self);
            }
            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
            }
            states[name] = state;
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                        $state.transitionTo(state, $match, {
                            inherit: true,
                            location: false
                        });
                    }
                } ]);
            }
            flushQueuedChildren(name);
            return state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".");
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === "*") {
                    segments[i] = "*";
                }
            }
            if (globSegments[0] === "**") {
                segments = segments.slice(indexOf(segments, globSegments[1]));
                segments.unshift("**");
            }
            if (globSegments[globSegments.length - 1] === "**") {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                segments.push("**");
            }
            if (globSegments.length != segments.length) {
                return false;
            }
            return segments.join("") === globSegments.join("");
        }
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name];
            }
            if (!isFunction(func) || !isString(name)) {
                return this;
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name];
            }
            stateBuilder[name] = func;
            return this;
        }
        this.state = state;
        function state(name, definition) {
            if (isObject(name)) definition = name; else definition.name = name;
            registerState(definition);
            return this;
        }
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSuperseded = $q.reject(new Error("transition superseded"));
            var TransitionPrevented = $q.reject(new Error("transition prevented"));
            var TransitionAborted = $q.reject(new Error("transition aborted"));
            var TransitionFailed = $q.reject(new Error("transition failed"));
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) {
                    $urlRouter.update();
                    return TransitionAborted;
                }
                if (!evt.retry) {
                    return null;
                }
                if (options.$retry) {
                    $urlRouter.update();
                    return TransitionFailed;
                }
                var retryTransition = $state.transition = $q.when(evt.retry);
                retryTransition.then(function() {
                    if (retryTransition !== $state.transition) return TransitionSuperseded;
                    redirect.options.$retry = true;
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                }, function() {
                    return TransitionAborted;
                });
                $urlRouter.update();
                return retryTransition;
            }
            root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            };
            $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            };
            $state.reload = function reload(state) {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: state || true,
                    inherit: false,
                    notify: true
                });
            };
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: true,
                    relative: $state.$current
                }, options));
            };
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {};
                options = extend({
                    location: true,
                    inherit: false,
                    relative: null,
                    notify: true,
                    reload: false,
                    $retry: false
                }, options || {});
                var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                var evt, toState = findState(to, options.relative);
                var hash = toParams["#"];
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    };
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) {
                        return redirectResult;
                    }
                    to = redirect.to;
                    toParams = redirect.toParams;
                    options = redirect.options;
                    toState = findState(to, options.relative);
                    if (!isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                if (!toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams);
                to = toState;
                var toPath = to.path;
                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                var skipTriggerReloadCheck = false;
                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                } else if (isString(options.reload) || isObject(options.reload)) {
                    if (isObject(options.reload) && !options.reload.name) {
                        throw new Error("Invalid reload state object");
                    }
                    var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                    if (options.reload && !reloadState) {
                        throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                    }
                    skipTriggerReloadCheck = true;
                    while (state && state === fromPath[keep] && state !== reloadState) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                }
                if (!skipTriggerReloadCheck && shouldTriggerReload(to, from, locals, options)) {
                    if (to.self.reloadOnSearch !== false) $urlRouter.update();
                    $state.transition = null;
                    return $q.when($state.current);
                }
                toParams = filterByKeys(to.params.$$keys(), toParams || {});
                if (options.notify) {
                    if ($rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams).defaultPrevented) {
                        $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams);
                        $urlRouter.update();
                        return TransitionPrevented;
                    }
                }
                var resolved = $q.when(locals);
                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals);
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                }
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l];
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                        }
                        exiting.locals = null;
                    }
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l];
                        entering.locals = toLocals[l];
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        }
                    }
                    if (hash) toParams["#"] = hash;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.$current = to;
                    $state.current = to.self;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    $state.transition = null;
                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true,
                            replace: options.location === "replace"
                        });
                    }
                    if (options.notify) {
                        $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams);
                    }
                    $urlRouter.update(true);
                    return $state.current;
                }, function(error) {
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.transition = null;
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error);
                    if (!evt.defaultPrevented) {
                        $urlRouter.update();
                    }
                    return $q.reject(error);
                });
                return transition;
            };
            $state.is = function is(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if ($state.$current !== state) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
            };
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false;
                    }
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
            };
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
                var nav = state && options.lossy ? state.navigable : state;
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), {
                    absolute: options.absolute
                });
            };
            $state.get = function(stateOrName, context) {
                if (arguments.length === 0) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            };
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                var locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                if (inherited) promises.push(inherited);
                forEach(state.views, function(view, name) {
                    var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                    injectables.$template = [ function() {
                        return $view.load(name, {
                            view: view,
                            locals: locals,
                            params: $stateParams,
                            notify: options.notify
                        }) || "";
                    } ];
                    promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                            var injectLocals = angular.extend({}, injectables, locals, result);
                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                        } else {
                            result.$$controller = view.controller;
                        }
                        result.$$state = state;
                        result.$$controllerAs = view.controllerAs;
                        dst[name] = result;
                    }));
                });
                return $q.all(promises).then(function(values) {
                    return dst;
                });
            }
            return $state;
        }
        function shouldTriggerReload(to, from, locals, options) {
            if (to === from && (locals === from.locals && !options.reload || to.self.reloadOnSearch === false)) {
                return true;
            }
        }
    }
    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$templateFactory" ];
        function $get($rootScope, $templateFactory) {
            return {
                load: function load(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: true,
                        async: true,
                        params: {}
                    };
                    options = extend(defaults, options);
                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                    }
                    if (result && options.notify) {
                        $rootScope.$broadcast("$viewContentLoading", options);
                    }
                    return result;
                }
            };
        }
    }
    angular.module("ui.router.state").provider("$view", $ViewProvider);
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
            useAnchorScroll = true;
        };
        this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll;
            }
            return function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, false);
            };
        } ];
    }
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate");
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element);
                        cb();
                    },
                    leave: function(element, cb) {
                        element.remove();
                        cb();
                    }
                };
            };
            if ($animate) {
                return {
                    enter: function(element, target, cb) {
                        var promise = $animate.enter(element, null, target, cb);
                        if (promise && promise.then) promise.then(cb);
                    },
                    leave: function(element, cb) {
                        var promise = $animate.leave(element, cb);
                        if (promise && promise.then) promise.then(cb);
                    }
                };
            }
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target);
                        cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element);
                        cb();
                    }
                };
            }
            return statics();
        }
        var directive = {
            restrict: "ECA",
            terminal: true,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(false);
                    });
                    scope.$on("$viewContentLoading", function() {
                        updateView(false);
                    });
                    updateView(true);
                    function cleanupLastView() {
                        if (previousEl) {
                            previousEl.remove();
                            previousEl = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentEl) {
                            renderer.leave(currentEl, function() {
                                previousEl = null;
                            });
                            previousEl = currentEl;
                            currentEl = null;
                        }
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (!firstTime && previousLocals === latestLocals) return;
                        newScope = scope.$new();
                        latestLocals = $state.$current.locals[name];
                        var clone = $transclude(newScope, function(clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit("$viewContentAnimationEnded");
                                }
                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });
                        currentEl = clone;
                        currentScope = newScope;
                        currentScope.$emit("$viewContentLoaded");
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };
        return directive;
    }
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (!locals) {
                        return;
                    }
                    $element.data("$uiView", {
                        name: name,
                        state: locals.$$state
                    });
                    $element.html(locals.$template ? locals.$template : initial);
                    var link = $compile($element.contents());
                    if (locals.$$controller) {
                        locals.$scope = scope;
                        locals.$element = $element;
                        var controller = $controller(locals.$$controller, locals);
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller;
                        }
                        $element.data("$ngControllerController", controller);
                        $element.children().data("$ngControllerController", controller);
                    }
                    link(scope);
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope);
        var inherited = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "");
    }
    angular.module("ui.router.state").directive("uiView", $ViewDirective);
    angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
        if (preparsed) ref = current + "(" + preparsed[1] + ")";
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state;
        }
    }
    $StateRefDirective.$inject = [ "$state", "$timeout" ];
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = [ "location", "inherit", "reload", "absolute" ];
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name);
                var params = null, url = null, base = stateContext(element) || $state.$current;
                var hrefKind = Object.prototype.toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                var newHref = null, isAnchor = element.prop("tagName").toUpperCase() === "A";
                var isForm = element[0].nodeName === "FORM";
                var attr = isForm ? "action" : hrefKind, nav = true;
                var options = {
                    relative: base,
                    inherit: true
                };
                var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    if (option in optionsOverride) {
                        options[option] = optionsOverride[option];
                    }
                });
                var update = function(newVal) {
                    if (newVal) params = angular.copy(newVal);
                    if (!nav) return;
                    newHref = $state.href(ref.state, params, options);
                    var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                    if (activeDirective) {
                        activeDirective.$$addStateInfo(ref.state, params);
                    }
                    if (newHref === null) {
                        nav = false;
                        return false;
                    }
                    attrs.$set(attr, newHref);
                };
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                        if (newVal !== params) update(newVal);
                    }, true);
                    params = angular.copy(scope.$eval(ref.paramExpr));
                }
                update();
                if (isForm) return;
                element.bind("click", function(e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
                        var transition = $timeout(function() {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function() {
                            if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }
    $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                var states = [], activeClass;
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || "", false)($scope);
                this.$$addStateInfo = function(newState, newParams) {
                    var state = $state.get(newState, stateContext($element));
                    states.push({
                        state: state || {
                            name: newState
                        },
                        params: newParams
                    });
                    update();
                };
                $scope.$on("$stateChangeSuccess", update);
                function update() {
                    if (anyMatch()) {
                        $element.addClass(activeClass);
                    } else {
                        $element.removeClass(activeClass);
                    }
                }
                function anyMatch() {
                    for (var i = 0; i < states.length; i++) {
                        if (isMatch(states[i].state, states[i].params)) {
                            return true;
                        }
                    }
                    return false;
                }
                function isMatch(state, params) {
                    if (typeof $attrs.uiSrefActiveEq !== "undefined") {
                        return $state.is(state.name, params);
                    } else {
                        return $state.includes(state.name, params);
                    }
                }
            } ]
        };
    }
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective);
    $IsStateFilter.$inject = [ "$state" ];
    function $IsStateFilter($state) {
        var isFilter = function(state) {
            return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    $IncludedByStateFilter.$inject = [ "$state" ];
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
            return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
})(window, window.angular);
var breakpointApp = angular.module("breakpointApp", []);

breakpointApp.directive("breakpoint", [ "$window", "$rootScope", function(e, t) {
    return {
        restrict: "A",
        link: function(n, r, i) {
            function o(e) {
                t.$broadcast("breakpointChange", n.breakpoint, e);
            }
            function u() {
                n.breakpoint.windowSize = e.innerWidth;
                if (!n.$$phase) n.$apply();
            }
            function a(e) {
                var t = s[Object.keys(s)[0]];
                for (var i in s) {
                    if (i < e) t = s[i];
                    r.removeClass(s[i]);
                }
                r.addClass(t);
                n.breakpoint.class = t;
                if (!n.$$phase) n.$apply();
            }
            n.breakpoint = {
                "class": "",
                windowSize: e.innerWidth
            };
            var s = n.$eval(i.breakpoint);
            angular.element(e).bind("resize", u);
            n.$watch("breakpoint.windowSize", function(e, t) {
                a(e);
            });
            n.$watch("breakpoint.class", function(e, t) {
                if (e != t) o();
            });
        }
    };
} ]);
(function(angular, undefined) {
    "use strict";
    var mod_core = angular.module("ct.ui.router.extras.core", [ "ui.router" ]);
    var internalStates = {}, stateRegisteredCallbacks = [];
    mod_core.config([ "$stateProvider", "$injector", function($stateProvider, $injector) {
        $stateProvider.decorator("parent", function(state, parentFn) {
            internalStates[state.self.name] = state;
            state.self.$$state = function() {
                return internalStates[state.self.name];
            };
            angular.forEach(stateRegisteredCallbacks, function(callback) {
                callback(state);
            });
            return parentFn(state);
        });
    } ]);
    var DEBUG = false;
    var forEach = angular.forEach;
    var extend = angular.extend;
    var isArray = angular.isArray;
    var map = function(collection, callback) {
        "use strict";
        var result = [];
        forEach(collection, function(item, index) {
            result.push(callback(item, index));
        });
        return result;
    };
    var keys = function(collection) {
        "use strict";
        return map(collection, function(collection, key) {
            return key;
        });
    };
    var filter = function(collection, callback) {
        "use strict";
        var result = [];
        forEach(collection, function(item, index) {
            if (callback(item, index)) {
                result.push(item);
            }
        });
        return result;
    };
    var filterObj = function(collection, callback) {
        "use strict";
        var result = {};
        forEach(collection, function(item, index) {
            if (callback(item, index)) {
                result[index] = item;
            }
        });
        return result;
    };
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        angular.forEach(object, function(val, key) {
            result.push(key);
        });
        return result;
    }
    function protoKeys(object, ignoreKeys) {
        var result = [];
        for (var key in object) {
            if (!ignoreKeys || ignoreKeys.indexOf(key) === -1) result.push(key);
        }
        return result;
    }
    function arraySearch(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (;from < len; from++) {
            if (from in array && array[from] === value) return from;
        }
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i].params) continue;
            parentParams = isArray(parents[i].params) ? parents[i].params : objectKeys(parents[i].params);
            if (!parentParams.length) continue;
            for (var j in parentParams) {
                if (arraySearch(inheritList, parentParams[j]) >= 0) continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function onStateRegistered(callback) {
        stateRegisteredCallbacks.push(callback);
    }
    mod_core.provider("uirextras_core", function() {
        var core = {
            internalStates: internalStates,
            onStateRegistered: onStateRegistered,
            forEach: forEach,
            extend: extend,
            isArray: isArray,
            map: map,
            keys: keys,
            filter: filter,
            filterObj: filterObj,
            ancestors: ancestors,
            objectKeys: objectKeys,
            protoKeys: protoKeys,
            arraySearch: arraySearch,
            inheritParams: inheritParams,
            inherit: inherit
        };
        angular.extend(this, core);
        this.$get = function() {
            return core;
        };
    });
    var ignoreDsr;
    function resetIgnoreDsr() {
        ignoreDsr = undefined;
    }
    angular.module("ct.ui.router.extras.dsr", [ "ct.ui.router.extras.core" ]).config([ "$provide", function($provide) {
        var $state_transitionTo;
        $provide.decorator("$state", [ "$delegate", "$q", function($state, $q) {
            $state_transitionTo = $state.transitionTo;
            $state.transitionTo = function(to, toParams, options) {
                if (options.ignoreDsr) {
                    ignoreDsr = options.ignoreDsr;
                }
                return $state_transitionTo.apply($state, arguments).then(function(result) {
                    resetIgnoreDsr();
                    return result;
                }, function(err) {
                    resetIgnoreDsr();
                    return $q.reject(err);
                });
            };
            return $state;
        } ]);
    } ]);
    angular.module("ct.ui.router.extras.dsr").service("$deepStateRedirect", [ "$rootScope", "$state", "$injector", function($rootScope, $state, $injector) {
        var lastSubstate = {};
        var deepStateRedirectsByName = {};
        var REDIRECT = "Redirect", ANCESTOR_REDIRECT = "AncestorRedirect";
        function computeDeepStateStatus(state) {
            var name = state.name;
            if (deepStateRedirectsByName.hasOwnProperty(name)) return deepStateRedirectsByName[name];
            recordDeepStateRedirectStatus(name);
        }
        function getConfig(state) {
            var declaration = state.deepStateRedirect || state.dsr;
            if (!declaration) return {
                dsr: false
            };
            var dsrCfg = {
                dsr: true
            };
            if (angular.isFunction(declaration)) {
                dsrCfg.fn = declaration;
            } else if (angular.isObject(declaration)) {
                dsrCfg = angular.extend(dsrCfg, declaration);
            }
            if (angular.isString(dsrCfg.default)) {
                dsrCfg.default = {
                    state: dsrCfg.default
                };
            }
            if (!dsrCfg.fn) {
                dsrCfg.fn = [ "$dsr$", function($dsr$) {
                    return $dsr$.redirect.state != $dsr$.to.state;
                } ];
            }
            return dsrCfg;
        }
        function recordDeepStateRedirectStatus(stateName) {
            var state = $state.get(stateName);
            if (!state) return false;
            var cfg = getConfig(state);
            if (cfg.dsr) {
                deepStateRedirectsByName[state.name] = REDIRECT;
                if (lastSubstate[stateName] === undefined) lastSubstate[stateName] = {};
            }
            var parent = state.$$state && state.$$state().parent;
            if (parent) {
                var parentStatus = recordDeepStateRedirectStatus(parent.self.name);
                if (parentStatus && deepStateRedirectsByName[state.name] === undefined) {
                    deepStateRedirectsByName[state.name] = ANCESTOR_REDIRECT;
                }
            }
            return deepStateRedirectsByName[state.name] || false;
        }
        function getMatchParams(params, dsrParams) {
            if (dsrParams === true) dsrParams = Object.keys(params);
            if (dsrParams === null || dsrParams === undefined) dsrParams = [];
            var matchParams = {};
            angular.forEach(dsrParams.sort(), function(name) {
                matchParams[name] = params[name];
            });
            return matchParams;
        }
        function getParamsString(params, dsrParams) {
            var matchParams = getMatchParams(params, dsrParams);
            function safeString(input) {
                return !input ? input : input.toString();
            }
            var paramsToString = {};
            angular.forEach(matchParams, function(val, name) {
                paramsToString[name] = safeString(val);
            });
            return angular.toJson(paramsToString);
        }
        $rootScope.$on("$stateChangeStart", function(event, toState, toParams, fromState, fromParams) {
            var cfg = getConfig(toState);
            if (ignoreDsr || computeDeepStateStatus(toState) !== REDIRECT && !cfg.default) return;
            var key = getParamsString(toParams, cfg.params);
            var redirect = lastSubstate[toState.name][key] || cfg.default;
            if (!redirect) return;
            var $dsr$ = {
                redirect: {
                    state: redirect.state,
                    params: redirect.params
                },
                to: {
                    state: toState.name,
                    params: toParams
                }
            };
            var result = $injector.invoke(cfg.fn, toState, {
                $dsr$: $dsr$
            });
            if (!result) return;
            if (result.state) redirect = result;
            event.preventDefault();
            var redirectParams = getMatchParams(toParams, cfg.params);
            $state.go(redirect.state, angular.extend(redirectParams, redirect.params));
        });
        $rootScope.$on("$stateChangeSuccess", function(event, toState, toParams, fromState, fromParams) {
            var deepStateStatus = computeDeepStateStatus(toState);
            if (deepStateStatus) {
                var name = toState.name;
                angular.forEach(lastSubstate, function(redirect, dsrState) {
                    var cfg = getConfig($state.get(dsrState));
                    var key = getParamsString(toParams, cfg.params);
                    if (name == dsrState || name.indexOf(dsrState + ".") != -1) {
                        lastSubstate[dsrState][key] = {
                            state: name,
                            params: angular.copy(toParams)
                        };
                    }
                });
            }
        });
        return {
            reset: function(stateOrName, params) {
                if (!stateOrName) {
                    angular.forEach(lastSubstate, function(redirect, dsrState) {
                        lastSubstate[dsrState] = {};
                    });
                } else {
                    var state = $state.get(stateOrName);
                    if (!state) throw new Error("Unknown state: " + stateOrName);
                    if (lastSubstate[state.name]) {
                        if (params) {
                            var key = getParamsString(params, getConfig(state).params);
                            delete lastSubstate[state.name][key];
                        } else {
                            lastSubstate[state.name] = {};
                        }
                    }
                }
            }
        };
    } ]);
    angular.module("ct.ui.router.extras.dsr").run([ "$deepStateRedirect", function($deepStateRedirect) {} ]);
    angular.module("ct.ui.router.extras.sticky", [ "ct.ui.router.extras.core" ]);
    var mod_sticky = angular.module("ct.ui.router.extras.sticky");
    $StickyStateProvider.$inject = [ "$stateProvider", "uirextras_coreProvider" ];
    function $StickyStateProvider($stateProvider, uirextras_coreProvider) {
        var core = uirextras_coreProvider;
        var inheritParams = core.inheritParams;
        var protoKeys = core.protoKeys;
        var map = core.map;
        var inactiveStates = {};
        var stickyStates = {};
        var $state;
        var DEBUG = false;
        this.registerStickyState = function(state) {
            stickyStates[state.name] = state;
        };
        this.enableDebug = this.debugMode = function(enabled) {
            if (angular.isDefined(enabled)) DEBUG = enabled;
            return DEBUG;
        };
        this.$get = [ "$rootScope", "$state", "$stateParams", "$injector", "$log", function($rootScope, $state, $stateParams, $injector, $log) {
            function mapInactives() {
                var mappedStates = {};
                angular.forEach(inactiveStates, function(state, name) {
                    var stickyAncestors = getStickyStateStack(state);
                    for (var i = 0; i < stickyAncestors.length; i++) {
                        var parent = stickyAncestors[i].parent;
                        mappedStates[parent.name] = mappedStates[parent.name] || [];
                        mappedStates[parent.name].push(state);
                    }
                    if (mappedStates[""]) {
                        mappedStates["__inactives"] = mappedStates[""];
                    }
                });
                return mappedStates;
            }
            function getStickyStateStack(state) {
                var stack = [];
                if (!state) return stack;
                do {
                    if (state.sticky) stack.push(state);
                    state = state.parent;
                } while (state);
                stack.reverse();
                return stack;
            }
            function getStickyTransitionType(fromPath, toPath, keep) {
                if (fromPath[keep] === toPath[keep]) return {
                    from: false,
                    to: false
                };
                var stickyFromState = keep < fromPath.length && fromPath[keep].self.sticky;
                var stickyToState = keep < toPath.length && toPath[keep].self.sticky;
                return {
                    from: stickyFromState,
                    to: stickyToState
                };
            }
            function getEnterTransition(state, stateParams, reloadStateTree, ancestorParamsChanged) {
                if (ancestorParamsChanged) return "updateStateParams";
                var inactiveState = inactiveStates[state.self.name];
                if (!inactiveState) return "enter";
                if (state.self === reloadStateTree) return "updateStateParams";
                var paramsMatch = equalForKeys(stateParams, inactiveState.locals.globals.$stateParams, state.ownParams);
                return paramsMatch ? "reactivate" : "updateStateParams";
            }
            function getInactivatedState(state, stateParams) {
                var inactiveState = inactiveStates[state.name];
                if (!inactiveState) return null;
                if (!stateParams) return inactiveState;
                var paramsMatch = equalForKeys(stateParams, inactiveState.locals.globals.$stateParams, state.ownParams);
                return paramsMatch ? inactiveState : null;
            }
            function equalForKeys(a, b, keys) {
                if (!angular.isArray(keys) && angular.isObject(keys)) {
                    keys = protoKeys(keys, [ "$$keys", "$$values", "$$equals", "$$validates", "$$new", "$$parent" ]);
                }
                if (!keys) {
                    keys = [];
                    for (var n in a) keys.push(n);
                }
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    if (a[k] != b[k]) return false;
                }
                return true;
            }
            var stickySupport = {
                getInactiveStates: function() {
                    var states = [];
                    angular.forEach(inactiveStates, function(state) {
                        states.push(state);
                    });
                    return states;
                },
                getInactiveStatesByParent: function() {
                    return mapInactives();
                },
                processTransition: function(transition) {
                    var result = {
                        inactives: [],
                        enter: [],
                        exit: [],
                        keep: 0
                    };
                    var fromPath = transition.fromState.path, fromParams = transition.fromParams, toPath = transition.toState.path, toParams = transition.toParams, reloadStateTree = transition.reloadStateTree, options = transition.options;
                    var keep = 0, state = toPath[keep];
                    if (options.inherit) {
                        toParams = inheritParams($stateParams, toParams || {}, $state.$current, transition.toState);
                    }
                    while (state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams)) {
                        state = toPath[++keep];
                    }
                    result.keep = keep;
                    var idx, deepestUpdatedParams, deepestReactivate, noLongerInactiveStates = {}, pType = getStickyTransitionType(fromPath, toPath, keep);
                    var ancestorUpdated = !!options.reload;
                    for (idx = keep; idx < toPath.length; idx++) {
                        var enterTrans = !pType.to ? "enter" : getEnterTransition(toPath[idx], toParams, reloadStateTree, ancestorUpdated);
                        ancestorUpdated = ancestorUpdated || enterTrans == "updateStateParams";
                        result.enter[idx] = enterTrans;
                        if (enterTrans == "reactivate") deepestReactivate = noLongerInactiveStates[toPath[idx].name] = toPath[idx];
                        if (enterTrans == "updateStateParams") deepestUpdatedParams = noLongerInactiveStates[toPath[idx].name] = toPath[idx];
                    }
                    deepestReactivate = deepestReactivate ? deepestReactivate.self.name + "." : "";
                    deepestUpdatedParams = deepestUpdatedParams ? deepestUpdatedParams.self.name + "." : "";
                    var inactivesByParent = mapInactives();
                    var keptStateNames = [ "" ].concat(map(fromPath.slice(0, keep), function(state) {
                        return state.self.name;
                    }));
                    angular.forEach(keptStateNames, function(name) {
                        var inactiveChildren = inactivesByParent[name];
                        for (var i = 0; inactiveChildren && i < inactiveChildren.length; i++) {
                            var child = inactiveChildren[i];
                            if (!noLongerInactiveStates[child.name] && (!deepestReactivate || child.self.name.indexOf(deepestReactivate) !== 0) && (!deepestUpdatedParams || child.self.name.indexOf(deepestUpdatedParams) !== 0)) result.inactives.push(child);
                        }
                    });
                    for (idx = keep; idx < fromPath.length; idx++) {
                        var exitTrans = "exit";
                        if (pType.from) {
                            result.inactives.push(fromPath[idx]);
                            exitTrans = "inactivate";
                        }
                        result.exit[idx] = exitTrans;
                    }
                    return result;
                },
                stateInactivated: function(state) {
                    inactiveStates[state.self.name] = state;
                    state.self.status = "inactive";
                    if (state.self.onInactivate) $injector.invoke(state.self.onInactivate, state.self, state.locals.globals);
                },
                stateReactivated: function(state) {
                    if (inactiveStates[state.self.name]) {
                        delete inactiveStates[state.self.name];
                    }
                    state.self.status = "entered";
                    if (state.self.onReactivate) $injector.invoke(state.self.onReactivate, state.self, state.locals.globals);
                },
                stateExiting: function(exiting, exitQueue, onExit) {
                    var exitingNames = {};
                    angular.forEach(exitQueue, function(state) {
                        exitingNames[state.self.name] = true;
                    });
                    angular.forEach(inactiveStates, function(inactiveExiting, name) {
                        if (!exitingNames[name] && inactiveExiting.includes[exiting.name]) {
                            if (DEBUG) $log.debug("Exiting " + name + " because it's a substate of " + exiting.name + " and wasn't found in ", exitingNames);
                            if (inactiveExiting.self.onExit) $injector.invoke(inactiveExiting.self.onExit, inactiveExiting.self, inactiveExiting.locals.globals);
                            angular.forEach(inactiveExiting.locals, function(localval, key) {
                                delete inactivePseudoState.locals[key];
                            });
                            inactiveExiting.locals = null;
                            inactiveExiting.self.status = "exited";
                            delete inactiveStates[name];
                        }
                    });
                    if (onExit) $injector.invoke(onExit, exiting.self, exiting.locals.globals);
                    exiting.locals = null;
                    exiting.self.status = "exited";
                    delete inactiveStates[exiting.self.name];
                },
                stateEntering: function(entering, params, onEnter, updateParams) {
                    var inactivatedState = getInactivatedState(entering);
                    if (inactivatedState && (updateParams || !getInactivatedState(entering, params))) {
                        var savedLocals = entering.locals;
                        this.stateExiting(inactivatedState);
                        entering.locals = savedLocals;
                    }
                    entering.self.status = "entered";
                    if (onEnter) $injector.invoke(onEnter, entering.self, entering.locals.globals);
                },
                reset: function reset(inactiveState, params) {
                    var state = $state.get(inactiveState);
                    var exiting = getInactivatedState(state, params);
                    if (!exiting) return false;
                    stickySupport.stateExiting(exiting);
                    $rootScope.$broadcast("$viewContentLoading");
                    return true;
                }
            };
            return stickySupport;
        } ];
    }
    mod_sticky.provider("$stickyState", $StickyStateProvider);
    var _StickyState;
    var internalStates = {};
    var root, pendingTransitions = [], pendingRestore, inactivePseudoState, versionHeuristics = {
        hasParamSet: false
    };
    function SurrogateState(type) {
        return {
            resolve: {},
            locals: {
                globals: root && root.locals && root.locals.globals
            },
            views: {},
            self: {},
            params: {},
            ownParams: versionHeuristics.hasParamSet ? {
                $$equals: function() {
                    return true;
                }
            } : [],
            surrogateType: type
        };
    }
    angular.module("ct.ui.router.extras.sticky").run([ "$stickyState", function($stickyState) {
        _StickyState = $stickyState;
    } ]);
    angular.module("ct.ui.router.extras.sticky").config([ "$provide", "$stateProvider", "$stickyStateProvider", "$urlMatcherFactoryProvider", "uirextras_coreProvider", function($provide, $stateProvider, $stickyStateProvider, $urlMatcherFactoryProvider, uirextras_coreProvider) {
        var core = uirextras_coreProvider;
        var internalStates = core.internalStates;
        var inherit = core.inherit;
        var inheritParams = core.inheritParams;
        var map = core.map;
        var filterObj = core.filterObj;
        versionHeuristics.hasParamSet = !!$urlMatcherFactoryProvider.ParamSet;
        inactivePseudoState = angular.extend(new SurrogateState("__inactives"), {
            self: {
                name: "__inactives"
            }
        });
        root = pendingRestore = undefined;
        pendingTransitions = [];
        uirextras_coreProvider.onStateRegistered(function(state) {
            if (state.self.sticky === true) {
                $stickyStateProvider.registerStickyState(state.self);
            }
        });
        var $state_transitionTo;
        $provide.decorator("$state", [ "$delegate", "$log", "$q", function($state, $log, $q) {
            root = $state.$current;
            internalStates[""] = root;
            root.parent = inactivePseudoState;
            inactivePseudoState.parent = undefined;
            root.locals = inherit(inactivePseudoState.locals, root.locals);
            delete inactivePseudoState.locals.globals;
            $state_transitionTo = $state.transitionTo;
            $state.transitionTo = function(to, toParams, options) {
                var DEBUG = $stickyStateProvider.debugMode();
                if (!inactivePseudoState.locals) inactivePseudoState.locals = root.locals;
                var idx = pendingTransitions.length;
                if (pendingRestore) {
                    pendingRestore();
                    if (DEBUG) {
                        $log.debug("Restored paths from pending transition");
                    }
                }
                var fromState = $state.$current, fromParams = $state.params;
                var rel = options && options.relative || $state.$current;
                var toStateSelf = $state.get(to, rel);
                var savedToStatePath, savedFromStatePath, stickyTransitions;
                var reactivated = [], exited = [], terminalReactivatedState;
                toParams = toParams || {};
                arguments[1] = toParams;
                var noop = function() {};
                var restore = function() {
                    if (savedToStatePath) {
                        toState.path = savedToStatePath;
                        savedToStatePath = null;
                    }
                    if (savedFromStatePath) {
                        fromState.path = savedFromStatePath;
                        savedFromStatePath = null;
                    }
                    angular.forEach(restore.restoreFunctions, function(restoreFunction) {
                        restoreFunction();
                    });
                    restore = noop;
                    pendingRestore = null;
                    pendingTransitions.splice(idx, 1);
                };
                restore.restoreFunctions = [];
                restore.addRestoreFunction = function addRestoreFunction(fn) {
                    this.restoreFunctions.push(fn);
                };
                function stateReactivatedSurrogatePhase1(state) {
                    var surrogate = angular.extend(new SurrogateState("reactivate_phase1"), {
                        locals: state.locals
                    });
                    surrogate.self = angular.extend({}, state.self);
                    return surrogate;
                }
                function stateReactivatedSurrogatePhase2(state) {
                    var surrogate = angular.extend(new SurrogateState("reactivate_phase2"), state);
                    var oldOnEnter = surrogate.self.onEnter;
                    surrogate.resolve = {};
                    surrogate.views = {};
                    surrogate.self.onEnter = function() {
                        surrogate.locals = state.locals;
                        _StickyState.stateReactivated(state);
                    };
                    restore.addRestoreFunction(function() {
                        state.self.onEnter = oldOnEnter;
                    });
                    return surrogate;
                }
                function stateInactivatedSurrogate(state) {
                    var surrogate = new SurrogateState("inactivate");
                    surrogate.self = state.self;
                    var oldOnExit = state.self.onExit;
                    surrogate.self.onExit = function() {
                        _StickyState.stateInactivated(state);
                    };
                    restore.addRestoreFunction(function() {
                        state.self.onExit = oldOnExit;
                    });
                    return surrogate;
                }
                function stateEnteredSurrogate(state, toParams) {
                    var oldOnEnter = state.self.onEnter;
                    state.self.onEnter = function() {
                        _StickyState.stateEntering(state, toParams, oldOnEnter);
                    };
                    restore.addRestoreFunction(function() {
                        state.self.onEnter = oldOnEnter;
                    });
                    return state;
                }
                function stateUpdateParamsSurrogate(state, toParams) {
                    var oldOnEnter = state.self.onEnter;
                    state.self.onEnter = function() {
                        _StickyState.stateEntering(state, toParams, oldOnEnter, true);
                    };
                    restore.addRestoreFunction(function() {
                        state.self.onEnter = oldOnEnter;
                    });
                    return state;
                }
                function stateExitedSurrogate(state) {
                    var oldOnExit = state.self.onExit;
                    state.self.onExit = function() {
                        _StickyState.stateExiting(state, exited, oldOnExit);
                    };
                    restore.addRestoreFunction(function() {
                        state.self.onExit = oldOnExit;
                    });
                    return state;
                }
                if (toStateSelf) {
                    var toState = internalStates[toStateSelf.name];
                    if (toState) {
                        savedToStatePath = toState.path;
                        savedFromStatePath = fromState.path;
                        var reload = options && options.reload || false;
                        var reloadStateTree = reload && (reload === true ? savedToStatePath[0].self : $state.get(reload, rel));
                        if (options && reload && reload !== true) delete options.reload;
                        var currentTransition = {
                            toState: toState,
                            toParams: toParams || {},
                            fromState: fromState,
                            fromParams: fromParams || {},
                            options: options,
                            reloadStateTree: reloadStateTree
                        };
                        pendingTransitions.push(currentTransition);
                        pendingRestore = restore;
                        if (reloadStateTree) {
                            currentTransition.toParams.$$uirouterextrasreload = Math.random();
                            var params = reloadStateTree.$$state().params;
                            var ownParams = reloadStateTree.$$state().ownParams;
                            if (versionHeuristics.hasParamSet) {
                                var tempParam = new $urlMatcherFactoryProvider.Param("$$uirouterextrasreload");
                                params.$$uirouterextrasreload = ownParams.$$uirouterextrasreload = tempParam;
                                restore.restoreFunctions.push(function() {
                                    delete params.$$uirouterextrasreload;
                                    delete ownParams.$$uirouterextrasreload;
                                });
                            } else {
                                params.push("$$uirouterextrasreload");
                                ownParams.push("$$uirouterextrasreload");
                                restore.restoreFunctions.push(function() {
                                    params.length = params.length - 1;
                                    ownParams.length = ownParams.length - 1;
                                });
                            }
                        }
                        stickyTransitions = _StickyState.processTransition(currentTransition);
                        if (DEBUG) debugTransition($log, currentTransition, stickyTransitions);
                        var surrogateToPath = toState.path.slice(0, stickyTransitions.keep);
                        var surrogateFromPath = fromState.path.slice(0, stickyTransitions.keep);
                        angular.forEach(inactivePseudoState.locals, function(local, name) {
                            if (name.indexOf("@") != -1) delete inactivePseudoState.locals[name];
                        });
                        for (var i = 0; i < stickyTransitions.inactives.length; i++) {
                            var iLocals = stickyTransitions.inactives[i].locals;
                            angular.forEach(iLocals, function(view, name) {
                                if (iLocals.hasOwnProperty(name) && name.indexOf("@") != -1) {
                                    inactivePseudoState.locals[name] = view;
                                }
                            });
                        }
                        angular.forEach(stickyTransitions.enter, function(value, idx) {
                            var surrogate;
                            var enteringState = toState.path[idx];
                            if (value === "reactivate") {
                                surrogate = stateReactivatedSurrogatePhase1(enteringState);
                                surrogateToPath.push(surrogate);
                                surrogateFromPath.push(surrogate);
                                reactivated.push(stateReactivatedSurrogatePhase2(enteringState));
                                terminalReactivatedState = enteringState;
                            } else if (value === "updateStateParams") {
                                surrogate = stateUpdateParamsSurrogate(enteringState);
                                surrogateToPath.push(surrogate);
                                terminalReactivatedState = enteringState;
                            } else if (value === "enter") {
                                surrogateToPath.push(stateEnteredSurrogate(enteringState));
                            }
                        });
                        angular.forEach(stickyTransitions.exit, function(value, idx) {
                            var exiting = fromState.path[idx];
                            if (value === "inactivate") {
                                surrogateFromPath.push(stateInactivatedSurrogate(exiting));
                                exited.push(exiting);
                            } else if (value === "exit") {
                                surrogateFromPath.push(stateExitedSurrogate(exiting));
                                exited.push(exiting);
                            }
                        });
                        if (reactivated.length) {
                            angular.forEach(reactivated, function(surrogate) {
                                surrogateToPath.push(surrogate);
                            });
                        }
                        if (toState === terminalReactivatedState) {
                            var prefix = terminalReactivatedState.self.name + ".";
                            var inactiveStates = _StickyState.getInactiveStates();
                            var inactiveOrphans = [];
                            inactiveStates.forEach(function(exiting) {
                                if (exiting.self.name.indexOf(prefix) === 0) {
                                    inactiveOrphans.push(exiting);
                                }
                            });
                            inactiveOrphans.sort();
                            inactiveOrphans.reverse();
                            surrogateFromPath = surrogateFromPath.concat(map(inactiveOrphans, function(exiting) {
                                return stateExitedSurrogate(exiting);
                            }));
                            exited = exited.concat(inactiveOrphans);
                        }
                        toState.path = surrogateToPath;
                        fromState.path = surrogateFromPath;
                        var pathMessage = function(state) {
                            return (state.surrogateType ? state.surrogateType + ":" : "") + state.self.name;
                        };
                        if (DEBUG) $log.debug("SurrogateFromPath: ", map(surrogateFromPath, pathMessage));
                        if (DEBUG) $log.debug("SurrogateToPath:   ", map(surrogateToPath, pathMessage));
                    }
                }
                var transitionPromise = $state_transitionTo.apply($state, arguments);
                return transitionPromise.then(function transitionSuccess(state) {
                    restore();
                    if (DEBUG) debugViewsAfterSuccess($log, internalStates[state.name], $state);
                    state.status = "active";
                    return state;
                }, function transitionFailed(err) {
                    restore();
                    if (DEBUG && err.message !== "transition prevented" && err.message !== "transition aborted" && err.message !== "transition superseded") {
                        $log.debug("transition failed", err);
                        console.log(err.stack);
                    }
                    return $q.reject(err);
                });
            };
            return $state;
        } ]);
        function debugTransition($log, currentTransition, stickyTransition) {
            function message(path, index, state) {
                return path[index] ? path[index].toUpperCase() + ": " + state.self.name : "(" + state.self.name + ")";
            }
            var inactiveLogVar = map(stickyTransition.inactives, function(state) {
                return state.self.name;
            });
            var enterLogVar = map(currentTransition.toState.path, function(state, index) {
                return message(stickyTransition.enter, index, state);
            });
            var exitLogVar = map(currentTransition.fromState.path, function(state, index) {
                return message(stickyTransition.exit, index, state);
            });
            var transitionMessage = currentTransition.fromState.self.name + ": " + angular.toJson(currentTransition.fromParams) + ": " + " -> " + currentTransition.toState.self.name + ": " + angular.toJson(currentTransition.toParams);
            $log.debug("   Current transition: ", transitionMessage);
            $log.debug("Before transition, inactives are:   : ", map(_StickyState.getInactiveStates(), function(s) {
                return s.self.name;
            }));
            $log.debug("After transition,  inactives will be: ", inactiveLogVar);
            $log.debug("Transition will exit:  ", exitLogVar);
            $log.debug("Transition will enter: ", enterLogVar);
        }
        function debugViewsAfterSuccess($log, currentState, $state) {
            $log.debug("Current state: " + currentState.self.name + ", inactive states: ", map(_StickyState.getInactiveStates(), function(s) {
                return s.self.name;
            }));
            var viewMsg = function(local, name) {
                return "'" + name + "' (" + local.$$state.name + ")";
            };
            var statesOnly = function(local, name) {
                return name != "globals" && name != "resolve";
            };
            var viewsForState = function(state) {
                var views = map(filterObj(state.locals, statesOnly), viewMsg).join(", ");
                return "(" + (state.self.name ? state.self.name : "root") + ".locals" + (views.length ? ": " + views : "") + ")";
            };
            var message = viewsForState(currentState);
            var parent = currentState.parent;
            while (parent && parent !== currentState) {
                if (parent.self.name === "") {
                    message = viewsForState($state.$current.path[0]) + " / " + message;
                }
                message = viewsForState(parent) + " / " + message;
                currentState = parent;
                parent = currentState.parent;
            }
            $log.debug("Views: " + message);
        }
    } ]);
    (function(angular, undefined) {
        var app = angular.module("ct.ui.router.extras.future", [ "ct.ui.router.extras.core" ]);
        _futureStateProvider.$inject = [ "$stateProvider", "$urlRouterProvider", "$urlMatcherFactoryProvider", "uirextras_coreProvider" ];
        function _futureStateProvider($stateProvider, $urlRouterProvider, $urlMatcherFactory, uirextras_coreProvider) {
            var core = uirextras_coreProvider;
            var internalStates = core.internalStates;
            var stateFactories = {}, futureStates = {};
            var lazyloadInProgress = false, resolveFunctions = [], initPromise, initDone = false;
            var provider = this;
            this.addResolve = function(promiseFn) {
                resolveFunctions.push(promiseFn);
            };
            this.stateFactory = function(futureStateType, factory) {
                stateFactories[futureStateType] = factory;
            };
            this.futureState = function(futureState) {
                if (futureState.stateName) futureState.name = futureState.stateName;
                if (futureState.urlPrefix) futureState.url = "^" + futureState.urlPrefix;
                futureStates[futureState.name] = futureState;
                var parentMatcher, parentName = futureState.name.split(/\./).slice(0, -1).join("."), realParent = findState(futureState.parent || parentName);
                if (realParent) {
                    parentMatcher = realParent.url || realParent.navigable.url;
                } else if (parentName === "") {
                    parentMatcher = $urlMatcherFactory.compile("");
                } else {
                    var futureParent = findState(futureState.parent || parentName, true);
                    if (!futureParent) throw new Error("Couldn't determine parent state of future state. FutureState:" + angular.toJson(futureState));
                    var pattern = futureParent.urlMatcher.source.replace(/\*rest$/, "");
                    parentMatcher = $urlMatcherFactory.compile(pattern);
                    futureState.parentFutureState = futureParent;
                }
                if (futureState.url) {
                    futureState.urlMatcher = futureState.url.charAt(0) === "^" ? $urlMatcherFactory.compile(futureState.url.substring(1) + "*rest") : parentMatcher.concat(futureState.url + "*rest");
                }
            };
            this.get = function() {
                return angular.extend({}, futureStates);
            };
            function findState(stateOrName, findFutureState) {
                var statename = angular.isObject(stateOrName) ? stateOrName.name : stateOrName;
                return !findFutureState ? internalStates[statename] : futureStates[statename];
            }
            function findFutureState($state, options) {
                if (options.name) {
                    var nameComponents = options.name.split(/\./);
                    if (options.name.charAt(0) === ".") nameComponents[0] = $state.current.name;
                    while (nameComponents.length) {
                        var stateName = nameComponents.join(".");
                        if ($state.get(stateName, {
                            relative: $state.current
                        })) return null;
                        if (futureStates[stateName]) return futureStates[stateName];
                        nameComponents.pop();
                    }
                }
                if (options.url) {
                    var matches = [];
                    for (var future in futureStates) {
                        var matcher = futureStates[future].urlMatcher;
                        if (matcher && matcher.exec(options.url)) {
                            matches.push(futureStates[future]);
                        }
                    }
                    var copy = matches.slice(0);
                    for (var i = matches.length - 1; i >= 0; i--) {
                        for (var j = 0; j < copy.length; j++) {
                            if (matches[i] === copy[j].parentFutureState) matches.splice(i, 1);
                        }
                    }
                    return matches[0];
                }
            }
            function lazyLoadState($injector, futureState) {
                lazyloadInProgress = true;
                var $q = $injector.get("$q");
                if (!futureState) {
                    var deferred = $q.defer();
                    deferred.reject("No lazyState passed in " + futureState);
                    return deferred.promise;
                }
                var promise = $q.when([]), parentFuture = futureState.parentFutureState;
                if (parentFuture && futureStates[parentFuture.name]) {
                    promise = lazyLoadState($injector, futureStates[parentFuture.name]);
                }
                var type = futureState.type;
                var factory = stateFactories[type];
                if (!factory) throw Error("No state factory for futureState.type: " + (futureState && futureState.type));
                return promise.then(function(array) {
                    var injectorPromise = $injector.invoke(factory, factory, {
                        futureState: futureState
                    });
                    return injectorPromise.then(function(fullState) {
                        if (fullState) {
                            array.push(fullState);
                        }
                        return array;
                    });
                })["finally"](function() {
                    delete futureStates[futureState.name];
                });
            }
            var otherwiseFunc = [ "$log", "$location", function otherwiseFunc($log, $location) {
                $log.debug("Unable to map " + $location.path());
            } ];
            function futureState_otherwise($injector, $location) {
                var resyncing = false;
                var lazyLoadMissingState = [ "$rootScope", "$urlRouter", "$state", function lazyLoadMissingState($rootScope, $urlRouter, $state) {
                    function resync() {
                        resyncing = true;
                        $urlRouter.sync();
                        resyncing = false;
                    }
                    if (!initDone) {
                        initPromise().then(resync);
                        initDone = true;
                        return;
                    }
                    var futureState = findFutureState($state, {
                        url: $location.path()
                    });
                    if (!futureState) {
                        return $injector.invoke(otherwiseFunc);
                    }
                    lazyLoadState($injector, futureState).then(function lazyLoadedStateCallback(states) {
                        states.forEach(function(state) {
                            if (state && (!$state.get(state) || state.name && !$state.get(state.name))) $stateProvider.state(state);
                        });
                        lazyloadInProgress = false;
                        resync();
                    }, function lazyLoadStateAborted() {
                        lazyloadInProgress = false;
                        resync();
                    });
                } ];
                if (lazyloadInProgress) return;
                var nextFn = resyncing ? otherwiseFunc : lazyLoadMissingState;
                return $injector.invoke(nextFn);
            }
            $urlRouterProvider.otherwise(futureState_otherwise);
            $urlRouterProvider.otherwise = function(rule) {
                if (angular.isString(rule)) {
                    var redirect = rule;
                    rule = function() {
                        return redirect;
                    };
                } else if (!angular.isFunction(rule)) throw new Error("'rule' must be a function");
                otherwiseFunc = [ "$injector", "$location", rule ];
                return $urlRouterProvider;
            };
            var serviceObject = {
                getResolvePromise: function() {
                    return initPromise();
                }
            };
            this.$get = [ "$injector", "$state", "$q", "$rootScope", "$urlRouter", "$timeout", "$log", function futureStateProvider_get($injector, $state, $q, $rootScope, $urlRouter, $timeout, $log) {
                function init() {
                    $rootScope.$on("$stateNotFound", function futureState_notFound(event, unfoundState, fromState, fromParams) {
                        if (lazyloadInProgress) return;
                        $log.debug("event, unfoundState, fromState, fromParams", event, unfoundState, fromState, fromParams);
                        var futureState = findFutureState($state, {
                            name: unfoundState.to
                        });
                        if (!futureState) return;
                        event.preventDefault();
                        var promise = lazyLoadState($injector, futureState);
                        promise.then(function(states) {
                            states.forEach(function(state) {
                                if (state && (!$state.get(state) || state.name && !$state.get(state.name))) $stateProvider.state(state);
                            });
                            $state.go(unfoundState.to, unfoundState.toParams);
                            lazyloadInProgress = false;
                        }, function(error) {
                            console.log("failed to lazy load state ", error);
                            $state.go(fromState, fromParams);
                            lazyloadInProgress = false;
                        });
                    });
                    if (!initPromise) {
                        var promises = [];
                        angular.forEach(resolveFunctions, function(promiseFn) {
                            promises.push($injector.invoke(promiseFn));
                        });
                        initPromise = function() {
                            return $q.all(promises);
                        };
                    }
                    initPromise().then(function retryInitialState() {
                        $timeout(function() {
                            if ($state.transition) {
                                $state.transition.then($urlRouter.sync, $urlRouter.sync);
                            } else {
                                $urlRouter.sync();
                            }
                        });
                    });
                }
                init();
                serviceObject.state = $stateProvider.state;
                serviceObject.futureState = provider.futureState;
                serviceObject.get = provider.get;
                return serviceObject;
            } ];
        }
        app.provider("$futureState", _futureStateProvider);
        var statesAddedQueue = {
            state: function(state) {
                if (statesAddedQueue.$rootScope) statesAddedQueue.$rootScope.$broadcast("$stateAdded", state);
            },
            itsNowRuntimeOhWhatAHappyDay: function($rootScope) {
                statesAddedQueue.$rootScope = $rootScope;
            },
            $rootScope: undefined
        };
        app.config([ "$stateProvider", function($stateProvider) {
            var realStateFn = $stateProvider.state;
            $stateProvider.state = function state_announce() {
                var val = realStateFn.apply($stateProvider, arguments);
                var state = angular.isObject(arguments[0]) ? arguments[0] : arguments[1];
                statesAddedQueue.state(state);
                return val;
            };
        } ]);
        app.run([ "$futureState", function($futureState, $rootScope) {
            statesAddedQueue.itsNowRuntimeOhWhatAHappyDay($rootScope);
        } ]);
    })(angular);
    angular.module("ct.ui.router.extras.previous", [ "ct.ui.router.extras.core", "ct.ui.router.extras.transition" ]).service("$previousState", [ "$rootScope", "$state", function($rootScope, $state) {
        var previous = null, lastPrevious = null, memos = {};
        $rootScope.$on("$transitionStart", function(evt, $transition$) {
            var from = $transition$.from;
            var fromState = from.state && from.state.$$state && from.state.$$state();
            if (fromState && fromState.navigable) {
                lastPrevious = previous;
                previous = $transition$.from;
            }
            $transition$.promise.then(commit).catch(revert);
            function commit() {
                lastPrevious = null;
            }
            function revert() {
                previous = lastPrevious;
            }
        });
        var $previousState = {
            get: function(memoName) {
                return memoName ? memos[memoName] : previous;
            },
            go: function(memoName, options) {
                var to = $previousState.get(memoName);
                return $state.go(to.state, to.params, options);
            },
            memo: function(memoName, defaultStateName, defaultStateParams) {
                memos[memoName] = previous || {
                    state: $state.get(defaultStateName),
                    params: defaultStateParams
                };
            },
            forget: function(memoName) {
                if (memoName) {
                    delete memos[memoName];
                } else {
                    previous = undefined;
                }
            }
        };
        return $previousState;
    } ]);
    angular.module("ct.ui.router.extras.previous").run([ "$previousState", function($previousState) {} ]);
    angular.module("ct.ui.router.extras.transition", [ "ct.ui.router.extras.core" ]).config([ "$provide", function($provide) {
        $provide.decorator("$state", [ "$delegate", "$rootScope", "$q", "$injector", function($state, $rootScope, $q, $injector) {
            var $state_transitionTo = $state.transitionTo;
            var transitionDepth = -1;
            var tDataStack = [];
            var restoreFnStack = [];
            function decorateInjector(tData) {
                var oldinvoke = $injector.invoke;
                var oldinstantiate = $injector.instantiate;
                $injector.invoke = function(fn, self, locals) {
                    return oldinvoke(fn, self, angular.extend({
                        $transition$: tData
                    }, locals));
                };
                $injector.instantiate = function(fn, locals) {
                    return oldinstantiate(fn, angular.extend({
                        $transition$: tData
                    }, locals));
                };
                return function restoreItems() {
                    $injector.invoke = oldinvoke;
                    $injector.instantiate = oldinstantiate;
                };
            }
            function popStack() {
                restoreFnStack.pop()();
                tDataStack.pop();
                transitionDepth--;
            }
            function transitionSuccess(deferred, tSuccess) {
                return function successFn(data) {
                    popStack();
                    $rootScope.$broadcast("$transitionSuccess", tSuccess);
                    deferred.resolve(data);
                    return data;
                };
            }
            function transitionFailure(deferred, tFail) {
                return function failureFn(error) {
                    popStack();
                    $rootScope.$broadcast("$transitionError", tFail, error);
                    deferred.reject(error);
                    return $q.reject(error);
                };
            }
            $state.transitionTo = function(to, toParams, options) {
                var deferred = $q.defer();
                var tData = tDataStack[++transitionDepth] = {
                    promise: deferred.promise
                };
                restoreFnStack[transitionDepth] = function() {};
                var tPromise = $state_transitionTo.apply($state, arguments);
                return tPromise.then(transitionSuccess(deferred, tData), transitionFailure(deferred, tData));
            };
            $rootScope.$on("$stateChangeStart", function(evt, toState, toParams, fromState, fromParams) {
                var depth = transitionDepth;
                var tData = angular.extend(tDataStack[depth], {
                    to: {
                        state: toState,
                        params: toParams
                    },
                    from: {
                        state: fromState,
                        params: fromParams
                    }
                });
                var restoreFn = decorateInjector(tData);
                restoreFnStack[depth] = restoreFn;
                $rootScope.$broadcast("$transitionStart", tData);
            });
            return $state;
        } ]);
    } ]);
    (function() {
        "use strict";
        var app = angular.module("ct.ui.router.extras.statevis", [ "ct.ui.router.extras.core", "ct.ui.router.extras.sticky" ]);
        app.directive("stateVis", [ "$state", "$timeout", "$interval", stateVisDirective ]);
        function stateVisDirective($state, $timeout, $interval) {
            return {
                scope: {
                    width: "@",
                    height: "@"
                },
                restrict: "AE",
                template: "<svg></svg>",
                link: function(_scope, _elem, _attrs) {
                    var stateMap = {};
                    var width = _scope.width || 400, height = _scope.height || 400;
                    var tree = d3.layout.tree().size([ width - 20, height - 20 ]).separation(function(a, b) {
                        return a.parent == b.parent ? 10 : 25;
                    });
                    var root = $state.get().filter(function(state) {
                        return state.name === "";
                    })[0];
                    var nodes = tree(root);
                    root.parent = root;
                    root.px = root.x = width / 2;
                    root.py = root.y = height / 2;
                    var activeNode = {};
                    activeNode.px = activeNode.x = root.px;
                    activeNode.py = activeNode.y = root.py;
                    var diagonal = d3.svg.diagonal();
                    var svg = d3.select(_elem.find("svg")[0]).attr("width", width).attr("height", height).append("g").attr("transform", "translate(10, 10)");
                    var node = svg.selectAll(".node"), link = svg.selectAll(".link"), active = svg.selectAll(".active");
                    var updateInterval = 200, transLength = 200, timer = setInterval(update, updateInterval);
                    function addStates(data) {
                        data = data.map(function(node) {
                            return node.name === "" ? root : angular.copy(node);
                        });
                        angular.extend(stateMap, data.reduce(function(map, node) {
                            map[node.name] = node;
                            return map;
                        }, {}));
                        data.forEach(function(node) {
                            var parentName = node.name.split(/\./).slice(0, -1).join(".");
                            var parent = node.name != parentName && stateMap[parentName];
                            if (parent) {
                                (parent.children || (parent.children = [])).push(node);
                                node.px = parent.px;
                                node.py = parent.py;
                                nodes.push(node);
                            }
                        });
                    }
                    $interval(function() {
                        _scope.states = $state.get();
                        angular.forEach(nodes, function(n) {
                            var s = $state.get(n.name);
                            if (s) {
                                n.status = s.status || "exited";
                            }
                        });
                    }, 250);
                    _scope.$watchCollection("states", function(newval, oldval) {
                        var oldstates = (oldval || []).map(function(s) {
                            return s.name;
                        });
                        addStates((newval || []).filter(function(state) {
                            return oldstates.indexOf(state.name) == -1;
                        }));
                    });
                    update(updateInterval);
                    function update() {
                        node = node.data(tree.nodes(root), function(d) {
                            return d.name;
                        });
                        link = link.data(tree.links(nodes), function(d) {
                            return d.target.name;
                        });
                        active = active.data(activeNode);
                        nodes.forEach(function(d) {
                            d.y = d.depth * 70;
                        });
                        var nodeEnter = node.enter();
                        function stateName(node) {
                            var name = node.name.split(".").pop();
                            if (node.sticky) {
                                name += " (STICKY)";
                            }
                            if (node.deepStateRedirect) {
                                name += " (DSR)";
                            }
                            return name;
                        }
                        active.enter().append("circle").attr("class", "active").attr("r", 13).attr("cx", function(d) {
                            return d.parent.px || 100;
                        }).attr("cy", function(d) {
                            return d.parent.py || 100;
                        });
                        nodeEnter.append("circle").attr("class", "node").attr("r", 9).attr("cx", function(d) {
                            return d.parent.px;
                        }).attr("cy", function(d) {
                            return d.parent.py;
                        });
                        nodeEnter.append("text").attr("class", "label").attr("x", function(d) {
                            return d.parent.px;
                        }).attr("y", function(d) {
                            return d.parent.py;
                        }).attr("text-anchor", function(d) {
                            return "middle";
                        }).text(stateName).style("fill-opacity", 1);
                        link.enter().insert("path", ".node").attr("class", "link").attr("d", function(d) {
                            var o = {
                                x: d.source.px,
                                y: d.source.py
                            };
                            return diagonal({
                                source: o,
                                target: o
                            });
                        });
                        var t = svg.transition().duration(transLength);
                        t.selectAll(".link").attr("d", diagonal);
                        var circleColors = {
                            entered: "#AF0",
                            exited: "#777",
                            active: "#0f0",
                            inactive: "#55F",
                            future: "#009"
                        };
                        t.selectAll(".node").attr("cx", function(d) {
                            return d.px = d.x;
                        }).attr("cy", function(d) {
                            return d.py = d.y;
                        }).attr("r", function(d) {
                            return d.status === "active" ? 15 : 10;
                        }).style("fill", function(d) {
                            return circleColors[d.status] || "#FFF";
                        });
                        t.selectAll(".label").attr("x", function(d) {
                            return d.px = d.x;
                        }).attr("y", function(d) {
                            return d.py = d.y - 15;
                        }).attr("transform", function(d) {
                            return "rotate(-25 " + d.x + " " + d.y + ")";
                        });
                        t.selectAll(".active").attr("x", function(d) {
                            return d.px = d.x;
                        }).attr("y", function(d) {
                            return d.py = d.y - 15;
                        });
                    }
                }
            };
        }
    })();
    angular.module("ct.ui.router.extras", [ "ct.ui.router.extras.core", "ct.ui.router.extras.dsr", "ct.ui.router.extras.future", "ct.ui.router.extras.previous", "ct.ui.router.extras.statevis", "ct.ui.router.extras.sticky", "ct.ui.router.extras.transition" ]);
})(angular);
(function(window, angular, undefined) {
    "use strict";
    var $sanitizeMinErr = angular.$$minErr("$sanitize");
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join("");
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," + "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," + "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," + "stop,svg,switch,text,title,tspan,use");
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
    var htmlAttrs = makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,target,title,type," + "valign,value,vspace,width");
    var svgAttrs = makeMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent," + "attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color," + "color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family," + "font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name," + "gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints," + "keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits," + "markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position," + "overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY," + "repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh," + "stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke," + "stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit," + "stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2," + "underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version," + "viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role," + "xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2," + "zoomAndPan");
    var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function htmlParser(html, handler) {
        if (typeof html !== "string") {
            if (html === null || typeof html === "undefined") {
                html = "";
            } else {
                html = "" + html;
            }
        }
        var index, chars, match, stack = [], last = html, text;
        stack.last = function() {
            return stack[stack.length - 1];
        };
        while (html) {
            text = "";
            chars = true;
            if (!stack.last() || !specialElements[stack.last()]) {
                if (html.indexOf("<!--") === 0) {
                    index = html.indexOf("--", 4);
                    if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);
                    if (match) {
                        html = html.replace(match[0], "");
                        chars = false;
                    }
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);
                    if (match) {
                        if (match[4]) {
                            html = html.substring(match[0].length);
                            match[0].replace(START_TAG_REGEXP, parseStartTag);
                        }
                        chars = false;
                    } else {
                        text += "<";
                        html = html.substring(1);
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    text += index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars) handler.chars(decodeEntities(text));
                }
            } else {
                html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                    text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
                    if (handler.chars) handler.chars(decodeEntities(text));
                    return "";
                });
                parseEndTag("", stack.last());
            }
            if (html == last) {
                throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block " + "of html: {0}", html);
            }
            last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }
            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }
            unary = voidElements[tagName] || !!unary;
            if (!unary) stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos = 0, i;
            tagName = angular.lowercase(tagName);
            if (tagName) for (pos = stack.length - 1; pos >= 0; pos--) if (stack[pos] == tagName) break;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) if (handler.end) handler.end(stack[i]);
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement("pre");
    function decodeEntities(value) {
        if (!value) {
            return "";
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out("<");
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = tag === "img" && lkey === "src" || lkey === "background";
                        if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(" ");
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? "/>" : ">");
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out("</");
                    out(tag);
                    out(">");
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
    angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/, MAILTO_REGEXP = /^mailto:/;
        return function(text, target) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while (match = raw.match(LINKY_URL_REGEXP)) {
                url = match[0];
                if (!match[2] && !match[4]) {
                    url = (match[3] ? "http://" : "mailto:") + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(""));
            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a ");
                if (angular.isDefined(target)) {
                    html.push('target="', target, '" ');
                }
                html.push('href="', url.replace(/"/g, "&quot;"), '">');
                addText(text);
                html.push("</a>");
            }
        };
    } ]);
})(window, window.angular);
(function(window, angular, undefined) {
    "use strict";
    var settings = {};
    var flags = {
        sdk: false,
        ready: false
    };
    var loadDeferred;
    angular.module("facebook", []).value("settings", settings).value("flags", flags).provider("Facebook", [ function() {
        settings.appId = null;
        this.setAppId = function(appId) {
            settings.appId = appId;
        };
        this.getAppId = function() {
            return settings.appId;
        };
        settings.locale = "en_US";
        this.setLocale = function(locale) {
            settings.locale = locale;
        };
        this.getLocale = function() {
            return settings.locale;
        };
        settings.status = true;
        this.setStatus = function(status) {
            settings.status = status;
        };
        this.getStatus = function() {
            return settings.status;
        };
        settings.channelUrl = null;
        this.setChannel = function(channel) {
            settings.channelUrl = channel;
        };
        this.getChannel = function() {
            return settings.channelUrl;
        };
        settings.cookie = true;
        this.setCookie = function(cookie) {
            settings.cookie = cookie;
        };
        this.getCookie = function() {
            return settings.cookie;
        };
        settings.xfbml = true;
        this.setXfbml = function(enable) {
            settings.xfbml = enable;
        };
        this.getXfbml = function() {
            return settings.xfbml;
        };
        this.setAuthResponse = function(obj) {
            settings.authResponse = obj || true;
        };
        this.getAuthResponse = function() {
            return settings.authResponse;
        };
        settings.frictionlessRequests = false;
        this.setFrictionlessRequests = function(enable) {
            settings.frictionlessRequests = enable;
        };
        this.getFrictionlessRequests = function() {
            return settings.frictionlessRequests;
        };
        settings.hideFlashCallback = null;
        this.setHideFlashCallback = function(obj) {
            settings.hideFlashCallback = obj || null;
        };
        this.getHideFlashCallback = function() {
            return settings.hideFlashCallback;
        };
        this.setInitCustomOption = function(key, value) {
            if (!angular.isString(key)) {
                return false;
            }
            settings[key] = value;
            return settings[key];
        };
        this.getInitOption = function(key) {
            if (!angular.isString(key) || !settings.hasOwnProperty(key)) {
                return false;
            }
            return settings[key];
        };
        settings.loadSDK = true;
        this.setLoadSDK = function(a) {
            settings.loadSDK = !!a;
        };
        this.getLoadSDK = function() {
            return settings.loadSDK;
        };
        settings.version = "v2.0";
        this.setSdkVersion = function(version) {
            settings.version = version;
        };
        this.getSdkVersion = function() {
            return settings.version;
        };
        this.init = function(initSettings, _loadSDK) {
            if (angular.isString(initSettings)) {
                settings.appId = initSettings || settings.appId;
            }
            if (angular.isObject(initSettings)) {
                angular.extend(settings, initSettings);
            }
            if (angular.isDefined(_loadSDK)) {
                settings.loadSDK = !!_loadSDK;
            }
        };
        this.$get = [ "$q", "$rootScope", "$timeout", "$window", function($q, $rootScope, $timeout, $window) {
            function NgFacebook() {
                this.appId = settings.appId;
            }
            NgFacebook.prototype.isReady = function() {
                return flags.ready;
            };
            NgFacebook.prototype.login = function() {
                var d = $q.defer(), args = Array.prototype.slice.call(arguments), userFn, userFnIndex;
                angular.forEach(args, function(arg, index) {
                    if (angular.isFunction(arg)) {
                        userFn = arg;
                        userFnIndex = index;
                    }
                });
                if (angular.isFunction(userFn) && angular.isNumber(userFnIndex)) {
                    args.splice(userFnIndex, 1, function(response) {
                        $timeout(function() {
                            if (angular.isUndefined(response.error)) {
                                d.resolve(response);
                            } else {
                                d.reject(response);
                            }
                            if (angular.isFunction(userFn)) {
                                userFn(response);
                            }
                        });
                    });
                }
                if (this.isReady()) {
                    $window.FB.login.apply($window.FB, args);
                } else {
                    $timeout(function() {
                        d.reject("Facebook.login() called before Facebook SDK has loaded.");
                    });
                }
                return d.promise;
            };
            angular.forEach([ "logout", "api", "ui", "getLoginStatus" ], function(name) {
                NgFacebook.prototype[name] = function() {
                    var d = $q.defer(), args = Array.prototype.slice.call(arguments), userFn, userFnIndex;
                    angular.forEach(args, function(arg, index) {
                        if (angular.isFunction(arg)) {
                            userFn = arg;
                            userFnIndex = index;
                        }
                    });
                    if (angular.isFunction(userFn) && angular.isNumber(userFnIndex)) {
                        args.splice(userFnIndex, 1, function(response) {
                            $timeout(function() {
                                if (response && typeof response.error === "undefined") {
                                    d.resolve(response);
                                } else {
                                    d.reject(response);
                                }
                                if (angular.isFunction(userFn)) {
                                    userFn(response);
                                }
                            });
                        });
                    }
                    $timeout(function() {
                        loadDeferred.promise.then(function() {
                            $window.FB[name].apply(FB, args);
                        }, function() {
                            throw "Facebook API could not be initialized properly";
                        });
                    });
                    return d.promise;
                };
            });
            NgFacebook.prototype.parseXFBML = function() {
                var d = $q.defer();
                $timeout(function() {
                    loadDeferred.promise.then(function() {
                        $window.FB.XFBML.parse();
                        d.resolve();
                    }, function() {
                        throw "Facebook API could not be initialized properly";
                    });
                });
                return d.promise;
            };
            NgFacebook.prototype.subscribe = function() {
                var d = $q.defer(), args = Array.prototype.slice.call(arguments), userFn, userFnIndex;
                angular.forEach(args, function(arg, index) {
                    if (angular.isFunction(arg)) {
                        userFn = arg;
                        userFnIndex = index;
                    }
                });
                if (angular.isFunction(userFn) && angular.isNumber(userFnIndex)) {
                    args.splice(userFnIndex, 1, function(response) {
                        $timeout(function() {
                            if (response && typeof response.error === "undefined") {
                                d.resolve(response);
                            } else {
                                d.reject(response);
                            }
                            if (angular.isFunction(userFn)) {
                                userFn(response);
                            }
                        });
                    });
                }
                $timeout(function() {
                    loadDeferred.promise.then(function() {
                        $window.FB.Event.subscribe.apply(FB, args);
                    }, function() {
                        throw "Facebook API could not be initialized properly";
                    });
                });
                return d.promise;
            };
            NgFacebook.prototype.unsubscribe = function() {
                var d = $q.defer(), args = Array.prototype.slice.call(arguments), userFn, userFnIndex;
                angular.forEach(args, function(arg, index) {
                    if (angular.isFunction(arg)) {
                        userFn = arg;
                        userFnIndex = index;
                    }
                });
                if (angular.isFunction(userFn) && angular.isNumber(userFnIndex)) {
                    args.splice(userFnIndex, 1, function(response) {
                        $timeout(function() {
                            if (response && typeof response.error === "undefined") {
                                d.resolve(response);
                            } else {
                                d.reject(response);
                            }
                            if (angular.isFunction(userFn)) {
                                userFn(response);
                            }
                        });
                    });
                }
                $timeout(function() {
                    loadDeferred.promise.then(function() {
                        $window.FB.Event.unsubscribe.apply(FB, args);
                    }, function() {
                        throw "Facebook API could not be initialized properly";
                    });
                });
                return d.promise;
            };
            return new NgFacebook();
        } ];
    } ]).run([ "$rootScope", "$q", "$window", "$timeout", function($rootScope, $q, $window, $timeout) {
        loadDeferred = $q.defer();
        var loadSDK = settings.loadSDK;
        delete settings["loadSDK"];
        $window.fbAsyncInit = function() {
            $timeout(function() {
                if (!settings.appId) {
                    throw "Missing appId setting.";
                }
                FB.init(settings);
                flags.ready = true;
                angular.forEach({
                    "auth.login": "login",
                    "auth.logout": "logout",
                    "auth.prompt": "prompt",
                    "auth.sessionChange": "sessionChange",
                    "auth.statusChange": "statusChange",
                    "auth.authResponseChange": "authResponseChange",
                    "xfbml.render": "xfbmlRender",
                    "edge.create": "like",
                    "edge.remove": "unlike",
                    "comment.create": "comment",
                    "comment.remove": "uncomment"
                }, function(mapped, name) {
                    FB.Event.subscribe(name, function(response) {
                        $timeout(function() {
                            $rootScope.$broadcast("Facebook:" + mapped, response);
                        });
                    });
                });
                $rootScope.$broadcast("Facebook:load");
                loadDeferred.resolve(FB);
            });
        };
        (function addFBRoot() {
            var fbroot = document.getElementById("fb-root");
            if (!fbroot) {
                fbroot = document.createElement("div");
                fbroot.id = "fb-root";
                document.body.insertBefore(fbroot, document.body.childNodes[0]);
            }
            return fbroot;
        })();
        if (loadSDK) {
            (function injectScript() {
                var src = "//connect.facebook.net/" + settings.locale + "/sdk.js", script = document.createElement("script");
                script.id = "facebook-jssdk";
                script.async = true;
                if ([ "file", "file:" ].indexOf($window.location.protocol) !== -1) {
                    src = "https:" + src;
                }
                script.src = src;
                script.onload = function() {
                    flags.sdk = true;
                };
                document.getElementsByTagName("head")[0].appendChild(script);
            })();
        }
    } ]);
})(window, angular);
"use strict";

angular.module("ui.alias", []).config([ "$compileProvider", "uiAliasConfig", function($compileProvider, uiAliasConfig) {
    uiAliasConfig = uiAliasConfig || {};
    angular.forEach(uiAliasConfig, function(config, alias) {
        if (angular.isString(config)) {
            config = {
                replace: true,
                template: config
            };
        }
        $compileProvider.directive(alias, function() {
            return config;
        });
    });
} ]);

"use strict";

angular.module("ui.event", []).directive("uiEvent", [ "$parse", function($parse) {
    return function($scope, elm, attrs) {
        var events = $scope.$eval(attrs.uiEvent);
        angular.forEach(events, function(uiEvent, eventName) {
            var fn = $parse(uiEvent);
            elm.bind(eventName, function(evt) {
                var params = Array.prototype.slice.call(arguments);
                params = params.splice(1);
                fn($scope, {
                    $event: evt,
                    $params: params
                });
                if (!$scope.$$phase) {
                    $scope.$apply();
                }
            });
        });
    };
} ]);

"use strict";

angular.module("ui.format", []).filter("format", function() {
    return function(value, replace) {
        var target = value;
        if (angular.isString(target) && replace !== undefined) {
            if (!angular.isArray(replace) && !angular.isObject(replace)) {
                replace = [ replace ];
            }
            if (angular.isArray(replace)) {
                var rlen = replace.length;
                var rfx = function(str, i) {
                    i = parseInt(i, 10);
                    return i >= 0 && i < rlen ? replace[i] : str;
                };
                target = target.replace(/\$([0-9]+)/g, rfx);
            } else {
                angular.forEach(replace, function(value, key) {
                    target = target.split(":" + key).join(value);
                });
            }
        }
        return target;
    };
});

"use strict";

angular.module("ui.highlight", []).filter("highlight", function() {
    return function(text, search, caseSensitive) {
        if (search || angular.isNumber(search)) {
            text = text.toString();
            search = search.toString();
            if (caseSensitive) {
                return text.split(search).join('<span class="ui-match">' + search + "</span>");
            } else {
                return text.replace(new RegExp(search, "gi"), '<span class="ui-match">$&</span>');
            }
        } else {
            return text;
        }
    };
});

"use strict";

angular.module("ui.include", []).directive("uiInclude", [ "$http", "$templateCache", "$anchorScroll", "$compile", function($http, $templateCache, $anchorScroll, $compile) {
    return {
        restrict: "ECA",
        terminal: true,
        compile: function(element, attr) {
            var srcExp = attr.uiInclude || attr.src, fragExp = attr.fragment || "", onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
            return function(scope, element) {
                var changeCounter = 0, childScope;
                var clearContent = function() {
                    if (childScope) {
                        childScope.$destroy();
                        childScope = null;
                    }
                    element.html("");
                };
                function ngIncludeWatchAction() {
                    var thisChangeId = ++changeCounter;
                    var src = scope.$eval(srcExp);
                    var fragment = scope.$eval(fragExp);
                    if (src) {
                        $http.get(src, {
                            cache: $templateCache
                        }).success(function(response) {
                            if (thisChangeId !== changeCounter) {
                                return;
                            }
                            if (childScope) {
                                childScope.$destroy();
                            }
                            childScope = scope.$new();
                            var contents;
                            if (fragment) {
                                contents = angular.element("<div/>").html(response).find(fragment);
                            } else {
                                contents = angular.element("<div/>").html(response).contents();
                            }
                            element.html(contents);
                            $compile(contents)(childScope);
                            if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                            childScope.$emit("$includeContentLoaded");
                            scope.$eval(onloadExp);
                        }).error(function() {
                            if (thisChangeId === changeCounter) {
                                clearContent();
                            }
                        });
                    } else {
                        clearContent();
                    }
                }
                scope.$watch(fragExp, ngIncludeWatchAction);
                scope.$watch(srcExp, ngIncludeWatchAction);
            };
        }
    };
} ]);

"use strict";

angular.module("ui.indeterminate", []).directive("uiIndeterminate", [ function() {
    return {
        compile: function(tElm, tAttrs) {
            if (!tAttrs.type || tAttrs.type.toLowerCase() !== "checkbox") {
                return angular.noop;
            }
            return function($scope, elm, attrs) {
                $scope.$watch(attrs.uiIndeterminate, function(newVal) {
                    elm[0].indeterminate = !!newVal;
                });
            };
        }
    };
} ]);

"use strict";

angular.module("ui.inflector", []).filter("inflector", function() {
    function ucwords(text) {
        return text.replace(/^([a-z])|\s+([a-z])/g, function($1) {
            return $1.toUpperCase();
        });
    }
    function breakup(text, separator) {
        return text.replace(/[A-Z]/g, function(match) {
            return separator + match;
        });
    }
    var inflectors = {
        humanize: function(value) {
            return ucwords(breakup(value, " ").split("_").join(" "));
        },
        underscore: function(value) {
            return value.substr(0, 1).toLowerCase() + breakup(value.substr(1), "_").toLowerCase().split(" ").join("_");
        },
        variable: function(value) {
            value = value.substr(0, 1).toLowerCase() + ucwords(value.split("_").join(" ")).substr(1).split(" ").join("");
            return value;
        }
    };
    return function(text, inflector) {
        if (inflector !== false && angular.isString(text)) {
            inflector = inflector || "humanize";
            return inflectors[inflector](text);
        } else {
            return text;
        }
    };
});

"use strict";

angular.module("ui.jq", []).value("uiJqConfig", {}).directive("uiJq", [ "uiJqConfig", "$timeout", function uiJqInjectingFunction(uiJqConfig, $timeout) {
    return {
        restrict: "A",
        compile: function uiJqCompilingFunction(tElm, tAttrs) {
            if (!angular.isFunction(tElm[tAttrs.uiJq])) {
                throw new Error('ui-jq: The "' + tAttrs.uiJq + '" function does not exist');
            }
            var options = uiJqConfig && uiJqConfig[tAttrs.uiJq];
            return function uiJqLinkingFunction(scope, elm, attrs) {
                var linkOptions = [];
                if (attrs.uiOptions) {
                    linkOptions = scope.$eval("[" + attrs.uiOptions + "]");
                    if (angular.isObject(options) && angular.isObject(linkOptions[0])) {
                        linkOptions[0] = angular.extend({}, options, linkOptions[0]);
                    }
                } else if (options) {
                    linkOptions = [ options ];
                }
                if (attrs.ngModel && elm.is("select,input,textarea")) {
                    elm.bind("change", function() {
                        elm.trigger("input");
                    });
                }
                function callPlugin() {
                    $timeout(function() {
                        elm[attrs.uiJq].apply(elm, linkOptions);
                    }, 0, false);
                }
                if (attrs.uiRefresh) {
                    scope.$watch(attrs.uiRefresh, function() {
                        callPlugin();
                    });
                }
                callPlugin();
            };
        }
    };
} ]);

"use strict";

angular.module("ui.keypress", []).factory("keypressHelper", [ "$parse", function keypress($parse) {
    var keysByCode = {
        8: "backspace",
        9: "tab",
        13: "enter",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "delete"
    };
    var capitaliseFirstLetter = function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return function(mode, scope, elm, attrs) {
        var params, combinations = [];
        params = scope.$eval(attrs["ui" + capitaliseFirstLetter(mode)]);
        angular.forEach(params, function(v, k) {
            var combination, expression;
            expression = $parse(v);
            angular.forEach(k.split(" "), function(variation) {
                combination = {
                    expression: expression,
                    keys: {}
                };
                angular.forEach(variation.split("-"), function(value) {
                    combination.keys[value] = true;
                });
                combinations.push(combination);
            });
        });
        elm.bind(mode, function(event) {
            var metaPressed = !!(event.metaKey && !event.ctrlKey);
            var altPressed = !!event.altKey;
            var ctrlPressed = !!event.ctrlKey;
            var shiftPressed = !!event.shiftKey;
            var keyCode = event.keyCode;
            if (mode === "keypress" && !shiftPressed && keyCode >= 97 && keyCode <= 122) {
                keyCode = keyCode - 32;
            }
            angular.forEach(combinations, function(combination) {
                var mainKeyPressed = combination.keys[keysByCode[keyCode]] || combination.keys[keyCode.toString()];
                var metaRequired = !!combination.keys.meta;
                var altRequired = !!combination.keys.alt;
                var ctrlRequired = !!combination.keys.ctrl;
                var shiftRequired = !!combination.keys.shift;
                if (mainKeyPressed && metaRequired === metaPressed && altRequired === altPressed && ctrlRequired === ctrlPressed && shiftRequired === shiftPressed) {
                    scope.$apply(function() {
                        combination.expression(scope, {
                            $event: event
                        });
                    });
                }
            });
        });
    };
} ]);

angular.module("ui.keypress").directive("uiKeydown", [ "keypressHelper", function(keypressHelper) {
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keydown", scope, elm, attrs);
        }
    };
} ]);

angular.module("ui.keypress").directive("uiKeypress", [ "keypressHelper", function(keypressHelper) {
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keypress", scope, elm, attrs);
        }
    };
} ]);

angular.module("ui.keypress").directive("uiKeyup", [ "keypressHelper", function(keypressHelper) {
    return {
        link: function(scope, elm, attrs) {
            keypressHelper("keyup", scope, elm, attrs);
        }
    };
} ]);

"use strict";

angular.module("ui.mask", []).value("uiMaskConfig", {
    maskDefinitions: {
        "9": /\d/,
        A: /[a-zA-Z]/,
        "*": /[a-zA-Z0-9]/
    }
}).directive("uiMask", [ "uiMaskConfig", function(maskConfig) {
    return {
        priority: 100,
        require: "ngModel",
        restrict: "A",
        compile: function uiMaskCompilingFunction() {
            var options = maskConfig;
            return function uiMaskLinkingFunction(scope, iElement, iAttrs, controller) {
                var maskProcessed = false, eventsBound = false, maskCaretMap, maskPatterns, maskPlaceholder, maskComponents, minRequiredLength, value, valueMasked, isValid, originalPlaceholder = iAttrs.placeholder, originalMaxlength = iAttrs.maxlength, oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength;
                function initialize(maskAttr) {
                    if (!angular.isDefined(maskAttr)) {
                        return uninitialize();
                    }
                    processRawMask(maskAttr);
                    if (!maskProcessed) {
                        return uninitialize();
                    }
                    initializeElement();
                    bindEventListeners();
                    return true;
                }
                function initPlaceholder(placeholderAttr) {
                    if (!angular.isDefined(placeholderAttr)) {
                        return;
                    }
                    maskPlaceholder = placeholderAttr;
                    if (maskProcessed) {
                        eventHandler();
                    }
                }
                function formatter(fromModelValue) {
                    if (!maskProcessed) {
                        return fromModelValue;
                    }
                    value = unmaskValue(fromModelValue || "");
                    isValid = validateValue(value);
                    controller.$setValidity("mask", isValid);
                    return isValid && value.length ? maskValue(value) : undefined;
                }
                function parser(fromViewValue) {
                    if (!maskProcessed) {
                        return fromViewValue;
                    }
                    value = unmaskValue(fromViewValue || "");
                    isValid = validateValue(value);
                    controller.$viewValue = value.length ? maskValue(value) : "";
                    controller.$setValidity("mask", isValid);
                    if (value === "" && controller.$error.required !== undefined) {
                        controller.$setValidity("required", false);
                    }
                    return isValid ? value : undefined;
                }
                var linkOptions = {};
                if (iAttrs.uiOptions) {
                    linkOptions = scope.$eval("[" + iAttrs.uiOptions + "]");
                    if (angular.isObject(linkOptions[0])) {
                        linkOptions = function(original, current) {
                            for (var i in original) {
                                if (Object.prototype.hasOwnProperty.call(original, i)) {
                                    if (!current[i]) {
                                        current[i] = angular.copy(original[i]);
                                    } else {
                                        angular.extend(current[i], original[i]);
                                    }
                                }
                            }
                            return current;
                        }(options, linkOptions[0]);
                    }
                } else {
                    linkOptions = options;
                }
                iAttrs.$observe("uiMask", initialize);
                iAttrs.$observe("placeholder", initPlaceholder);
                controller.$formatters.push(formatter);
                controller.$parsers.push(parser);
                function uninitialize() {
                    maskProcessed = false;
                    unbindEventListeners();
                    if (angular.isDefined(originalPlaceholder)) {
                        iElement.attr("placeholder", originalPlaceholder);
                    } else {
                        iElement.removeAttr("placeholder");
                    }
                    if (angular.isDefined(originalMaxlength)) {
                        iElement.attr("maxlength", originalMaxlength);
                    } else {
                        iElement.removeAttr("maxlength");
                    }
                    iElement.val(controller.$modelValue);
                    controller.$viewValue = controller.$modelValue;
                    return false;
                }
                function initializeElement() {
                    value = oldValueUnmasked = unmaskValue(controller.$modelValue || "");
                    valueMasked = oldValue = maskValue(value);
                    isValid = validateValue(value);
                    var viewValue = isValid && value.length ? valueMasked : "";
                    if (iAttrs.maxlength) {
                        iElement.attr("maxlength", maskCaretMap[maskCaretMap.length - 1] * 2);
                    }
                    iElement.attr("placeholder", maskPlaceholder);
                    iElement.val(viewValue);
                    controller.$viewValue = viewValue;
                }
                function bindEventListeners() {
                    if (eventsBound) {
                        return;
                    }
                    iElement.bind("blur", blurHandler);
                    iElement.bind("mousedown mouseup", mouseDownUpHandler);
                    iElement.bind("input keyup click focus", eventHandler);
                    eventsBound = true;
                }
                function unbindEventListeners() {
                    if (!eventsBound) {
                        return;
                    }
                    iElement.unbind("blur", blurHandler);
                    iElement.unbind("mousedown", mouseDownUpHandler);
                    iElement.unbind("mouseup", mouseDownUpHandler);
                    iElement.unbind("input", eventHandler);
                    iElement.unbind("keyup", eventHandler);
                    iElement.unbind("click", eventHandler);
                    iElement.unbind("focus", eventHandler);
                    eventsBound = false;
                }
                function validateValue(value) {
                    return value.length ? value.length >= minRequiredLength : true;
                }
                function unmaskValue(value) {
                    var valueUnmasked = "", maskPatternsCopy = maskPatterns.slice();
                    value = value.toString();
                    angular.forEach(maskComponents, function(component) {
                        value = value.replace(component, "");
                    });
                    angular.forEach(value.split(""), function(chr) {
                        if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                            valueUnmasked += chr;
                            maskPatternsCopy.shift();
                        }
                    });
                    return valueUnmasked;
                }
                function maskValue(unmaskedValue) {
                    var valueMasked = "", maskCaretMapCopy = maskCaretMap.slice();
                    angular.forEach(maskPlaceholder.split(""), function(chr, i) {
                        if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                            valueMasked += unmaskedValue.charAt(0) || "_";
                            unmaskedValue = unmaskedValue.substr(1);
                            maskCaretMapCopy.shift();
                        } else {
                            valueMasked += chr;
                        }
                    });
                    return valueMasked;
                }
                function getPlaceholderChar(i) {
                    var placeholder = iAttrs.placeholder;
                    if (typeof placeholder !== "undefined" && placeholder[i]) {
                        return placeholder[i];
                    } else {
                        return "_";
                    }
                }
                function getMaskComponents() {
                    return maskPlaceholder.replace(/[_]+/g, "_").replace(/([^_]+)([a-zA-Z0-9])([^_])/g, "$1$2_$3").split("_");
                }
                function processRawMask(mask) {
                    var characterCount = 0;
                    maskCaretMap = [];
                    maskPatterns = [];
                    maskPlaceholder = "";
                    if (typeof mask === "string") {
                        minRequiredLength = 0;
                        var isOptional = false, splitMask = mask.split("");
                        angular.forEach(splitMask, function(chr, i) {
                            if (linkOptions.maskDefinitions[chr]) {
                                maskCaretMap.push(characterCount);
                                maskPlaceholder += getPlaceholderChar(i);
                                maskPatterns.push(linkOptions.maskDefinitions[chr]);
                                characterCount++;
                                if (!isOptional) {
                                    minRequiredLength++;
                                }
                            } else if (chr === "?") {
                                isOptional = true;
                            } else {
                                maskPlaceholder += chr;
                                characterCount++;
                            }
                        });
                    }
                    maskCaretMap.push(maskCaretMap.slice().pop() + 1);
                    maskComponents = getMaskComponents();
                    maskProcessed = maskCaretMap.length > 1 ? true : false;
                }
                function blurHandler() {
                    oldCaretPosition = 0;
                    oldSelectionLength = 0;
                    if (!isValid || value.length === 0) {
                        valueMasked = "";
                        iElement.val("");
                        scope.$apply(function() {
                            controller.$setViewValue("");
                        });
                    }
                }
                function mouseDownUpHandler(e) {
                    if (e.type === "mousedown") {
                        iElement.bind("mouseout", mouseoutHandler);
                    } else {
                        iElement.unbind("mouseout", mouseoutHandler);
                    }
                }
                iElement.bind("mousedown mouseup", mouseDownUpHandler);
                function mouseoutHandler() {
                    oldSelectionLength = getSelectionLength(this);
                    iElement.unbind("mouseout", mouseoutHandler);
                }
                function eventHandler(e) {
                    e = e || {};
                    var eventWhich = e.which, eventType = e.type;
                    if (eventWhich === 16 || eventWhich === 91) {
                        return;
                    }
                    var val = iElement.val(), valOld = oldValue, valMasked, valUnmasked = unmaskValue(val), valUnmaskedOld = oldValueUnmasked, valAltered = false, caretPos = getCaretPosition(this) || 0, caretPosOld = oldCaretPosition || 0, caretPosDelta = caretPos - caretPosOld, caretPosMin = maskCaretMap[0], caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(), selectionLenOld = oldSelectionLength || 0, isSelected = getSelectionLength(this) > 0, wasSelected = selectionLenOld > 0, isAddition = val.length > valOld.length || selectionLenOld && val.length > valOld.length - selectionLenOld, isDeletion = val.length < valOld.length || selectionLenOld && val.length === valOld.length - selectionLenOld, isSelection = eventWhich >= 37 && eventWhich <= 40 && e.shiftKey, isKeyLeftArrow = eventWhich === 37, isKeyBackspace = eventWhich === 8 || eventType !== "keyup" && isDeletion && caretPosDelta === -1, isKeyDelete = eventWhich === 46 || eventType !== "keyup" && isDeletion && caretPosDelta === 0 && !wasSelected, caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === "click") && caretPos > caretPosMin;
                    oldSelectionLength = getSelectionLength(this);
                    if (isSelection || isSelected && (eventType === "click" || eventType === "keyup")) {
                        return;
                    }
                    if (eventType === "input" && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
                        while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                            caretPos--;
                        }
                        while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                            caretPos++;
                        }
                        var charIndex = maskCaretMap.indexOf(caretPos);
                        valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
                        valAltered = true;
                    }
                    valMasked = maskValue(valUnmasked);
                    oldValue = valMasked;
                    oldValueUnmasked = valUnmasked;
                    iElement.val(valMasked);
                    if (valAltered) {
                        scope.$apply(function() {
                            controller.$setViewValue(valUnmasked);
                        });
                    }
                    if (isAddition && caretPos <= caretPosMin) {
                        caretPos = caretPosMin + 1;
                    }
                    if (caretBumpBack) {
                        caretPos--;
                    }
                    caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;
                    while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
                        caretPos += caretBumpBack ? -1 : 1;
                    }
                    if (caretBumpBack && caretPos < caretPosMax || isAddition && !isValidCaretPosition(caretPosOld)) {
                        caretPos++;
                    }
                    oldCaretPosition = caretPos;
                    setCaretPosition(this, caretPos);
                }
                function isValidCaretPosition(pos) {
                    return maskCaretMap.indexOf(pos) > -1;
                }
                function getCaretPosition(input) {
                    if (!input) return 0;
                    if (input.selectionStart !== undefined) {
                        return input.selectionStart;
                    } else if (document.selection) {
                        input.focus();
                        var selection = document.selection.createRange();
                        selection.moveStart("character", -input.value.length);
                        return selection.text.length;
                    }
                    return 0;
                }
                function setCaretPosition(input, pos) {
                    if (!input) return 0;
                    if (input.offsetWidth === 0 || input.offsetHeight === 0) {
                        return;
                    }
                    if (input.setSelectionRange) {
                        input.focus();
                        input.setSelectionRange(pos, pos);
                    } else if (input.createTextRange) {
                        var range = input.createTextRange();
                        range.collapse(true);
                        range.moveEnd("character", pos);
                        range.moveStart("character", pos);
                        range.select();
                    }
                }
                function getSelectionLength(input) {
                    if (!input) return 0;
                    if (input.selectionStart !== undefined) {
                        return input.selectionEnd - input.selectionStart;
                    }
                    if (document.selection) {
                        return document.selection.createRange().text.length;
                    }
                    return 0;
                }
                if (!Array.prototype.indexOf) {
                    Array.prototype.indexOf = function(searchElement) {
                        if (this === null) {
                            throw new TypeError();
                        }
                        var t = Object(this);
                        var len = t.length >>> 0;
                        if (len === 0) {
                            return -1;
                        }
                        var n = 0;
                        if (arguments.length > 1) {
                            n = Number(arguments[1]);
                            if (n !== n) {
                                n = 0;
                            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                                n = (n > 0 || -1) * Math.floor(Math.abs(n));
                            }
                        }
                        if (n >= len) {
                            return -1;
                        }
                        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
                        for (;k < len; k++) {
                            if (k in t && t[k] === searchElement) {
                                return k;
                            }
                        }
                        return -1;
                    };
                }
            };
        }
    };
} ]);

"use strict";

angular.module("ui.reset", []).value("uiResetConfig", null).directive("uiReset", [ "uiResetConfig", function(uiResetConfig) {
    var resetValue = null;
    if (uiResetConfig !== undefined) {
        resetValue = uiResetConfig;
    }
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            var aElement;
            aElement = angular.element('<a class="ui-reset" />');
            elm.wrap('<span class="ui-resetwrap" />').after(aElement);
            aElement.bind("click", function(e) {
                e.preventDefault();
                scope.$apply(function() {
                    if (attrs.uiReset) {
                        ctrl.$setViewValue(scope.$eval(attrs.uiReset));
                    } else {
                        ctrl.$setViewValue(resetValue);
                    }
                    ctrl.$render();
                });
            });
        }
    };
} ]);

"use strict";

angular.module("ui.route", []).directive("uiRoute", [ "$location", "$parse", function($location, $parse) {
    return {
        restrict: "AC",
        scope: true,
        compile: function(tElement, tAttrs) {
            var useProperty;
            if (tAttrs.uiRoute) {
                useProperty = "uiRoute";
            } else if (tAttrs.ngHref) {
                useProperty = "ngHref";
            } else if (tAttrs.href) {
                useProperty = "href";
            } else {
                throw new Error("uiRoute missing a route or href property on " + tElement[0]);
            }
            return function($scope, elm, attrs) {
                var modelSetter = $parse(attrs.ngModel || attrs.routeModel || "$uiRoute").assign;
                var watcher = angular.noop;
                function staticWatcher(newVal) {
                    var hash = newVal.indexOf("#");
                    if (hash > -1) {
                        newVal = newVal.substr(hash + 1);
                    }
                    watcher = function watchHref() {
                        modelSetter($scope, $location.path().indexOf(newVal) > -1);
                    };
                    watcher();
                }
                function regexWatcher(newVal) {
                    var hash = newVal.indexOf("#");
                    if (hash > -1) {
                        newVal = newVal.substr(hash + 1);
                    }
                    watcher = function watchRegex() {
                        var regexp = new RegExp("^" + newVal + "$", [ "i" ]);
                        modelSetter($scope, regexp.test($location.path()));
                    };
                    watcher();
                }
                switch (useProperty) {
                  case "uiRoute":
                    if (attrs.uiRoute) {
                        regexWatcher(attrs.uiRoute);
                    } else {
                        attrs.$observe("uiRoute", regexWatcher);
                    }
                    break;

                  case "ngHref":
                    if (attrs.ngHref) {
                        staticWatcher(attrs.ngHref);
                    } else {
                        attrs.$observe("ngHref", staticWatcher);
                    }
                    break;

                  case "href":
                    staticWatcher(attrs.href);
                }
                $scope.$on("$routeChangeSuccess", function() {
                    watcher();
                });
                $scope.$on("$stateChangeSuccess", function() {
                    watcher();
                });
            };
        }
    };
} ]);

"use strict";

angular.module("ui.scroll.jqlite", [ "ui.scroll" ]).service("jqLiteExtras", [ "$log", "$window", function(console, window) {
    return {
        registerFor: function(element) {
            var convertToPx, css, getMeasurements, getStyle, getWidthHeight, isWindow, scrollTo;
            css = angular.element.prototype.css;
            element.prototype.css = function(name, value) {
                var elem, self;
                self = this;
                elem = self[0];
                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {
                    return css.call(self, name, value);
                }
            };
            isWindow = function(obj) {
                return obj && obj.document && obj.location && obj.alert && obj.setInterval;
            };
            scrollTo = function(self, direction, value) {
                var elem, method, preserve, prop, _ref;
                elem = self[0];
                _ref = {
                    top: [ "scrollTop", "pageYOffset", "scrollLeft" ],
                    left: [ "scrollLeft", "pageXOffset", "scrollTop" ]
                }[direction], method = _ref[0], prop = _ref[1], preserve = _ref[2];
                if (isWindow(elem)) {
                    if (angular.isDefined(value)) {
                        return elem.scrollTo(self[preserve].call(self), value);
                    } else {
                        if (prop in elem) {
                            return elem[prop];
                        } else {
                            return elem.document.documentElement[method];
                        }
                    }
                } else {
                    if (angular.isDefined(value)) {
                        return elem[method] = value;
                    } else {
                        return elem[method];
                    }
                }
            };
            if (window.getComputedStyle) {
                getStyle = function(elem) {
                    return window.getComputedStyle(elem, null);
                };
                convertToPx = function(elem, value) {
                    return parseFloat(value);
                };
            } else {
                getStyle = function(elem) {
                    return elem.currentStyle;
                };
                convertToPx = function(elem, value) {
                    var core_pnum, left, result, rnumnonpx, rs, rsLeft, style;
                    core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
                    rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i");
                    if (!rnumnonpx.test(value)) {
                        return parseFloat(value);
                    } else {
                        style = elem.style;
                        left = style.left;
                        rs = elem.runtimeStyle;
                        rsLeft = rs && rs.left;
                        if (rs) {
                            rs.left = style.left;
                        }
                        style.left = value;
                        result = style.pixelLeft;
                        style.left = left;
                        if (rsLeft) {
                            rs.left = rsLeft;
                        }
                        return result;
                    }
                };
            }
            getMeasurements = function(elem, measure) {
                var base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB, _ref;
                if (isWindow(elem)) {
                    base = document.documentElement[{
                        height: "clientHeight",
                        width: "clientWidth"
                    }[measure]];
                    return {
                        base: base,
                        padding: 0,
                        border: 0,
                        margin: 0
                    };
                }
                _ref = {
                    width: [ elem.offsetWidth, "Left", "Right" ],
                    height: [ elem.offsetHeight, "Top", "Bottom" ]
                }[measure], base = _ref[0], dirA = _ref[1], dirB = _ref[2];
                computedStyle = getStyle(elem);
                paddingA = convertToPx(elem, computedStyle["padding" + dirA]) || 0;
                paddingB = convertToPx(elem, computedStyle["padding" + dirB]) || 0;
                borderA = convertToPx(elem, computedStyle["border" + dirA + "Width"]) || 0;
                borderB = convertToPx(elem, computedStyle["border" + dirB + "Width"]) || 0;
                computedMarginA = computedStyle["margin" + dirA];
                computedMarginB = computedStyle["margin" + dirB];
                marginA = convertToPx(elem, computedMarginA) || 0;
                marginB = convertToPx(elem, computedMarginB) || 0;
                return {
                    base: base,
                    padding: paddingA + paddingB,
                    border: borderA + borderB,
                    margin: marginA + marginB
                };
            };
            getWidthHeight = function(elem, direction, measure) {
                var computedStyle, measurements, result;
                measurements = getMeasurements(elem, direction);
                if (measurements.base > 0) {
                    return {
                        base: measurements.base - measurements.padding - measurements.border,
                        outer: measurements.base,
                        outerfull: measurements.base + measurements.margin
                    }[measure];
                } else {
                    computedStyle = getStyle(elem);
                    result = computedStyle[direction];
                    if (result < 0 || result === null) {
                        result = elem.style[direction] || 0;
                    }
                    result = parseFloat(result) || 0;
                    return {
                        base: result - measurements.padding - measurements.border,
                        outer: result,
                        outerfull: result + measurements.padding + measurements.border + measurements.margin
                    }[measure];
                }
            };
            return angular.forEach({
                before: function(newElem) {
                    var children, elem, i, parent, self, _i, _ref;
                    self = this;
                    elem = self[0];
                    parent = self.parent();
                    children = parent.contents();
                    if (children[0] === elem) {
                        return parent.prepend(newElem);
                    } else {
                        for (i = _i = 1, _ref = children.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
                            if (children[i] === elem) {
                                angular.element(children[i - 1]).after(newElem);
                                return;
                            }
                        }
                        throw new Error("invalid DOM structure " + elem.outerHTML);
                    }
                },
                height: function(value) {
                    var self;
                    self = this;
                    if (angular.isDefined(value)) {
                        if (angular.isNumber(value)) {
                            value = value + "px";
                        }
                        return css.call(self, "height", value);
                    } else {
                        return getWidthHeight(this[0], "height", "base");
                    }
                },
                outerHeight: function(option) {
                    return getWidthHeight(this[0], "height", option ? "outerfull" : "outer");
                },
                offset: function(value) {
                    var box, doc, docElem, elem, self, win;
                    self = this;
                    if (arguments.length) {
                        if (value === void 0) {
                            return self;
                        } else {
                            return value;
                        }
                    }
                    box = {
                        top: 0,
                        left: 0
                    };
                    elem = self[0];
                    doc = elem && elem.ownerDocument;
                    if (!doc) {
                        return;
                    }
                    docElem = doc.documentElement;
                    if (elem.getBoundingClientRect) {
                        box = elem.getBoundingClientRect();
                    }
                    win = doc.defaultView || doc.parentWindow;
                    return {
                        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                    };
                },
                scrollTop: function(value) {
                    return scrollTo(this, "top", value);
                },
                scrollLeft: function(value) {
                    return scrollTo(this, "left", value);
                }
            }, function(value, key) {
                if (!element.prototype[key]) {
                    return element.prototype[key] = value;
                }
            });
        }
    };
} ]).run([ "$log", "$window", "jqLiteExtras", function(console, window, jqLiteExtras) {
    if (!window.jQuery) {
        return jqLiteExtras.registerFor(angular.element);
    }
} ]);

"use strict";

angular.module("ui.scroll", []).directive("ngScrollViewport", [ "$log", function() {
    return {
        controller: [ "$scope", "$element", function(scope, element) {
            return element;
        } ]
    };
} ]).directive("ngScroll", [ "$log", "$injector", "$rootScope", "$timeout", function(console, $injector, $rootScope, $timeout) {
    return {
        require: [ "?^ngScrollViewport" ],
        transclude: "element",
        priority: 1e3,
        terminal: true,
        compile: function(element, attr, linker) {
            return function($scope, $element, $attr, controllers) {
                var adapter, adjustBuffer, adjustRowHeight, bof, bottomVisiblePos, buffer, bufferPadding, bufferSize, clipBottom, clipTop, datasource, datasourceName, enqueueFetch, eof, eventListener, fetch, finalize, first, insert, isDatasource, isLoading, itemName, loading, match, next, pending, reload, removeFromBuffer, resizeHandler, scrollHandler, scrollHeight, shouldLoadBottom, shouldLoadTop, tempScope, topVisiblePos, viewport;
                match = $attr.ngScroll.match(/^\s*(\w+)\s+in\s+(\w+)\s*$/);
                if (!match) {
                    throw new Error('Expected ngScroll in form of "item_ in _datasource_" but got "' + $attr.ngScroll + '"');
                }
                itemName = match[1];
                datasourceName = match[2];
                isDatasource = function(datasource) {
                    return angular.isObject(datasource) && datasource.get && angular.isFunction(datasource.get);
                };
                datasource = $scope[datasourceName];
                if (!isDatasource(datasource)) {
                    datasource = $injector.get(datasourceName);
                    if (!isDatasource(datasource)) {
                        throw new Error(datasourceName + " is not a valid datasource");
                    }
                }
                bufferSize = Math.max(3, +$attr.bufferSize || 10);
                bufferPadding = function() {
                    return viewport.height() * Math.max(.1, +$attr.padding || .1);
                };
                scrollHeight = function(elem) {
                    return elem[0].scrollHeight || elem[0].document.documentElement.scrollHeight;
                };
                adapter = null;
                linker(tempScope = $scope.$new(), function(template) {
                    var bottomPadding, createPadding, padding, repeaterType, topPadding, viewport;
                    repeaterType = template[0].localName;
                    if (repeaterType === "dl") {
                        throw new Error("ng-scroll directive does not support <" + template[0].localName + "> as a repeating tag: " + template[0].outerHTML);
                    }
                    if (repeaterType !== "li" && repeaterType !== "tr") {
                        repeaterType = "div";
                    }
                    viewport = controllers[0] || angular.element(window);
                    viewport.css({
                        "overflow-y": "auto",
                        display: "block"
                    });
                    padding = function(repeaterType) {
                        var div, result, table;
                        switch (repeaterType) {
                          case "tr":
                            table = angular.element("<table><tr><td><div></div></td></tr></table>");
                            div = table.find("div");
                            result = table.find("tr");
                            result.paddingHeight = function() {
                                return div.height.apply(div, arguments);
                            };
                            return result;

                          default:
                            result = angular.element("<" + repeaterType + "></" + repeaterType + ">");
                            result.paddingHeight = result.height;
                            return result;
                        }
                    };
                    createPadding = function(padding, element, direction) {
                        element[{
                            top: "before",
                            bottom: "after"
                        }[direction]](padding);
                        return {
                            paddingHeight: function() {
                                return padding.paddingHeight.apply(padding, arguments);
                            },
                            insert: function(element) {
                                return padding[{
                                    top: "after",
                                    bottom: "before"
                                }[direction]](element);
                            }
                        };
                    };
                    topPadding = createPadding(padding(repeaterType), element, "top");
                    bottomPadding = createPadding(padding(repeaterType), element, "bottom");
                    tempScope.$destroy();
                    return adapter = {
                        viewport: viewport,
                        topPadding: topPadding.paddingHeight,
                        bottomPadding: bottomPadding.paddingHeight,
                        append: bottomPadding.insert,
                        prepend: topPadding.insert,
                        bottomDataPos: function() {
                            return scrollHeight(viewport) - bottomPadding.paddingHeight();
                        },
                        topDataPos: function() {
                            return topPadding.paddingHeight();
                        }
                    };
                });
                viewport = adapter.viewport;
                first = 1;
                next = 1;
                buffer = [];
                pending = [];
                eof = false;
                bof = false;
                loading = datasource.loading || function() {};
                isLoading = false;
                removeFromBuffer = function(start, stop) {
                    var i, _i;
                    for (i = _i = start; start <= stop ? _i < stop : _i > stop; i = start <= stop ? ++_i : --_i) {
                        buffer[i].scope.$destroy();
                        buffer[i].element.remove();
                    }
                    return buffer.splice(start, stop - start);
                };
                reload = function() {
                    first = 1;
                    next = 1;
                    removeFromBuffer(0, buffer.length);
                    adapter.topPadding(0);
                    adapter.bottomPadding(0);
                    pending = [];
                    eof = false;
                    bof = false;
                    return adjustBuffer(false);
                };
                bottomVisiblePos = function() {
                    return viewport.scrollTop() + viewport.height();
                };
                topVisiblePos = function() {
                    return viewport.scrollTop();
                };
                shouldLoadBottom = function() {
                    return !eof && adapter.bottomDataPos() < bottomVisiblePos() + bufferPadding();
                };
                clipBottom = function() {
                    var bottomHeight, i, itemHeight, overage, _i, _ref;
                    bottomHeight = 0;
                    overage = 0;
                    for (i = _i = _ref = buffer.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                        itemHeight = buffer[i].element.outerHeight(true);
                        if (adapter.bottomDataPos() - bottomHeight - itemHeight > bottomVisiblePos() + bufferPadding()) {
                            bottomHeight += itemHeight;
                            overage++;
                            eof = false;
                        } else {
                            break;
                        }
                    }
                    if (overage > 0) {
                        adapter.bottomPadding(adapter.bottomPadding() + bottomHeight);
                        removeFromBuffer(buffer.length - overage, buffer.length);
                        next -= overage;
                        return console.log("clipped off bottom " + overage + " bottom padding " + adapter.bottomPadding());
                    }
                };
                shouldLoadTop = function() {
                    return !bof && adapter.topDataPos() > topVisiblePos() - bufferPadding();
                };
                clipTop = function() {
                    var item, itemHeight, overage, topHeight, _i, _len;
                    topHeight = 0;
                    overage = 0;
                    for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                        item = buffer[_i];
                        itemHeight = item.element.outerHeight(true);
                        if (adapter.topDataPos() + topHeight + itemHeight < topVisiblePos() - bufferPadding()) {
                            topHeight += itemHeight;
                            overage++;
                            bof = false;
                        } else {
                            break;
                        }
                    }
                    if (overage > 0) {
                        adapter.topPadding(adapter.topPadding() + topHeight);
                        removeFromBuffer(0, overage);
                        first += overage;
                        return console.log("clipped off top " + overage + " top padding " + adapter.topPadding());
                    }
                };
                enqueueFetch = function(direction, scrolling) {
                    if (!isLoading) {
                        isLoading = true;
                        loading(true);
                    }
                    if (pending.push(direction) === 1) {
                        return fetch(scrolling);
                    }
                };
                insert = function(index, item) {
                    var itemScope, toBeAppended, wrapper;
                    itemScope = $scope.$new();
                    itemScope[itemName] = item;
                    toBeAppended = index > first;
                    itemScope.$index = index;
                    if (toBeAppended) {
                        itemScope.$index--;
                    }
                    wrapper = {
                        scope: itemScope
                    };
                    linker(itemScope, function(clone) {
                        wrapper.element = clone;
                        if (toBeAppended) {
                            if (index === next) {
                                adapter.append(clone);
                                return buffer.push(wrapper);
                            } else {
                                buffer[index - first].element.after(clone);
                                return buffer.splice(index - first + 1, 0, wrapper);
                            }
                        } else {
                            adapter.prepend(clone);
                            return buffer.unshift(wrapper);
                        }
                    });
                    return {
                        appended: toBeAppended,
                        wrapper: wrapper
                    };
                };
                adjustRowHeight = function(appended, wrapper) {
                    var newHeight;
                    if (appended) {
                        return adapter.bottomPadding(Math.max(0, adapter.bottomPadding() - wrapper.element.outerHeight(true)));
                    } else {
                        newHeight = adapter.topPadding() - wrapper.element.outerHeight(true);
                        if (newHeight >= 0) {
                            return adapter.topPadding(newHeight);
                        } else {
                            return viewport.scrollTop(viewport.scrollTop() + wrapper.element.outerHeight(true));
                        }
                    }
                };
                adjustBuffer = function(scrolling, newItems, finalize) {
                    var doAdjustment;
                    doAdjustment = function() {
                        console.log("top {actual=" + adapter.topDataPos() + " visible from=" + topVisiblePos() + " bottom {visible through=" + bottomVisiblePos() + " actual=" + adapter.bottomDataPos() + "}");
                        if (shouldLoadBottom()) {
                            enqueueFetch(true, scrolling);
                        } else {
                            if (shouldLoadTop()) {
                                enqueueFetch(false, scrolling);
                            }
                        }
                        if (finalize) {
                            return finalize();
                        }
                    };
                    if (newItems) {
                        return $timeout(function() {
                            var row, _i, _len;
                            for (_i = 0, _len = newItems.length; _i < _len; _i++) {
                                row = newItems[_i];
                                adjustRowHeight(row.appended, row.wrapper);
                            }
                            return doAdjustment();
                        });
                    } else {
                        return doAdjustment();
                    }
                };
                finalize = function(scrolling, newItems) {
                    return adjustBuffer(scrolling, newItems, function() {
                        pending.shift();
                        if (pending.length === 0) {
                            isLoading = false;
                            return loading(false);
                        } else {
                            return fetch(scrolling);
                        }
                    });
                };
                fetch = function(scrolling) {
                    var direction;
                    direction = pending[0];
                    if (direction) {
                        if (buffer.length && !shouldLoadBottom()) {
                            return finalize(scrolling);
                        } else {
                            return datasource.get(next, bufferSize, function(result) {
                                var item, newItems, _i, _len;
                                newItems = [];
                                if (result.length === 0) {
                                    eof = true;
                                    adapter.bottomPadding(0);
                                    console.log("appended: requested " + bufferSize + " records starting from " + next + " recieved: eof");
                                } else {
                                    clipTop();
                                    for (_i = 0, _len = result.length; _i < _len; _i++) {
                                        item = result[_i];
                                        newItems.push(insert(++next, item));
                                    }
                                    console.log("appended: requested " + bufferSize + " received " + result.length + " buffer size " + buffer.length + " first " + first + " next " + next);
                                }
                                return finalize(scrolling, newItems);
                            });
                        }
                    } else {
                        if (buffer.length && !shouldLoadTop()) {
                            return finalize(scrolling);
                        } else {
                            return datasource.get(first - bufferSize, bufferSize, function(result) {
                                var i, newItems, _i, _ref;
                                newItems = [];
                                if (result.length === 0) {
                                    bof = true;
                                    adapter.topPadding(0);
                                    console.log("prepended: requested " + bufferSize + " records starting from " + (first - bufferSize) + " recieved: bof");
                                } else {
                                    clipBottom();
                                    for (i = _i = _ref = result.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                                        newItems.unshift(insert(--first, result[i]));
                                    }
                                    console.log("prepended: requested " + bufferSize + " received " + result.length + " buffer size " + buffer.length + " first " + first + " next " + next);
                                }
                                return finalize(scrolling, newItems);
                            });
                        }
                    }
                };
                resizeHandler = function() {
                    if (!$rootScope.$$phase && !isLoading) {
                        adjustBuffer(false);
                        return $scope.$apply();
                    }
                };
                viewport.bind("resize", resizeHandler);
                scrollHandler = function() {
                    if (!$rootScope.$$phase && !isLoading) {
                        adjustBuffer(true);
                        return $scope.$apply();
                    }
                };
                viewport.bind("scroll", scrollHandler);
                $scope.$watch(datasource.revision, function() {
                    return reload();
                });
                if (datasource.scope) {
                    eventListener = datasource.scope.$new();
                } else {
                    eventListener = $scope.$new();
                }
                $scope.$on("$destroy", function() {
                    eventListener.$destroy();
                    viewport.unbind("resize", resizeHandler);
                    return viewport.unbind("scroll", scrollHandler);
                });
                eventListener.$on("update.items", function(event, locator, newItem) {
                    var wrapper, _fn, _i, _len, _ref;
                    if (angular.isFunction(locator)) {
                        _fn = function(wrapper) {
                            return locator(wrapper.scope);
                        };
                        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                            wrapper = buffer[_i];
                            _fn(wrapper);
                        }
                    } else {
                        if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                            buffer[locator - first - 1].scope[itemName] = newItem;
                        }
                    }
                    return null;
                });
                eventListener.$on("delete.items", function(event, locator) {
                    var i, item, temp, wrapper, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
                    if (angular.isFunction(locator)) {
                        temp = [];
                        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                            item = buffer[_i];
                            temp.unshift(item);
                        }
                        _fn = function(wrapper) {
                            if (locator(wrapper.scope)) {
                                removeFromBuffer(temp.length - 1 - i, temp.length - i);
                                return next--;
                            }
                        };
                        for (i = _j = 0, _len1 = temp.length; _j < _len1; i = ++_j) {
                            wrapper = temp[i];
                            _fn(wrapper);
                        }
                    } else {
                        if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                            removeFromBuffer(locator - first - 1, locator - first);
                            next--;
                        }
                    }
                    for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) {
                        item = buffer[i];
                        item.scope.$index = first + i;
                    }
                    return adjustBuffer(false);
                });
                return eventListener.$on("insert.item", function(event, locator, item) {
                    var i, inserted, temp, wrapper, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
                    inserted = [];
                    if (angular.isFunction(locator)) {
                        temp = [];
                        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                            item = buffer[_i];
                            temp.unshift(item);
                        }
                        _fn = function(wrapper) {
                            var j, newItems, _k, _len2, _results;
                            if (newItems = locator(wrapper.scope)) {
                                insert = function(index, newItem) {
                                    insert(index, newItem);
                                    return next++;
                                };
                                if (angular.isArray(newItems)) {
                                    _results = [];
                                    for (j = _k = 0, _len2 = newItems.length; _k < _len2; j = ++_k) {
                                        item = newItems[j];
                                        _results.push(inserted.push(insert(i + j, item)));
                                    }
                                    return _results;
                                } else {
                                    return inserted.push(insert(i, newItems));
                                }
                            }
                        };
                        for (i = _j = 0, _len1 = temp.length; _j < _len1; i = ++_j) {
                            wrapper = temp[i];
                            _fn(wrapper);
                        }
                    } else {
                        if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                            inserted.push(insert(locator, item));
                            next++;
                        }
                    }
                    for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) {
                        item = buffer[i];
                        item.scope.$index = first + i;
                    }
                    return adjustBuffer(false, inserted);
                });
            };
        }
    };
} ]);

"use strict";

angular.module("ui.scrollfix", []).directive("uiScrollfix", [ "$window", function($window) {
    return {
        require: "^?uiScrollfixTarget",
        link: function(scope, elm, attrs, uiScrollfixTarget) {
            var top = elm[0].offsetTop, $target = uiScrollfixTarget && uiScrollfixTarget.$element || angular.element($window);
            if (!attrs.uiScrollfix) {
                attrs.uiScrollfix = top;
            } else if (typeof attrs.uiScrollfix === "string") {
                if (attrs.uiScrollfix.charAt(0) === "-") {
                    attrs.uiScrollfix = top - parseFloat(attrs.uiScrollfix.substr(1));
                } else if (attrs.uiScrollfix.charAt(0) === "+") {
                    attrs.uiScrollfix = top + parseFloat(attrs.uiScrollfix.substr(1));
                }
            }
            function onScroll() {
                var offset;
                if (angular.isDefined($window.pageYOffset)) {
                    offset = $window.pageYOffset;
                } else {
                    var iebody = document.compatMode && document.compatMode !== "BackCompat" ? document.documentElement : document.body;
                    offset = iebody.scrollTop;
                }
                if (!elm.hasClass("ui-scrollfix") && offset > attrs.uiScrollfix) {
                    elm.addClass("ui-scrollfix");
                } else if (elm.hasClass("ui-scrollfix") && offset < attrs.uiScrollfix) {
                    elm.removeClass("ui-scrollfix");
                }
            }
            $target.on("scroll", onScroll);
            scope.$on("$destroy", function() {
                $target.off("scroll", onScroll);
            });
        }
    };
} ]).directive("uiScrollfixTarget", [ function() {
    return {
        controller: [ "$element", function($element) {
            this.$element = $element;
        } ]
    };
} ]);

"use strict";

angular.module("ui.showhide", []).directive("uiShow", [ function() {
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiShow, function(newVal) {
            if (newVal) {
                elm.addClass("ui-show");
            } else {
                elm.removeClass("ui-show");
            }
        });
    };
} ]).directive("uiHide", [ function() {
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiHide, function(newVal) {
            if (newVal) {
                elm.addClass("ui-hide");
            } else {
                elm.removeClass("ui-hide");
            }
        });
    };
} ]).directive("uiToggle", [ function() {
    return function(scope, elm, attrs) {
        scope.$watch(attrs.uiToggle, function(newVal) {
            if (newVal) {
                elm.removeClass("ui-hide").addClass("ui-show");
            } else {
                elm.removeClass("ui-show").addClass("ui-hide");
            }
        });
    };
} ]);

"use strict";

angular.module("ui.unique", []).filter("unique", [ "$parse", function($parse) {
    return function(items, filterOn) {
        if (filterOn === false) {
            return items;
        }
        if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {
            var newItems = [], get = angular.isString(filterOn) ? $parse(filterOn) : function(item) {
                return item;
            };
            var extractValueToCompare = function(item) {
                return angular.isObject(item) ? get(item) : item;
            };
            angular.forEach(items, function(item) {
                var isDuplicate = false;
                for (var i = 0; i < newItems.length; i++) {
                    if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate) {
                    newItems.push(item);
                }
            });
            items = newItems;
        }
        return items;
    };
} ]);

"use strict";

angular.module("ui.validate", []).directive("uiValidate", function() {
    return {
        restrict: "A",
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            var validateFn, validators = {}, validateExpr = scope.$eval(attrs.uiValidate);
            if (!validateExpr) {
                return;
            }
            if (angular.isString(validateExpr)) {
                validateExpr = {
                    validator: validateExpr
                };
            }
            angular.forEach(validateExpr, function(exprssn, key) {
                validateFn = function(valueToValidate) {
                    var expression = scope.$eval(exprssn, {
                        $value: valueToValidate
                    });
                    if (angular.isObject(expression) && angular.isFunction(expression.then)) {
                        expression.then(function() {
                            ctrl.$setValidity(key, true);
                        }, function() {
                            ctrl.$setValidity(key, false);
                        });
                        return valueToValidate;
                    } else if (expression) {
                        ctrl.$setValidity(key, true);
                        return valueToValidate;
                    } else {
                        ctrl.$setValidity(key, false);
                        return valueToValidate;
                    }
                };
                validators[key] = validateFn;
                ctrl.$formatters.push(validateFn);
                ctrl.$parsers.push(validateFn);
            });
            function apply_watch(watch) {
                if (angular.isString(watch)) {
                    scope.$watch(watch, function() {
                        angular.forEach(validators, function(validatorFn) {
                            validatorFn(ctrl.$modelValue);
                        });
                    });
                    return;
                }
                if (angular.isArray(watch)) {
                    angular.forEach(watch, function(expression) {
                        scope.$watch(expression, function() {
                            angular.forEach(validators, function(validatorFn) {
                                validatorFn(ctrl.$modelValue);
                            });
                        });
                    });
                    return;
                }
                if (angular.isObject(watch)) {
                    angular.forEach(watch, function(expression, validatorKey) {
                        if (angular.isString(expression)) {
                            scope.$watch(expression, function() {
                                validators[validatorKey](ctrl.$modelValue);
                            });
                        }
                        if (angular.isArray(expression)) {
                            angular.forEach(expression, function(intExpression) {
                                scope.$watch(intExpression, function() {
                                    validators[validatorKey](ctrl.$modelValue);
                                });
                            });
                        }
                    });
                }
            }
            if (attrs.uiValidateWatch) {
                apply_watch(scope.$eval(attrs.uiValidateWatch));
            }
        }
    };
});

angular.module("ui.utils", [ "ui.event", "ui.format", "ui.highlight", "ui.include", "ui.indeterminate", "ui.inflector", "ui.jq", "ui.keypress", "ui.mask", "ui.reset", "ui.route", "ui.scrollfix", "ui.scroll", "ui.scroll.jqlite", "ui.showhide", "ui.unique", "ui.validate" ]);
var Sprint;

(function() {
    var D = function(a, b) {
        for (var c = Sprint(b), d = Object.keys(a), e = d.length, f = 0; f < e; f++) for (var g = d[f], h = a[g], k = h.length, l = 0; l < k; l++) c.on(g, h[l]);
    }, w = function() {
        var a = "animation-iteration-count column-count flex-grow flex-shrink font-weight line-height opacity order orphans widows z-index".split(" ");
        return function(b, c) {
            if (v(b, a)) return c;
            var d = "string" == typeof c ? c : c.toString();
            c && !/\D/.test(d) && (d += "px");
            return d;
        };
    }(), K = {
        afterbegin: function(a) {
            this.insertBefore(a, this.firstChild);
        },
        afterend: function(a) {
            var b = this.parentElement;
            b && b.insertBefore(a, this.nextSibling);
        },
        beforebegin: function(a) {
            var b = this.parentElement;
            b && b.insertBefore(a, this);
        },
        beforeend: function(a) {
            this.appendChild(a);
        }
    }, E = function(a, b) {
        if (!(1 < a.nodeType)) {
            var c = a.sprintEventListeners;
            c && D(c, b);
            for (var d = r("*", a), e = d.length, f, g = 0; g < e; g++) if (c = d[g].sprintEventListeners) f || (f = r("*", b)), 
            D(c, f[g]);
        }
    }, z = function(a, b, c, d, e) {
        var f = [], g = this;
        this.each(function() {
            for (var h = a ? this.parentElement : this; h && (!e || e != h); ) {
                if (!d || g.is(d, h)) if (f.push(h), c) break;
                if (b) break;
                h = h.parentElement;
            }
        });
        return Sprint(x(f));
    }, F = function(a, b) {
        return Object.keys(a.sprintEventListeners).filter(function(a) {
            return q(b).every(function(b) {
                return v(b, q(a));
            });
        });
    }, G = function(a, b, c) {
        if (null == c) {
            var d = a.get(0);
            if (!d || 1 < d.nodeType) return;
            a = b[0].toUpperCase() + b.substring(1);
            return d == document ? (d = m["offset" + a], a = window["inner" + a], d > a ? d : a) : d == window ? window["inner" + a] : d.getBoundingClientRect()[b];
        }
        var e = "function" == typeof c, f = e ? "" : w(b, c);
        return a.each(function(a) {
            this == document || this == window || 1 < this.nodeType || (e && (f = w(b, c.call(this, a, Sprint(this)[b]()))), 
            this.style[b] = f);
        });
    }, p = function(a, b) {
        var c = b.length, d = b;
        if (1 < c && -1 < a.indexOf("after")) for (var d = [], e = c; e--; ) d.push(b[e]);
        for (e = 0; e < c; e++) {
            var f = d[e];
            if ("string" == typeof f || "number" == typeof f) this.each(function() {
                this.insertAdjacentHTML(a, f);
            }); else if ("function" == typeof f) this.each(function(b) {
                b = f.call(this, b, this.innerHTML);
                p.call(Sprint(this), a, [ b ]);
            }); else {
                var g = f instanceof n, h = [], k = g ? f.get() : Array.isArray(f) ? A(f, !0, !0) : f.nodeType ? [ f ] : t(f), l = k.length;
                this.each(function(b) {
                    for (var c = document.createDocumentFragment(), d = 0; d < l; d++) {
                        var e = k[d], f;
                        b ? (f = e.cloneNode(!0), E(e, f)) : f = e;
                        c.appendChild(f);
                        h.push(f);
                    }
                    K[a].call(this, c);
                });
                g && (f.dom = h, f.length = h.length);
                if (!(e < c - 1)) return h;
            }
        }
    }, v = function(a, b) {
        for (var c = b.length; c--; ) if (b[c] === a) return !0;
        return !1;
    }, B = function(a, b, c) {
        if (null == b) return "add" == a ? this : this.removeAttr("class");
        var d, e, f;
        "string" == typeof b && (d = !0, e = b.trim().split(" "), f = e.length);
        return this.each(function(g, h) {
            if (!(1 < this.nodeType)) {
                if (!d) {
                    var k = b.call(h, g, h.className);
                    if (!k) return;
                    e = k.trim().split(" ");
                    f = e.length;
                }
                for (k = 0; k < f; k++) {
                    var l = e[k];
                    l && (null == c ? h.classList[a](l) : h.classList.toggle(l, c));
                }
            }
        });
    }, L = function() {
        for (var a = [ "mozMatchesSelector", "webkitMatchesSelector", "msMatchesSelector", "matches" ], b = a.length; b--; ) {
            var c = a[b];
            if (Element.prototype[c]) return c;
        }
    }(), x = function(a) {
        for (var b = [], c = 0, d = a.length, e = 0; e < d; e++) {
            for (var f = a[e], g = !1, h = 0; h < c; h++) if (f === b[h]) {
                g = !0;
                break;
            }
            g || (b[c++] = f);
        }
        return b;
    }, H = function() {
        var a = function(a, b, c) {
            return 2 > Object.keys(a.sprintEventListeners).filter(function(a) {
                return q(b)[0] === q(a)[0];
            }).map(function(b) {
                return a.sprintEventListeners[b];
            }).reduce(function(a, b) {
                return a.concat(b);
            }).filter(function(a) {
                return a === c;
            }).length ? !1 : !0;
        }, b = function(b, c, f) {
            return function(g) {
                f && f !== g || (b.removeEventListener(c, g), /\./.test(c) && !a(b, c, g) && b.removeEventListener(q(c)[0], g));
            };
        }, c = function(a, b) {
            return a.filter(function(a) {
                return b && b !== a;
            });
        };
        return function(a, e) {
            return function(f) {
                a.sprintEventListeners[f].forEach(b(a, f, e));
                a.sprintEventListeners[f] = c(a.sprintEventListeners[f], e);
            };
        };
    }(), M = function(a, b) {
        return function(c) {
            F(a, c).forEach(H(a, b));
        };
    }, m = document.documentElement, A = function(a, b, c) {
        for (var d = a.length, e = d; e--; ) if (!a[e] && 0 !== a[e] || b && a[e] instanceof n || c && ("string" == typeof a[e] || "number" == typeof a[e])) {
            for (var e = [], f = 0; f < d; f++) {
                var g = a[f];
                if (g || 0 === g) if (b && g instanceof n) for (var h = 0; h < g.length; h++) e.push(g.get(h)); else !c || "string" != typeof g && "number" != typeof g ? e.push(g) : e.push(document.createTextNode(g));
            }
            return e;
        }
        return a;
    }, I = function() {
        var a;
        return function(b, c, d) {
            if (!a) {
                var e = m.scrollTop;
                m.scrollTop = e + 1;
                var f = m.scrollTop;
                m.scrollTop = e;
                a = f > e ? m : document.body;
            }
            if (null == d) {
                b = b.get(0);
                if (!b) return;
                if (b == window || b == document) b = a;
                return b[c];
            }
            return b.each(function() {
                var b = this;
                if (b == window || b == document) b = a;
                b[c] = d;
            });
        };
    }(), y = function(a, b, c, d) {
        var e = [], f = b + "ElementSibling";
        a.each(function() {
            for (var b = this; (b = b[f]) && (!d || !a.is(d, b)); ) c && !a.is(c, b) || e.push(b);
        });
        return Sprint(x(e));
    }, J = function(a, b, c) {
        var d = b + "ElementSibling";
        return a.map(function() {
            var b = this[d];
            if (b && (!c || a.is(c, b))) return b;
        }, !1);
    }, r = function(a, b) {
        b = b || document;
        if (/^[\#.]?[\w-]+$/.test(a)) {
            var c = a[0];
            return "." == c ? t(b.getElementsByClassName(a.slice(1))) : "#" == c ? (c = b.getElementById(a.slice(1))) ? [ c ] : [] : "body" == a ? [ document.body ] : t(b.getElementsByTagName(a));
        }
        return t(b.querySelectorAll(a));
    }, q = function(a) {
        return A(a.split("."));
    }, t = function(a) {
        for (var b = [], c = a.length; c--; ) b[c] = a[c];
        return b;
    }, C = function() {
        var a = function(a, c) {
            var d = Sprint(a).clone(!0).get(0), e = d;
            if (d && !(1 < this.nodeType)) {
                for (;e.firstChild; ) e = e.firstChild;
                if ("inner" == c) {
                    for (;this.firstChild; ) e.appendChild(this.firstChild);
                    this.appendChild(d);
                } else {
                    var f = "all" == c ? this.get(0) : this, g = f.parentNode, h = f.nextSibling;
                    "all" == c ? this.each(function() {
                        e.appendChild(this);
                    }) : e.appendChild(f);
                    g.insertBefore(d, h);
                }
            }
        };
        return function(b, c) {
            "function" == typeof b ? this.each(function(a) {
                Sprint(this)["inner" == c ? "wrapInner" : "wrap"](b.call(this, a));
            }) : "all" == c ? a.call(this, b, c) : this.each(function() {
                a.call(this, b, c);
            });
            return this;
        };
    }(), u = {
        legend: {
            intro: "<fieldset>",
            outro: "</fieldset>"
        },
        area: {
            intro: "<map>",
            outro: "</map>"
        },
        param: {
            intro: "<object>",
            outro: "</object>"
        },
        thead: {
            intro: "<table>",
            outro: "</table>"
        },
        tr: {
            intro: "<table><tbody>",
            outro: "</tbody></table>"
        },
        col: {
            intro: "<table><tbody></tbody><colgroup>",
            outro: "</colgroup></table>"
        },
        td: {
            intro: "<table><tbody><tr>",
            outro: "</tr></tbody></table>"
        }
    };
    [ "tbody", "tfoot", "colgroup", "caption" ].forEach(function(a) {
        u[a] = u.thead;
    });
    u.th = u.td;
    var n = function(a, b) {
        if ("string" == typeof a) if ("<" == a[0]) {
            var c = document.createElement("div"), d = /[\w:-]+/.exec(a)[0], d = u[d], e = a.trim();
            d && (e = d.intro + e + d.outro);
            c.insertAdjacentHTML("afterbegin", e);
            e = c.lastChild;
            if (d) for (d = d.outro.match(/</g).length; d--; ) e = e.lastChild;
            c.textContent = "";
            this.dom = [ e ];
        } else this.dom = b && b instanceof n ? b.find(a).get() : r(a, b); else if (Array.isArray(a)) this.dom = A(a); else if (a instanceof NodeList || a instanceof HTMLCollection) this.dom = t(a); else {
            if (a instanceof n) return a;
            if ("function" == typeof a) return this.ready(a);
            this.dom = a ? [ a ] : [];
        }
        this.length = this.dom.length;
    };
    n.prototype = {
        add: function(a) {
            var b = this.get();
            a = Sprint(a);
            for (var c = a.get(), d = 0; d < a.length; d++) b.push(c[d]);
            return Sprint(x(b));
        },
        addClass: function(a) {
            return B.call(this, "add", a);
        },
        after: function() {
            p.call(this, "afterend", arguments);
            return this;
        },
        append: function() {
            p.call(this, "beforeend", arguments);
            return this;
        },
        appendTo: function(a) {
            return Sprint(p.call(Sprint(a), "beforeend", [ this ]));
        },
        attr: function(a, b) {
            var c = "function" == typeof b;
            if ("string" == typeof b || "number" == typeof b || c) return this.each(function(d) {
                1 < this.nodeType || this.setAttribute(a, c ? b.call(this, d, this.getAttribute(a)) : b);
            });
            if ("object" == typeof a) {
                var d = Object.keys(a), e = d.length;
                return this.each(function() {
                    if (!(1 < this.nodeType)) for (var b = 0; b < e; b++) {
                        var c = d[b];
                        this.setAttribute(c, a[c]);
                    }
                });
            }
            var f = this.get(0);
            if (f && !(1 < f.nodeType)) return f = f.getAttribute(a), null == f ? void 0 : f ? f : a;
        },
        before: function() {
            p.call(this, "beforebegin", arguments);
            return this;
        },
        children: function(a) {
            var b = [], c = this;
            this.each(function() {
                if (!(1 < this.nodeType)) for (var d = this.children, e = d.length, f = 0; f < e; f++) {
                    var g = d[f];
                    a && !c.is(a, g) || b.push(g);
                }
            });
            return Sprint(b);
        },
        clone: function(a) {
            return this.map(function() {
                if (this) {
                    var b = this.cloneNode(!0);
                    a && E(this, b);
                    return b;
                }
            }, !1);
        },
        closest: function(a, b) {
            return z.call(this, !1, !1, !0, a, b);
        },
        css: function(a, b) {
            var c = typeof b, d = "string" == c;
            if (d || "number" == c) {
                var e = d && /=/.test(b);
                if (e) var f = parseInt(b[0] + b.slice(2));
                return this.each(function() {
                    if (!(1 < this.nodeType)) {
                        if (e) var c = parseInt(getComputedStyle(this).getPropertyValue(a)) + f;
                        this.style[a] = w(a, e ? c : b);
                    }
                });
            }
            if ("function" == c) return this.each(function(c) {
                if (!(1 < this.nodeType)) {
                    var d = getComputedStyle(this).getPropertyValue(a);
                    this.style[a] = b.call(this, c, d);
                }
            });
            if ("string" == typeof a) return d = this.get(0), !d || 1 < d.nodeType ? void 0 : getComputedStyle(d).getPropertyValue(a);
            if (Array.isArray(a)) {
                d = this.get(0);
                if (!d || 1 < d.nodeType) return;
                for (var c = {}, d = getComputedStyle(d), g = a.length, h = 0; h < g; h++) {
                    var k = a[h];
                    c[k] = d.getPropertyValue(k);
                }
                return c;
            }
            var l = Object.keys(a), m = l.length;
            return this.each(function() {
                if (!(1 < this.nodeType)) for (var b = 0; b < m; b++) {
                    var c = l[b];
                    this.style[c] = w(c, a[c]);
                }
            });
        },
        detach: function() {
            return this.map(function() {
                var a = this.parentElement;
                if (a) return a.removeChild(this), this;
            }, !1);
        },
        each: function(a) {
            for (var b = this.dom, c = this.length, d = 0; d < c; d++) {
                var e = b[d];
                a.call(e, d, e);
            }
            return this;
        },
        empty: function() {
            return this.each(function() {
                this.innerHTML = "";
            });
        },
        eq: function(a) {
            return Sprint(this.get(a));
        },
        filter: function(a) {
            var b = "function" == typeof a, c = this;
            return this.map(function(d) {
                if (!(1 < this.nodeType || !b && !c.is(a, this) || b && !a.call(this, d, this))) return this;
            }, !1);
        },
        find: function(a) {
            if ("string" == typeof a) {
                var b = [];
                this.each(function() {
                    if (!(1 < this.nodeType)) for (var c = r(a, this), d = c.length, e = 0; e < d; e++) b.push(c[e]);
                });
                return Sprint(x(b));
            }
            for (var c = a.nodeType ? [ a ] : a.get(), d = c.length, e = [], f = 0, g = 0; g < this.length; g++) {
                var h = this.get(g);
                if (!(1 < h.nodeType)) for (var k = 0; k < d; k++) {
                    var l = c[k];
                    if (h.contains(l) && (e[f++] = l, !(f < d))) return Sprint(e);
                }
            }
            return Sprint(e);
        },
        first: function() {
            return this.eq(0);
        },
        get: function(a) {
            if (null == a) return this.dom;
            0 > a && (a += this.length);
            return this.dom[a];
        },
        has: function(a) {
            if ("string" == typeof a) return this.map(function() {
                if (!(1 < this.nodeType) && r(a, this)[0]) return this;
            }, !1);
            for (var b = [], c = this.length; c--; ) {
                var d = this.get(c);
                if (d.contains(a)) {
                    b.push(d);
                    break;
                }
            }
            return Sprint(b);
        },
        hasClass: function(a) {
            for (var b = this.length; b--; ) {
                var c = this.get(b);
                if (1 < c.nodeType) return;
                if (c.classList.contains(a)) return !0;
            }
            return !1;
        },
        height: function(a) {
            return G(this, "height", a);
        },
        html: function(a) {
            if (null == a) {
                var b = this.get(0);
                return b ? b.innerHTML : void 0;
            }
            return "function" == typeof a ? this.each(function(b) {
                b = a.call(this, b, this.innerHTML);
                Sprint(this).html(b);
            }) : this.each(function() {
                this.innerHTML = a;
            });
        },
        index: function(a) {
            if (this.length) {
                var b;
                a ? "string" == typeof a ? (b = this.get(0), a = Sprint(a)) : (b = a instanceof n ? a.get(0) : a, 
                a = this) : (b = this.get(0), a = this.first().parent().children());
                a = a.get();
                for (var c = a.length; c--; ) if (a[c] == b) return c;
                return -1;
            }
        },
        insertAfter: function(a) {
            Sprint(a).after(this);
            return this;
        },
        insertBefore: function(a) {
            Sprint(a).before(this);
            return this;
        },
        is: function(a, b) {
            var c = b ? [ b ] : this.get(), d = c.length;
            if ("string" == typeof a) {
                for (var e = 0; e < d; e++) {
                    var f = c[e];
                    if (!(1 < f.nodeType) && f[L](a)) return !0;
                }
                return !1;
            }
            if ("object" == typeof a) {
                for (var f = a instanceof n ? a.get() : a.length ? a : [ a ], g = f.length, e = 0; e < d; e++) for (var h = 0; h < g; h++) if (c[e] === f[h]) return !0;
                return !1;
            }
            if ("function" == typeof a) {
                for (e = 0; e < d; e++) if (a.call(this, e, this)) return !0;
                return !1;
            }
        },
        last: function() {
            return this.eq(-1);
        },
        map: function(a, b) {
            null == b && (b = !0);
            for (var c = this.get(), d = this.length, e = [], f = 0; f < d; f++) {
                var g = c[f], g = a.call(g, f, g);
                if (b && Array.isArray(g)) for (var h = g.length, k = 0; k < h; k++) e.push(g[k]); else e.push(g);
            }
            return Sprint(e);
        },
        next: function(a) {
            return J(this, "next", a);
        },
        nextAll: function(a) {
            return y(this, "next", a);
        },
        nextUntil: function(a, b) {
            return y(this, "next", b, a);
        },
        not: function(a) {
            var b = "function" == typeof a, c = this;
            return this.map(function(d) {
                if (b) {
                    if (a.call(this, d, this)) return;
                } else if (c.is(a, this)) return;
                return this;
            }, !1);
        },
        off: function(a, b) {
            if ("object" == typeof a) return Object.keys(a).forEach(function(b) {
                this.off(b, a[b]);
            }, this), this;
            a && (a = a.trim().split(" "));
            return this.each(function() {
                this.sprintEventListeners && (a ? a.forEach(M(this, b)) : Object.keys(this.sprintEventListeners).forEach(H(this)));
            });
        },
        offset: function(a) {
            if (!a) {
                var b = this.get(0);
                if (!b || 1 < b.nodeType) return;
                b = b.getBoundingClientRect();
                return {
                    top: b.top,
                    left: b.left
                };
            }
            if ("object" == typeof a) return this.each(function() {
                if (!(1 < this.nodeType)) {
                    var b = Sprint(this);
                    "static" == b.css("position") ? b.css("position", "relative") : b.css({
                        top: 0,
                        left: 0
                    });
                    var d = b.offset();
                    b.css({
                        top: a.top - d.top + "px",
                        left: a.left - d.left + "px"
                    });
                }
            });
            if ("function" == typeof a) return this.each(function(b) {
                var d = Sprint(this);
                b = a.call(this, b, d.offset());
                d.offset(b);
            });
        },
        offsetParent: function() {
            var a = [];
            this.each(function() {
                if (!(1 < this.nodeType)) {
                    for (var b = this; b != m; ) {
                        var b = b.parentNode, c = getComputedStyle(b).getPropertyValue("position");
                        if (!c) break;
                        if ("static" != c) {
                            a.push(b);
                            return;
                        }
                    }
                    a.push(m);
                }
            });
            return Sprint(a);
        },
        on: function(a, b) {
            if (b) {
                var c = a.trim().split(" ");
                return this.each(function() {
                    this.sprintEventListeners || (this.sprintEventListeners = {});
                    c.forEach(function(a) {
                        this.sprintEventListeners[a] || (this.sprintEventListeners[a] = []);
                        this.sprintEventListeners[a].push(b);
                        this.addEventListener(a, b);
                        /\./.test(a) && this.addEventListener(q(a)[0], b);
                    }, this);
                });
            }
            Object.keys(a).forEach(function(b) {
                this.on(b, a[b]);
            }, this);
            return this;
        },
        parent: function(a) {
            return z.call(this, !0, !0, !1, a);
        },
        parents: function(a) {
            return z.call(this, !0, !1, !1, a);
        },
        position: function() {
            var a = this.offset(), b = this.parent().offset();
            if (a) return {
                top: a.top - b.top,
                left: a.left - b.left
            };
        },
        prop: function(a, b) {
            if ("object" == typeof a) {
                var c = Object.keys(a), d = c.length;
                return this.each(function() {
                    for (var b = 0; b < d; b++) {
                        var e = c[b];
                        this[e] = a[e];
                    }
                });
            }
            if (null == b) {
                var e = this.get(0);
                return e ? e[a] : void 0;
            }
            var f = "function" == typeof b;
            return this.each(function(c) {
                this[a] = f ? b.call(this, c, this[a]) : b;
            });
        },
        prepend: function() {
            p.call(this, "afterbegin", arguments);
            return this;
        },
        prependTo: function(a) {
            return Sprint(p.call(Sprint(a), "afterbegin", [ this ]));
        },
        prev: function(a) {
            return J(this, "previous", a);
        },
        prevAll: function(a) {
            return y(this, "previous", a);
        },
        prevUntil: function(a, b) {
            return y(this, "previous", b, a);
        },
        ready: function(a) {
            this.dom = [ document ];
            this.length = 1;
            return this.on("DOMContentLoaded", a);
        },
        remove: function(a) {
            var b = this;
            return this.each(function() {
                var c = this.parentElement;
                c && (a && !b.is(a, this) || c.removeChild(this));
            });
        },
        removeAttr: function(a) {
            if (a) {
                var b = a.trim().split(" "), c = b.length;
                this.each(function() {
                    if (!(1 < this.nodeType)) for (var a = 0; a < c; a++) this.removeAttribute(b[a]);
                });
            }
            return this;
        },
        removeClass: function(a) {
            return B.call(this, "remove", a);
        },
        removeProp: function(a) {
            return this.each(function() {
                this[a] = void 0;
            });
        },
        replaceAll: function(a) {
            Sprint(a).replaceWith(this);
            return this;
        },
        replaceWith: function(a) {
            return "function" == typeof a ? this.each(function(b) {
                Sprint(this).replaceWith(a.call(this, b, this));
            }) : this.before(a).remove();
        },
        scrollLeft: function(a) {
            return I(this, "scrollLeft", a);
        },
        scrollTop: function(a) {
            return I(this, "scrollTop", a);
        },
        siblings: function(a) {
            var b = [], c = this;
            this.each(function(d, e) {
                Sprint(this).parent().children().each(function() {
                    this == e || a && !c.is(a, this) || b.push(this);
                });
            });
            return Sprint(b);
        },
        size: function() {
            return this.length;
        },
        slice: function(a, b) {
            var c = this.get(), d = [], e = 0 <= a ? a : a + this.length, f = this.length;
            for (0 > b ? f += b : 0 <= b && (f = b > this.length ? this.length : b); e < f; e++) d.push(c[e]);
            return Sprint(d);
        },
        text: function(a) {
            if (null == a) {
                var b = [];
                this.each(function() {
                    b.push(this.textContent);
                });
                return b.join("");
            }
            var c = "function" == typeof a;
            return this.each(function(b) {
                this.textContent = c ? a.call(this, b, this.textContent) : a;
            });
        },
        toggleClass: function(a, b) {
            return B.call(this, "toggle", a, b);
        },
        trigger: function(a) {
            if (!window.CustomEvent || "function" !== typeof window.CustomEvent) {
                var b = function(a, b) {
                    var e;
                    b = b || {
                        bubbles: !1,
                        cancelable: !1,
                        detail: void 0
                    };
                    e = document.createEvent("CustomEvent");
                    e.initCustomEvent(a, b.bubbles, b.cancelable, b.detail);
                    return e;
                };
                b.prototype = window.Event.prototype;
                window.CustomEvent = b;
            }
            return this.each(function() {
                F(this, a).forEach(function(a) {
                    this.dispatchEvent(new b(a, {
                        bubbles: !0,
                        cancelable: !0
                    }));
                }, this);
            });
        },
        unwrap: function() {
            this.parent().each(function() {
                this != document.body && this != m && Sprint(this).replaceWith(this.childNodes);
            });
            return this;
        },
        val: function(a) {
            if (null == a) {
                var b = this.get(0);
                if (!b) return;
                if (b.multiple) {
                    var c = [];
                    this.first().children(":checked").each(function() {
                        c.push(this.value);
                    });
                    return c;
                }
                return b.value;
            }
            if (Array.isArray(a)) {
                var d = this;
                return this.each(function() {
                    this.multiple ? d.children().each(function() {
                        this.selected = v(this.value, a);
                    }) : this.checked = v(this.value, a);
                });
            }
            return "function" == typeof a ? this.each(function(b) {
                Sprint(this).val(a.call(this, b, this.value));
            }) : this.each(function() {
                this.value = a;
            });
        },
        width: function(a) {
            return G(this, "width", a);
        },
        wrap: function(a) {
            return C.call(this, a);
        },
        wrapAll: function(a) {
            return C.call(this, a, "all");
        },
        wrapInner: function(a) {
            return C.call(this, a, "inner");
        }
    };
    Sprint = function(a, b) {
        return new n(a, b);
    };
    null == window.$ && (window.$ = Sprint);
})();
(function() {
    var h, aa = this;
    function n(a) {
        return void 0 !== a;
    }
    function ba() {}
    function ca(a) {
        a.ub = function() {
            return a.tf ? a.tf : a.tf = new a();
        };
    }
    function da(a) {
        var b = typeof a;
        if ("object" == b) if (a) {
            if (a instanceof Array) return "array";
            if (a instanceof Object) return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c) return "object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
        } else return "null"; else if ("function" == b && "undefined" == typeof a.call) return "object";
        return b;
    }
    function ea(a) {
        return "array" == da(a);
    }
    function fa(a) {
        var b = da(a);
        return "array" == b || "object" == b && "number" == typeof a.length;
    }
    function p(a) {
        return "string" == typeof a;
    }
    function ga(a) {
        return "number" == typeof a;
    }
    function ha(a) {
        return "function" == da(a);
    }
    function ia(a) {
        var b = typeof a;
        return "object" == b && null != a || "function" == b;
    }
    function ja(a, b, c) {
        return a.call.apply(a.bind, arguments);
    }
    function ka(a, b, c) {
        if (!a) throw Error();
        if (2 < arguments.length) {
            var d = Array.prototype.slice.call(arguments, 2);
            return function() {
                var c = Array.prototype.slice.call(arguments);
                Array.prototype.unshift.apply(c, d);
                return a.apply(b, c);
            };
        }
        return function() {
            return a.apply(b, arguments);
        };
    }
    function q(a, b, c) {
        q = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ja : ka;
        return q.apply(null, arguments);
    }
    var la = Date.now || function() {
        return +new Date();
    };
    function ma(a, b) {
        function c() {}
        c.prototype = b.prototype;
        a.Zg = b.prototype;
        a.prototype = new c();
        a.prototype.constructor = a;
        a.Vg = function(a, c, f) {
            for (var g = Array(arguments.length - 2), k = 2; k < arguments.length; k++) g[k - 2] = arguments[k];
            return b.prototype[c].apply(a, g);
        };
    }
    function r(a, b) {
        for (var c in a) b.call(void 0, a[c], c, a);
    }
    function na(a, b) {
        var c = {}, d;
        for (d in a) c[d] = b.call(void 0, a[d], d, a);
        return c;
    }
    function oa(a, b) {
        for (var c in a) if (!b.call(void 0, a[c], c, a)) return !1;
        return !0;
    }
    function pa(a) {
        var b = 0, c;
        for (c in a) b++;
        return b;
    }
    function qa(a) {
        for (var b in a) return b;
    }
    function ra(a) {
        var b = [], c = 0, d;
        for (d in a) b[c++] = a[d];
        return b;
    }
    function sa(a) {
        var b = [], c = 0, d;
        for (d in a) b[c++] = d;
        return b;
    }
    function ta(a, b) {
        for (var c in a) if (a[c] == b) return !0;
        return !1;
    }
    function ua(a, b, c) {
        for (var d in a) if (b.call(c, a[d], d, a)) return d;
    }
    function va(a, b) {
        var c = ua(a, b, void 0);
        return c && a[c];
    }
    function wa(a) {
        for (var b in a) return !1;
        return !0;
    }
    function xa(a) {
        var b = {}, c;
        for (c in a) b[c] = a[c];
        return b;
    }
    var ya = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    function za(a, b) {
        for (var c, d, e = 1; e < arguments.length; e++) {
            d = arguments[e];
            for (c in d) a[c] = d[c];
            for (var f = 0; f < ya.length; f++) c = ya[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
        }
    }
    function Aa(a) {
        a = String(a);
        if (/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) try {
            return eval("(" + a + ")");
        } catch (b) {}
        throw Error("Invalid JSON string: " + a);
    }
    function Ba() {
        this.Pd = void 0;
    }
    function Ca(a, b, c) {
        switch (typeof b) {
          case "string":
            Da(b, c);
            break;

          case "number":
            c.push(isFinite(b) && !isNaN(b) ? b : "null");
            break;

          case "boolean":
            c.push(b);
            break;

          case "undefined":
            c.push("null");
            break;

          case "object":
            if (null == b) {
                c.push("null");
                break;
            }
            if (ea(b)) {
                var d = b.length;
                c.push("[");
                for (var e = "", f = 0; f < d; f++) c.push(e), e = b[f], Ca(a, a.Pd ? a.Pd.call(b, String(f), e) : e, c), 
                e = ",";
                c.push("]");
                break;
            }
            c.push("{");
            d = "";
            for (f in b) Object.prototype.hasOwnProperty.call(b, f) && (e = b[f], "function" != typeof e && (c.push(d), 
            Da(f, c), c.push(":"), Ca(a, a.Pd ? a.Pd.call(b, f, e) : e, c), d = ","));
            c.push("}");
            break;

          case "function":
            break;

          default:
            throw Error("Unknown type: " + typeof b);
        }
    }
    var Ea = {
        '"': '\\"',
        "\\": "\\\\",
        "/": "\\/",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "": "\\u000b"
    }, Fa = /\uffff/.test("") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
    function Da(a, b) {
        b.push('"', a.replace(Fa, function(a) {
            if (a in Ea) return Ea[a];
            var b = a.charCodeAt(0), e = "\\u";
            16 > b ? e += "000" : 256 > b ? e += "00" : 4096 > b && (e += "0");
            return Ea[a] = e + b.toString(16);
        }), '"');
    }
    function Ga() {
        return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ la()).toString(36);
    }
    var Ha;
    a: {
        var Ia = aa.navigator;
        if (Ia) {
            var Ja = Ia.userAgent;
            if (Ja) {
                Ha = Ja;
                break a;
            }
        }
        Ha = "";
    }
    function Ka() {
        this.Wa = -1;
    }
    function La() {
        this.Wa = -1;
        this.Wa = 64;
        this.R = [];
        this.le = [];
        this.Tf = [];
        this.Id = [];
        this.Id[0] = 128;
        for (var a = 1; a < this.Wa; ++a) this.Id[a] = 0;
        this.be = this.$b = 0;
        this.reset();
    }
    ma(La, Ka);
    La.prototype.reset = function() {
        this.R[0] = 1732584193;
        this.R[1] = 4023233417;
        this.R[2] = 2562383102;
        this.R[3] = 271733878;
        this.R[4] = 3285377520;
        this.be = this.$b = 0;
    };
    function Ma(a, b, c) {
        c || (c = 0);
        var d = a.Tf;
        if (p(b)) for (var e = 0; 16 > e; e++) d[e] = b.charCodeAt(c) << 24 | b.charCodeAt(c + 1) << 16 | b.charCodeAt(c + 2) << 8 | b.charCodeAt(c + 3), 
        c += 4; else for (e = 0; 16 > e; e++) d[e] = b[c] << 24 | b[c + 1] << 16 | b[c + 2] << 8 | b[c + 3], 
        c += 4;
        for (e = 16; 80 > e; e++) {
            var f = d[e - 3] ^ d[e - 8] ^ d[e - 14] ^ d[e - 16];
            d[e] = (f << 1 | f >>> 31) & 4294967295;
        }
        b = a.R[0];
        c = a.R[1];
        for (var g = a.R[2], k = a.R[3], l = a.R[4], m, e = 0; 80 > e; e++) 40 > e ? 20 > e ? (f = k ^ c & (g ^ k), 
        m = 1518500249) : (f = c ^ g ^ k, m = 1859775393) : 60 > e ? (f = c & g | k & (c | g), 
        m = 2400959708) : (f = c ^ g ^ k, m = 3395469782), f = (b << 5 | b >>> 27) + f + l + m + d[e] & 4294967295, 
        l = k, k = g, g = (c << 30 | c >>> 2) & 4294967295, c = b, b = f;
        a.R[0] = a.R[0] + b & 4294967295;
        a.R[1] = a.R[1] + c & 4294967295;
        a.R[2] = a.R[2] + g & 4294967295;
        a.R[3] = a.R[3] + k & 4294967295;
        a.R[4] = a.R[4] + l & 4294967295;
    }
    La.prototype.update = function(a, b) {
        if (null != a) {
            n(b) || (b = a.length);
            for (var c = b - this.Wa, d = 0, e = this.le, f = this.$b; d < b; ) {
                if (0 == f) for (;d <= c; ) Ma(this, a, d), d += this.Wa;
                if (p(a)) for (;d < b; ) {
                    if (e[f] = a.charCodeAt(d), ++f, ++d, f == this.Wa) {
                        Ma(this, e);
                        f = 0;
                        break;
                    }
                } else for (;d < b; ) if (e[f] = a[d], ++f, ++d, f == this.Wa) {
                    Ma(this, e);
                    f = 0;
                    break;
                }
            }
            this.$b = f;
            this.be += b;
        }
    };
    var t = Array.prototype, Na = t.indexOf ? function(a, b, c) {
        return t.indexOf.call(a, b, c);
    } : function(a, b, c) {
        c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
        if (p(a)) return p(b) && 1 == b.length ? a.indexOf(b, c) : -1;
        for (;c < a.length; c++) if (c in a && a[c] === b) return c;
        return -1;
    }, Oa = t.forEach ? function(a, b, c) {
        t.forEach.call(a, b, c);
    } : function(a, b, c) {
        for (var d = a.length, e = p(a) ? a.split("") : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
    }, Pa = t.filter ? function(a, b, c) {
        return t.filter.call(a, b, c);
    } : function(a, b, c) {
        for (var d = a.length, e = [], f = 0, g = p(a) ? a.split("") : a, k = 0; k < d; k++) if (k in g) {
            var l = g[k];
            b.call(c, l, k, a) && (e[f++] = l);
        }
        return e;
    }, Qa = t.map ? function(a, b, c) {
        return t.map.call(a, b, c);
    } : function(a, b, c) {
        for (var d = a.length, e = Array(d), f = p(a) ? a.split("") : a, g = 0; g < d; g++) g in f && (e[g] = b.call(c, f[g], g, a));
        return e;
    }, Ra = t.reduce ? function(a, b, c, d) {
        for (var e = [], f = 1, g = arguments.length; f < g; f++) e.push(arguments[f]);
        d && (e[0] = q(b, d));
        return t.reduce.apply(a, e);
    } : function(a, b, c, d) {
        var e = c;
        Oa(a, function(c, g) {
            e = b.call(d, e, c, g, a);
        });
        return e;
    }, Sa = t.every ? function(a, b, c) {
        return t.every.call(a, b, c);
    } : function(a, b, c) {
        for (var d = a.length, e = p(a) ? a.split("") : a, f = 0; f < d; f++) if (f in e && !b.call(c, e[f], f, a)) return !1;
        return !0;
    };
    function Ta(a, b) {
        var c = Ua(a, b, void 0);
        return 0 > c ? null : p(a) ? a.charAt(c) : a[c];
    }
    function Ua(a, b, c) {
        for (var d = a.length, e = p(a) ? a.split("") : a, f = 0; f < d; f++) if (f in e && b.call(c, e[f], f, a)) return f;
        return -1;
    }
    function Va(a, b) {
        var c = Na(a, b);
        0 <= c && t.splice.call(a, c, 1);
    }
    function Wa(a, b, c) {
        return 2 >= arguments.length ? t.slice.call(a, b) : t.slice.call(a, b, c);
    }
    function Xa(a, b) {
        a.sort(b || Ya);
    }
    function Ya(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    var Za = -1 != Ha.indexOf("Opera") || -1 != Ha.indexOf("OPR"), $a = -1 != Ha.indexOf("Trident") || -1 != Ha.indexOf("MSIE"), ab = -1 != Ha.indexOf("Gecko") && -1 == Ha.toLowerCase().indexOf("webkit") && !(-1 != Ha.indexOf("Trident") || -1 != Ha.indexOf("MSIE")), bb = -1 != Ha.toLowerCase().indexOf("webkit");
    (function() {
        var a = "", b;
        if (Za && aa.opera) return a = aa.opera.version, ha(a) ? a() : a;
        ab ? b = /rv\:([^\);]+)(\)|;)/ : $a ? b = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/ : bb && (b = /WebKit\/(\S+)/);
        b && (a = (a = b.exec(Ha)) ? a[1] : "");
        return $a && (b = (b = aa.document) ? b.documentMode : void 0, b > parseFloat(a)) ? String(b) : a;
    })();
    var cb = null, db = null, eb = null;
    function fb(a, b) {
        if (!fa(a)) throw Error("encodeByteArray takes an array as a parameter");
        gb();
        for (var c = b ? db : cb, d = [], e = 0; e < a.length; e += 3) {
            var f = a[e], g = e + 1 < a.length, k = g ? a[e + 1] : 0, l = e + 2 < a.length, m = l ? a[e + 2] : 0, v = f >> 2, f = (f & 3) << 4 | k >> 4, k = (k & 15) << 2 | m >> 6, m = m & 63;
            l || (m = 64, g || (k = 64));
            d.push(c[v], c[f], c[k], c[m]);
        }
        return d.join("");
    }
    function gb() {
        if (!cb) {
            cb = {};
            db = {};
            eb = {};
            for (var a = 0; 65 > a; a++) cb[a] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a), 
            db[a] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a), 
            eb[db[a]] = a, 62 <= a && (eb["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a)] = a);
        }
    }
    function u(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function w(a, b) {
        if (Object.prototype.hasOwnProperty.call(a, b)) return a[b];
    }
    function hb(a, b) {
        for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && b(c, a[c]);
    }
    function ib(a) {
        var b = {};
        hb(a, function(a, d) {
            b[a] = d;
        });
        return b;
    }
    function jb(a) {
        var b = [];
        hb(a, function(a, d) {
            ea(d) ? Oa(d, function(d) {
                b.push(encodeURIComponent(a) + "=" + encodeURIComponent(d));
            }) : b.push(encodeURIComponent(a) + "=" + encodeURIComponent(d));
        });
        return b.length ? "&" + b.join("&") : "";
    }
    function kb(a) {
        var b = {};
        a = a.replace(/^\?/, "").split("&");
        Oa(a, function(a) {
            a && (a = a.split("="), b[a[0]] = a[1]);
        });
        return b;
    }
    function x(a, b, c, d) {
        var e;
        d < b ? e = "at least " + b : d > c && (e = 0 === c ? "none" : "no more than " + c);
        if (e) throw Error(a + " failed: Was called with " + d + (1 === d ? " argument." : " arguments.") + " Expects " + e + ".");
    }
    function z(a, b, c) {
        var d = "";
        switch (b) {
          case 1:
            d = c ? "first" : "First";
            break;

          case 2:
            d = c ? "second" : "Second";
            break;

          case 3:
            d = c ? "third" : "Third";
            break;

          case 4:
            d = c ? "fourth" : "Fourth";
            break;

          default:
            throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");
        }
        return a = a + " failed: " + (d + " argument ");
    }
    function A(a, b, c, d) {
        if ((!d || n(c)) && !ha(c)) throw Error(z(a, b, d) + "must be a valid function.");
    }
    function lb(a, b, c) {
        if (n(c) && (!ia(c) || null === c)) throw Error(z(a, b, !0) + "must be a valid context object.");
    }
    function mb(a) {
        return "undefined" !== typeof JSON && n(JSON.parse) ? JSON.parse(a) : Aa(a);
    }
    function B(a) {
        if ("undefined" !== typeof JSON && n(JSON.stringify)) a = JSON.stringify(a); else {
            var b = [];
            Ca(new Ba(), a, b);
            a = b.join("");
        }
        return a;
    }
    function nb() {
        this.Sd = C;
    }
    nb.prototype.j = function(a) {
        return this.Sd.oa(a);
    };
    nb.prototype.toString = function() {
        return this.Sd.toString();
    };
    function ob() {}
    ob.prototype.pf = function() {
        return null;
    };
    ob.prototype.xe = function() {
        return null;
    };
    var pb = new ob();
    function qb(a, b, c) {
        this.Qf = a;
        this.Ka = b;
        this.Hd = c;
    }
    qb.prototype.pf = function(a) {
        var b = this.Ka.D;
        if (rb(b, a)) return b.j().M(a);
        b = null != this.Hd ? new sb(this.Hd, !0, !1) : this.Ka.u();
        return this.Qf.Xa(a, b);
    };
    qb.prototype.xe = function(a, b, c) {
        var d = null != this.Hd ? this.Hd : tb(this.Ka);
        a = this.Qf.me(d, b, 1, c, a);
        return 0 === a.length ? null : a[0];
    };
    function ub() {
        this.tb = [];
    }
    function vb(a, b) {
        for (var c = null, d = 0; d < b.length; d++) {
            var e = b[d], f = e.Yb();
            null === c || f.Z(c.Yb()) || (a.tb.push(c), c = null);
            null === c && (c = new wb(f));
            c.add(e);
        }
        c && a.tb.push(c);
    }
    function xb(a, b, c) {
        vb(a, c);
        yb(a, function(a) {
            return a.Z(b);
        });
    }
    function zb(a, b, c) {
        vb(a, c);
        yb(a, function(a) {
            return a.contains(b) || b.contains(a);
        });
    }
    function yb(a, b) {
        for (var c = !0, d = 0; d < a.tb.length; d++) {
            var e = a.tb[d];
            if (e) if (e = e.Yb(), b(e)) {
                for (var e = a.tb[d], f = 0; f < e.sd.length; f++) {
                    var g = e.sd[f];
                    if (null !== g) {
                        e.sd[f] = null;
                        var k = g.Ub();
                        Ab && Bb("event: " + g.toString());
                        Cb(k);
                    }
                }
                a.tb[d] = null;
            } else c = !1;
        }
        c && (a.tb = []);
    }
    function wb(a) {
        this.qa = a;
        this.sd = [];
    }
    wb.prototype.add = function(a) {
        this.sd.push(a);
    };
    wb.prototype.Yb = function() {
        return this.qa;
    };
    function D(a, b, c, d) {
        this.type = a;
        this.Ja = b;
        this.Ya = c;
        this.Je = d;
        this.Nd = void 0;
    }
    function Db(a) {
        return new D(Eb, a);
    }
    var Eb = "value";
    function Fb(a, b, c, d) {
        this.te = b;
        this.Wd = c;
        this.Nd = d;
        this.rd = a;
    }
    Fb.prototype.Yb = function() {
        var a = this.Wd.lc();
        return "value" === this.rd ? a.path : a.parent().path;
    };
    Fb.prototype.ye = function() {
        return this.rd;
    };
    Fb.prototype.Ub = function() {
        return this.te.Ub(this);
    };
    Fb.prototype.toString = function() {
        return this.Yb().toString() + ":" + this.rd + ":" + B(this.Wd.lf());
    };
    function Gb(a, b, c) {
        this.te = a;
        this.error = b;
        this.path = c;
    }
    Gb.prototype.Yb = function() {
        return this.path;
    };
    Gb.prototype.ye = function() {
        return "cancel";
    };
    Gb.prototype.Ub = function() {
        return this.te.Ub(this);
    };
    Gb.prototype.toString = function() {
        return this.path.toString() + ":cancel";
    };
    function sb(a, b, c) {
        this.B = a;
        this.$ = b;
        this.Tb = c;
    }
    function Hb(a) {
        return a.$;
    }
    function rb(a, b) {
        return a.$ && !a.Tb || a.B.Ha(b);
    }
    sb.prototype.j = function() {
        return this.B;
    };
    function Ib(a) {
        this.dg = a;
        this.Ad = null;
    }
    Ib.prototype.get = function() {
        var a = this.dg.get(), b = xa(a);
        if (this.Ad) for (var c in this.Ad) b[c] -= this.Ad[c];
        this.Ad = a;
        return b;
    };
    function Jb(a, b) {
        this.Mf = {};
        this.Yd = new Ib(a);
        this.ca = b;
        var c = 1e4 + 2e4 * Math.random();
        setTimeout(q(this.Hf, this), Math.floor(c));
    }
    Jb.prototype.Hf = function() {
        var a = this.Yd.get(), b = {}, c = !1, d;
        for (d in a) 0 < a[d] && u(this.Mf, d) && (b[d] = a[d], c = !0);
        c && this.ca.Te(b);
        setTimeout(q(this.Hf, this), Math.floor(6e5 * Math.random()));
    };
    function Kb() {
        this.Dc = {};
    }
    function Lb(a, b, c) {
        n(c) || (c = 1);
        u(a.Dc, b) || (a.Dc[b] = 0);
        a.Dc[b] += c;
    }
    Kb.prototype.get = function() {
        return xa(this.Dc);
    };
    var Mb = {}, Nb = {};
    function Ob(a) {
        a = a.toString();
        Mb[a] || (Mb[a] = new Kb());
        return Mb[a];
    }
    function Pb(a, b) {
        var c = a.toString();
        Nb[c] || (Nb[c] = b());
        return Nb[c];
    }
    function E(a, b) {
        this.name = a;
        this.S = b;
    }
    function Qb(a, b) {
        return new E(a, b);
    }
    function Rb(a, b) {
        return Sb(a.name, b.name);
    }
    function Tb(a, b) {
        return Sb(a, b);
    }
    function Ub(a, b, c) {
        this.type = Vb;
        this.source = a;
        this.path = b;
        this.Ia = c;
    }
    Ub.prototype.Wc = function(a) {
        return this.path.e() ? new Ub(this.source, F, this.Ia.M(a)) : new Ub(this.source, G(this.path), this.Ia);
    };
    Ub.prototype.toString = function() {
        return "Operation(" + this.path + ": " + this.source.toString() + " overwrite: " + this.Ia.toString() + ")";
    };
    function Wb(a, b) {
        this.type = Xb;
        this.source = Yb;
        this.path = a;
        this.Ve = b;
    }
    Wb.prototype.Wc = function() {
        return this.path.e() ? this : new Wb(G(this.path), this.Ve);
    };
    Wb.prototype.toString = function() {
        return "Operation(" + this.path + ": " + this.source.toString() + " ack write revert=" + this.Ve + ")";
    };
    function Zb(a, b) {
        this.type = $b;
        this.source = a;
        this.path = b;
    }
    Zb.prototype.Wc = function() {
        return this.path.e() ? new Zb(this.source, F) : new Zb(this.source, G(this.path));
    };
    Zb.prototype.toString = function() {
        return "Operation(" + this.path + ": " + this.source.toString() + " listen_complete)";
    };
    function ac(a, b) {
        this.La = a;
        this.xa = b ? b : bc;
    }
    h = ac.prototype;
    h.Na = function(a, b) {
        return new ac(this.La, this.xa.Na(a, b, this.La).X(null, null, !1, null, null));
    };
    h.remove = function(a) {
        return new ac(this.La, this.xa.remove(a, this.La).X(null, null, !1, null, null));
    };
    h.get = function(a) {
        for (var b, c = this.xa; !c.e(); ) {
            b = this.La(a, c.key);
            if (0 === b) return c.value;
            0 > b ? c = c.left : 0 < b && (c = c.right);
        }
        return null;
    };
    function cc(a, b) {
        for (var c, d = a.xa, e = null; !d.e(); ) {
            c = a.La(b, d.key);
            if (0 === c) {
                if (d.left.e()) return e ? e.key : null;
                for (d = d.left; !d.right.e(); ) d = d.right;
                return d.key;
            }
            0 > c ? d = d.left : 0 < c && (e = d, d = d.right);
        }
        throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
    }
    h.e = function() {
        return this.xa.e();
    };
    h.count = function() {
        return this.xa.count();
    };
    h.Rc = function() {
        return this.xa.Rc();
    };
    h.ec = function() {
        return this.xa.ec();
    };
    h.ha = function(a) {
        return this.xa.ha(a);
    };
    h.Wb = function(a) {
        return new dc(this.xa, null, this.La, !1, a);
    };
    h.Xb = function(a, b) {
        return new dc(this.xa, a, this.La, !1, b);
    };
    h.Zb = function(a, b) {
        return new dc(this.xa, a, this.La, !0, b);
    };
    h.rf = function(a) {
        return new dc(this.xa, null, this.La, !0, a);
    };
    function dc(a, b, c, d, e) {
        this.Rd = e || null;
        this.Ee = d;
        this.Pa = [];
        for (e = 1; !a.e(); ) if (e = b ? c(a.key, b) : 1, d && (e *= -1), 0 > e) a = this.Ee ? a.left : a.right; else if (0 === e) {
            this.Pa.push(a);
            break;
        } else this.Pa.push(a), a = this.Ee ? a.right : a.left;
    }
    function H(a) {
        if (0 === a.Pa.length) return null;
        var b = a.Pa.pop(), c;
        c = a.Rd ? a.Rd(b.key, b.value) : {
            key: b.key,
            value: b.value
        };
        if (a.Ee) for (b = b.left; !b.e(); ) a.Pa.push(b), b = b.right; else for (b = b.right; !b.e(); ) a.Pa.push(b), 
        b = b.left;
        return c;
    }
    function ec(a) {
        if (0 === a.Pa.length) return null;
        var b;
        b = a.Pa;
        b = b[b.length - 1];
        return a.Rd ? a.Rd(b.key, b.value) : {
            key: b.key,
            value: b.value
        };
    }
    function fc(a, b, c, d, e) {
        this.key = a;
        this.value = b;
        this.color = null != c ? c : !0;
        this.left = null != d ? d : bc;
        this.right = null != e ? e : bc;
    }
    h = fc.prototype;
    h.X = function(a, b, c, d, e) {
        return new fc(null != a ? a : this.key, null != b ? b : this.value, null != c ? c : this.color, null != d ? d : this.left, null != e ? e : this.right);
    };
    h.count = function() {
        return this.left.count() + 1 + this.right.count();
    };
    h.e = function() {
        return !1;
    };
    h.ha = function(a) {
        return this.left.ha(a) || a(this.key, this.value) || this.right.ha(a);
    };
    function gc(a) {
        return a.left.e() ? a : gc(a.left);
    }
    h.Rc = function() {
        return gc(this).key;
    };
    h.ec = function() {
        return this.right.e() ? this.key : this.right.ec();
    };
    h.Na = function(a, b, c) {
        var d, e;
        e = this;
        d = c(a, e.key);
        e = 0 > d ? e.X(null, null, null, e.left.Na(a, b, c), null) : 0 === d ? e.X(null, b, null, null, null) : e.X(null, null, null, null, e.right.Na(a, b, c));
        return hc(e);
    };
    function ic(a) {
        if (a.left.e()) return bc;
        a.left.fa() || a.left.left.fa() || (a = jc(a));
        a = a.X(null, null, null, ic(a.left), null);
        return hc(a);
    }
    h.remove = function(a, b) {
        var c, d;
        c = this;
        if (0 > b(a, c.key)) c.left.e() || c.left.fa() || c.left.left.fa() || (c = jc(c)), 
        c = c.X(null, null, null, c.left.remove(a, b), null); else {
            c.left.fa() && (c = kc(c));
            c.right.e() || c.right.fa() || c.right.left.fa() || (c = lc(c), c.left.left.fa() && (c = kc(c), 
            c = lc(c)));
            if (0 === b(a, c.key)) {
                if (c.right.e()) return bc;
                d = gc(c.right);
                c = c.X(d.key, d.value, null, null, ic(c.right));
            }
            c = c.X(null, null, null, null, c.right.remove(a, b));
        }
        return hc(c);
    };
    h.fa = function() {
        return this.color;
    };
    function hc(a) {
        a.right.fa() && !a.left.fa() && (a = mc(a));
        a.left.fa() && a.left.left.fa() && (a = kc(a));
        a.left.fa() && a.right.fa() && (a = lc(a));
        return a;
    }
    function jc(a) {
        a = lc(a);
        a.right.left.fa() && (a = a.X(null, null, null, null, kc(a.right)), a = mc(a), a = lc(a));
        return a;
    }
    function mc(a) {
        return a.right.X(null, null, a.color, a.X(null, null, !0, null, a.right.left), null);
    }
    function kc(a) {
        return a.left.X(null, null, a.color, null, a.X(null, null, !0, a.left.right, null));
    }
    function lc(a) {
        return a.X(null, null, !a.color, a.left.X(null, null, !a.left.color, null, null), a.right.X(null, null, !a.right.color, null, null));
    }
    function nc() {}
    h = nc.prototype;
    h.X = function() {
        return this;
    };
    h.Na = function(a, b) {
        return new fc(a, b, null);
    };
    h.remove = function() {
        return this;
    };
    h.count = function() {
        return 0;
    };
    h.e = function() {
        return !0;
    };
    h.ha = function() {
        return !1;
    };
    h.Rc = function() {
        return null;
    };
    h.ec = function() {
        return null;
    };
    h.fa = function() {
        return !1;
    };
    var bc = new nc();
    function oc(a, b) {
        return a && "object" === typeof a ? (J(".sv" in a, "Unexpected leaf node or priority contents"), 
        b[a[".sv"]]) : a;
    }
    function pc(a, b) {
        var c = new qc();
        rc(a, new K(""), function(a, e) {
            c.mc(a, sc(e, b));
        });
        return c;
    }
    function sc(a, b) {
        var c = a.A().K(), c = oc(c, b), d;
        if (a.N()) {
            var e = oc(a.Ba(), b);
            return e !== a.Ba() || c !== a.A().K() ? new tc(e, L(c)) : a;
        }
        d = a;
        c !== a.A().K() && (d = d.da(new tc(c)));
        a.U(M, function(a, c) {
            var e = sc(c, b);
            e !== c && (d = d.Q(a, e));
        });
        return d;
    }
    function K(a, b) {
        if (1 == arguments.length) {
            this.o = a.split("/");
            for (var c = 0, d = 0; d < this.o.length; d++) 0 < this.o[d].length && (this.o[c] = this.o[d], 
            c++);
            this.o.length = c;
            this.Y = 0;
        } else this.o = a, this.Y = b;
    }
    function N(a, b) {
        var c = O(a);
        if (null === c) return b;
        if (c === O(b)) return N(G(a), G(b));
        throw Error("INTERNAL ERROR: innerPath (" + b + ") is not within outerPath (" + a + ")");
    }
    function O(a) {
        return a.Y >= a.o.length ? null : a.o[a.Y];
    }
    function uc(a) {
        return a.o.length - a.Y;
    }
    function G(a) {
        var b = a.Y;
        b < a.o.length && b++;
        return new K(a.o, b);
    }
    function vc(a) {
        return a.Y < a.o.length ? a.o[a.o.length - 1] : null;
    }
    h = K.prototype;
    h.toString = function() {
        for (var a = "", b = this.Y; b < this.o.length; b++) "" !== this.o[b] && (a += "/" + this.o[b]);
        return a || "/";
    };
    h.slice = function(a) {
        return this.o.slice(this.Y + (a || 0));
    };
    h.parent = function() {
        if (this.Y >= this.o.length) return null;
        for (var a = [], b = this.Y; b < this.o.length - 1; b++) a.push(this.o[b]);
        return new K(a, 0);
    };
    h.w = function(a) {
        for (var b = [], c = this.Y; c < this.o.length; c++) b.push(this.o[c]);
        if (a instanceof K) for (c = a.Y; c < a.o.length; c++) b.push(a.o[c]); else for (a = a.split("/"), 
        c = 0; c < a.length; c++) 0 < a[c].length && b.push(a[c]);
        return new K(b, 0);
    };
    h.e = function() {
        return this.Y >= this.o.length;
    };
    h.Z = function(a) {
        if (uc(this) !== uc(a)) return !1;
        for (var b = this.Y, c = a.Y; b <= this.o.length; b++, c++) if (this.o[b] !== a.o[c]) return !1;
        return !0;
    };
    h.contains = function(a) {
        var b = this.Y, c = a.Y;
        if (uc(this) > uc(a)) return !1;
        for (;b < this.o.length; ) {
            if (this.o[b] !== a.o[c]) return !1;
            ++b;
            ++c;
        }
        return !0;
    };
    var F = new K("");
    function wc(a, b) {
        this.Qa = a.slice();
        this.Ea = Math.max(1, this.Qa.length);
        this.kf = b;
        for (var c = 0; c < this.Qa.length; c++) this.Ea += xc(this.Qa[c]);
        yc(this);
    }
    wc.prototype.push = function(a) {
        0 < this.Qa.length && (this.Ea += 1);
        this.Qa.push(a);
        this.Ea += xc(a);
        yc(this);
    };
    wc.prototype.pop = function() {
        var a = this.Qa.pop();
        this.Ea -= xc(a);
        0 < this.Qa.length && --this.Ea;
    };
    function yc(a) {
        if (768 < a.Ea) throw Error(a.kf + "has a key path longer than 768 bytes (" + a.Ea + ").");
        if (32 < a.Qa.length) throw Error(a.kf + "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " + zc(a));
    }
    function zc(a) {
        return 0 == a.Qa.length ? "" : "in property '" + a.Qa.join(".") + "'";
    }
    function Ac() {
        this.wc = {};
    }
    Ac.prototype.set = function(a, b) {
        null == b ? delete this.wc[a] : this.wc[a] = b;
    };
    Ac.prototype.get = function(a) {
        return u(this.wc, a) ? this.wc[a] : null;
    };
    Ac.prototype.remove = function(a) {
        delete this.wc[a];
    };
    Ac.prototype.uf = !0;
    function Bc(a) {
        this.Ec = a;
        this.Md = "firebase:";
    }
    h = Bc.prototype;
    h.set = function(a, b) {
        null == b ? this.Ec.removeItem(this.Md + a) : this.Ec.setItem(this.Md + a, B(b));
    };
    h.get = function(a) {
        a = this.Ec.getItem(this.Md + a);
        return null == a ? null : mb(a);
    };
    h.remove = function(a) {
        this.Ec.removeItem(this.Md + a);
    };
    h.uf = !1;
    h.toString = function() {
        return this.Ec.toString();
    };
    function Cc(a) {
        try {
            if ("undefined" !== typeof window && "undefined" !== typeof window[a]) {
                var b = window[a];
                b.setItem("firebase:sentinel", "cache");
                b.removeItem("firebase:sentinel");
                return new Bc(b);
            }
        } catch (c) {}
        return new Ac();
    }
    var Dc = Cc("localStorage"), P = Cc("sessionStorage");
    function Ec(a, b, c, d, e) {
        this.host = a.toLowerCase();
        this.domain = this.host.substr(this.host.indexOf(".") + 1);
        this.lb = b;
        this.Cb = c;
        this.Tg = d;
        this.Ld = e || "";
        this.Oa = Dc.get("host:" + a) || this.host;
    }
    function Fc(a, b) {
        b !== a.Oa && (a.Oa = b, "s-" === a.Oa.substr(0, 2) && Dc.set("host:" + a.host, a.Oa));
    }
    Ec.prototype.toString = function() {
        var a = (this.lb ? "https://" : "http://") + this.host;
        this.Ld && (a += "<" + this.Ld + ">");
        return a;
    };
    var Gc = function() {
        var a = 1;
        return function() {
            return a++;
        };
    }();
    function J(a, b) {
        if (!a) throw Hc(b);
    }
    function Hc(a) {
        return Error("Firebase (2.2.4) INTERNAL ASSERT FAILED: " + a);
    }
    function Ic(a) {
        try {
            var b;
            if ("undefined" !== typeof atob) b = atob(a); else {
                gb();
                for (var c = eb, d = [], e = 0; e < a.length; ) {
                    var f = c[a.charAt(e++)], g = e < a.length ? c[a.charAt(e)] : 0;
                    ++e;
                    var k = e < a.length ? c[a.charAt(e)] : 64;
                    ++e;
                    var l = e < a.length ? c[a.charAt(e)] : 64;
                    ++e;
                    if (null == f || null == g || null == k || null == l) throw Error();
                    d.push(f << 2 | g >> 4);
                    64 != k && (d.push(g << 4 & 240 | k >> 2), 64 != l && d.push(k << 6 & 192 | l));
                }
                if (8192 > d.length) b = String.fromCharCode.apply(null, d); else {
                    a = "";
                    for (c = 0; c < d.length; c += 8192) a += String.fromCharCode.apply(null, Wa(d, c, c + 8192));
                    b = a;
                }
            }
            return b;
        } catch (m) {
            Bb("base64Decode failed: ", m);
        }
        return null;
    }
    function Jc(a) {
        var b = Kc(a);
        a = new La();
        a.update(b);
        var b = [], c = 8 * a.be;
        56 > a.$b ? a.update(a.Id, 56 - a.$b) : a.update(a.Id, a.Wa - (a.$b - 56));
        for (var d = a.Wa - 1; 56 <= d; d--) a.le[d] = c & 255, c /= 256;
        Ma(a, a.le);
        for (d = c = 0; 5 > d; d++) for (var e = 24; 0 <= e; e -= 8) b[c] = a.R[d] >> e & 255, 
        ++c;
        return fb(b);
    }
    function Lc(a) {
        for (var b = "", c = 0; c < arguments.length; c++) b = fa(arguments[c]) ? b + Lc.apply(null, arguments[c]) : "object" === typeof arguments[c] ? b + B(arguments[c]) : b + arguments[c], 
        b += " ";
        return b;
    }
    var Ab = null, Mc = !0;
    function Bb(a) {
        !0 === Mc && (Mc = !1, null === Ab && !0 === P.get("logging_enabled") && Nc(!0));
        if (Ab) {
            var b = Lc.apply(null, arguments);
            Ab(b);
        }
    }
    function Oc(a) {
        return function() {
            Bb(a, arguments);
        };
    }
    function Pc(a) {
        if ("undefined" !== typeof console) {
            var b = "FIREBASE INTERNAL ERROR: " + Lc.apply(null, arguments);
            "undefined" !== typeof console.error ? console.error(b) : console.log(b);
        }
    }
    function Qc(a) {
        var b = Lc.apply(null, arguments);
        throw Error("FIREBASE FATAL ERROR: " + b);
    }
    function Q(a) {
        if ("undefined" !== typeof console) {
            var b = "FIREBASE WARNING: " + Lc.apply(null, arguments);
            "undefined" !== typeof console.warn ? console.warn(b) : console.log(b);
        }
    }
    function Rc(a) {
        var b = "", c = "", d = "", e = "", f = !0, g = "https", k = 443;
        if (p(a)) {
            var l = a.indexOf("//");
            0 <= l && (g = a.substring(0, l - 1), a = a.substring(l + 2));
            l = a.indexOf("/");
            -1 === l && (l = a.length);
            b = a.substring(0, l);
            e = "";
            a = a.substring(l).split("/");
            for (l = 0; l < a.length; l++) if (0 < a[l].length) {
                var m = a[l];
                try {
                    m = decodeURIComponent(m.replace(/\+/g, " "));
                } catch (v) {}
                e += "/" + m;
            }
            a = b.split(".");
            3 === a.length ? (c = a[1], d = a[0].toLowerCase()) : 2 === a.length && (c = a[0]);
            l = b.indexOf(":");
            0 <= l && (f = "https" === g || "wss" === g, k = b.substring(l + 1), isFinite(k) && (k = String(k)), 
            k = p(k) ? /^\s*-?0x/i.test(k) ? parseInt(k, 16) : parseInt(k, 10) : NaN);
        }
        return {
            host: b,
            port: k,
            domain: c,
            Qg: d,
            lb: f,
            scheme: g,
            Zc: e
        };
    }
    function Sc(a) {
        return ga(a) && (a != a || a == Number.POSITIVE_INFINITY || a == Number.NEGATIVE_INFINITY);
    }
    function Tc(a) {
        if ("complete" === document.readyState) a(); else {
            var b = !1, c = function() {
                document.body ? b || (b = !0, a()) : setTimeout(c, Math.floor(10));
            };
            document.addEventListener ? (document.addEventListener("DOMContentLoaded", c, !1), 
            window.addEventListener("load", c, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", function() {
                "complete" === document.readyState && c();
            }), window.attachEvent("onload", c));
        }
    }
    function Sb(a, b) {
        if (a === b) return 0;
        if ("[MIN_NAME]" === a || "[MAX_NAME]" === b) return -1;
        if ("[MIN_NAME]" === b || "[MAX_NAME]" === a) return 1;
        var c = Uc(a), d = Uc(b);
        return null !== c ? null !== d ? 0 == c - d ? a.length - b.length : c - d : -1 : null !== d ? 1 : a < b ? -1 : 1;
    }
    function Vc(a, b) {
        if (b && a in b) return b[a];
        throw Error("Missing required key (" + a + ") in object: " + B(b));
    }
    function Wc(a) {
        if ("object" !== typeof a || null === a) return B(a);
        var b = [], c;
        for (c in a) b.push(c);
        b.sort();
        c = "{";
        for (var d = 0; d < b.length; d++) 0 !== d && (c += ","), c += B(b[d]), c += ":", 
        c += Wc(a[b[d]]);
        return c + "}";
    }
    function Xc(a, b) {
        if (a.length <= b) return [ a ];
        for (var c = [], d = 0; d < a.length; d += b) d + b > a ? c.push(a.substring(d, a.length)) : c.push(a.substring(d, d + b));
        return c;
    }
    function Yc(a, b) {
        if (ea(a)) for (var c = 0; c < a.length; ++c) b(c, a[c]); else r(a, b);
    }
    function Zc(a) {
        J(!Sc(a), "Invalid JSON number");
        var b, c, d, e;
        0 === a ? (d = c = 0, b = -Infinity === 1 / a ? 1 : 0) : (b = 0 > a, a = Math.abs(a), 
        a >= Math.pow(2, -1022) ? (d = Math.min(Math.floor(Math.log(a) / Math.LN2), 1023), 
        c = d + 1023, d = Math.round(a * Math.pow(2, 52 - d) - Math.pow(2, 52))) : (c = 0, 
        d = Math.round(a / Math.pow(2, -1074))));
        e = [];
        for (a = 52; a; --a) e.push(d % 2 ? 1 : 0), d = Math.floor(d / 2);
        for (a = 11; a; --a) e.push(c % 2 ? 1 : 0), c = Math.floor(c / 2);
        e.push(b ? 1 : 0);
        e.reverse();
        b = e.join("");
        c = "";
        for (a = 0; 64 > a; a += 8) d = parseInt(b.substr(a, 8), 2).toString(16), 1 === d.length && (d = "0" + d), 
        c += d;
        return c.toLowerCase();
    }
    var $c = /^-?\d{1,10}$/;
    function Uc(a) {
        return $c.test(a) && (a = Number(a), -2147483648 <= a && 2147483647 >= a) ? a : null;
    }
    function Cb(a) {
        try {
            a();
        } catch (b) {
            setTimeout(function() {
                Q("Exception was thrown by user callback.", b.stack || "");
                throw b;
            }, Math.floor(0));
        }
    }
    function R(a, b) {
        if (ha(a)) {
            var c = Array.prototype.slice.call(arguments, 1).slice();
            Cb(function() {
                a.apply(null, c);
            });
        }
    }
    function Kc(a) {
        for (var b = [], c = 0, d = 0; d < a.length; d++) {
            var e = a.charCodeAt(d);
            55296 <= e && 56319 >= e && (e -= 55296, d++, J(d < a.length, "Surrogate pair missing trail surrogate."), 
            e = 65536 + (e << 10) + (a.charCodeAt(d) - 56320));
            128 > e ? b[c++] = e : (2048 > e ? b[c++] = e >> 6 | 192 : (65536 > e ? b[c++] = e >> 12 | 224 : (b[c++] = e >> 18 | 240, 
            b[c++] = e >> 12 & 63 | 128), b[c++] = e >> 6 & 63 | 128), b[c++] = e & 63 | 128);
        }
        return b;
    }
    function xc(a) {
        for (var b = 0, c = 0; c < a.length; c++) {
            var d = a.charCodeAt(c);
            128 > d ? b++ : 2048 > d ? b += 2 : 55296 <= d && 56319 >= d ? (b += 4, c++) : b += 3;
        }
        return b;
    }
    function ad(a) {
        var b = {}, c = {}, d = {}, e = "";
        try {
            var f = a.split("."), b = mb(Ic(f[0]) || ""), c = mb(Ic(f[1]) || ""), e = f[2], d = c.d || {};
            delete c.d;
        } catch (g) {}
        return {
            Wg: b,
            Ac: c,
            data: d,
            Ng: e
        };
    }
    function bd(a) {
        a = ad(a).Ac;
        return "object" === typeof a && a.hasOwnProperty("iat") ? w(a, "iat") : null;
    }
    function cd(a) {
        a = ad(a);
        var b = a.Ac;
        return !!a.Ng && !!b && "object" === typeof b && b.hasOwnProperty("iat");
    }
    function dd(a) {
        this.V = a;
        this.g = a.n.g;
    }
    function ed(a, b, c, d) {
        var e = [], f = [];
        Oa(b, function(b) {
            "child_changed" === b.type && a.g.xd(b.Je, b.Ja) && f.push(new D("child_moved", b.Ja, b.Ya));
        });
        fd(a, e, "child_removed", b, d, c);
        fd(a, e, "child_added", b, d, c);
        fd(a, e, "child_moved", f, d, c);
        fd(a, e, "child_changed", b, d, c);
        fd(a, e, Eb, b, d, c);
        return e;
    }
    function fd(a, b, c, d, e, f) {
        d = Pa(d, function(a) {
            return a.type === c;
        });
        Xa(d, q(a.eg, a));
        Oa(d, function(c) {
            var d = gd(a, c, f);
            Oa(e, function(e) {
                e.Jf(c.type) && b.push(e.createEvent(d, a.V));
            });
        });
    }
    function gd(a, b, c) {
        "value" !== b.type && "child_removed" !== b.type && (b.Nd = c.qf(b.Ya, b.Ja, a.g));
        return b;
    }
    dd.prototype.eg = function(a, b) {
        if (null == a.Ya || null == b.Ya) throw Hc("Should only compare child_ events.");
        return this.g.compare(new E(a.Ya, a.Ja), new E(b.Ya, b.Ja));
    };
    function hd() {
        this.eb = {};
    }
    function id(a, b) {
        var c = b.type, d = b.Ya;
        J("child_added" == c || "child_changed" == c || "child_removed" == c, "Only child changes supported for tracking");
        J(".priority" !== d, "Only non-priority child changes can be tracked.");
        var e = w(a.eb, d);
        if (e) {
            var f = e.type;
            if ("child_added" == c && "child_removed" == f) a.eb[d] = new D("child_changed", b.Ja, d, e.Ja); else if ("child_removed" == c && "child_added" == f) delete a.eb[d]; else if ("child_removed" == c && "child_changed" == f) a.eb[d] = new D("child_removed", e.Je, d); else if ("child_changed" == c && "child_added" == f) a.eb[d] = new D("child_added", b.Ja, d); else if ("child_changed" == c && "child_changed" == f) a.eb[d] = new D("child_changed", b.Ja, d, e.Je); else throw Hc("Illegal combination of changes: " + b + " occurred after " + e);
        } else a.eb[d] = b;
    }
    function jd(a, b, c) {
        this.Pb = a;
        this.qb = b;
        this.sb = c || null;
    }
    h = jd.prototype;
    h.Jf = function(a) {
        return "value" === a;
    };
    h.createEvent = function(a, b) {
        var c = b.n.g;
        return new Fb("value", this, new S(a.Ja, b.lc(), c));
    };
    h.Ub = function(a) {
        var b = this.sb;
        if ("cancel" === a.ye()) {
            J(this.qb, "Raising a cancel event on a listener with no cancel callback");
            var c = this.qb;
            return function() {
                c.call(b, a.error);
            };
        }
        var d = this.Pb;
        return function() {
            d.call(b, a.Wd);
        };
    };
    h.ff = function(a, b) {
        return this.qb ? new Gb(this, a, b) : null;
    };
    h.matches = function(a) {
        return a instanceof jd ? a.Pb && this.Pb ? a.Pb === this.Pb && a.sb === this.sb : !0 : !1;
    };
    h.sf = function() {
        return null !== this.Pb;
    };
    function kd(a, b, c) {
        this.ga = a;
        this.qb = b;
        this.sb = c;
    }
    h = kd.prototype;
    h.Jf = function(a) {
        a = "children_added" === a ? "child_added" : a;
        return ("children_removed" === a ? "child_removed" : a) in this.ga;
    };
    h.ff = function(a, b) {
        return this.qb ? new Gb(this, a, b) : null;
    };
    h.createEvent = function(a, b) {
        J(null != a.Ya, "Child events should have a childName.");
        var c = b.lc().w(a.Ya);
        return new Fb(a.type, this, new S(a.Ja, c, b.n.g), a.Nd);
    };
    h.Ub = function(a) {
        var b = this.sb;
        if ("cancel" === a.ye()) {
            J(this.qb, "Raising a cancel event on a listener with no cancel callback");
            var c = this.qb;
            return function() {
                c.call(b, a.error);
            };
        }
        var d = this.ga[a.rd];
        return function() {
            d.call(b, a.Wd, a.Nd);
        };
    };
    h.matches = function(a) {
        if (a instanceof kd) {
            if (!this.ga || !a.ga) return !0;
            if (this.sb === a.sb) {
                var b = pa(a.ga);
                if (b === pa(this.ga)) {
                    if (1 === b) {
                        var b = qa(a.ga), c = qa(this.ga);
                        return c === b && (!a.ga[b] || !this.ga[c] || a.ga[b] === this.ga[c]);
                    }
                    return oa(this.ga, function(b, c) {
                        return a.ga[c] === b;
                    });
                }
            }
        }
        return !1;
    };
    h.sf = function() {
        return null !== this.ga;
    };
    function ld(a) {
        this.g = a;
    }
    h = ld.prototype;
    h.G = function(a, b, c, d, e) {
        J(a.Ic(this.g), "A node must be indexed if only a child is updated");
        d = a.M(b);
        if (d.Z(c)) return a;
        null != e && (c.e() ? a.Ha(b) ? id(e, new D("child_removed", d, b)) : J(a.N(), "A child remove without an old child only makes sense on a leaf node") : d.e() ? id(e, new D("child_added", c, b)) : id(e, new D("child_changed", c, b, d)));
        return a.N() && c.e() ? a : a.Q(b, c).mb(this.g);
    };
    h.ta = function(a, b, c) {
        null != c && (a.N() || a.U(M, function(a, e) {
            b.Ha(a) || id(c, new D("child_removed", e, a));
        }), b.N() || b.U(M, function(b, e) {
            if (a.Ha(b)) {
                var f = a.M(b);
                f.Z(e) || id(c, new D("child_changed", e, b, f));
            } else id(c, new D("child_added", e, b));
        }));
        return b.mb(this.g);
    };
    h.da = function(a, b) {
        return a.e() ? C : a.da(b);
    };
    h.Ga = function() {
        return !1;
    };
    h.Vb = function() {
        return this;
    };
    function md(a) {
        this.Ae = new ld(a.g);
        this.g = a.g;
        var b;
        a.la ? (b = nd(a), b = a.g.Oc(od(a), b)) : b = a.g.Sc();
        this.dd = b;
        a.na ? (b = pd(a), a = a.g.Oc(qd(a), b)) : a = a.g.Pc();
        this.Fc = a;
    }
    h = md.prototype;
    h.matches = function(a) {
        return 0 >= this.g.compare(this.dd, a) && 0 >= this.g.compare(a, this.Fc);
    };
    h.G = function(a, b, c, d, e) {
        this.matches(new E(b, c)) || (c = C);
        return this.Ae.G(a, b, c, d, e);
    };
    h.ta = function(a, b, c) {
        b.N() && (b = C);
        var d = b.mb(this.g), d = d.da(C), e = this;
        b.U(M, function(a, b) {
            e.matches(new E(a, b)) || (d = d.Q(a, C));
        });
        return this.Ae.ta(a, d, c);
    };
    h.da = function(a) {
        return a;
    };
    h.Ga = function() {
        return !0;
    };
    h.Vb = function() {
        return this.Ae;
    };
    function rd(a) {
        this.ra = new md(a);
        this.g = a.g;
        J(a.ia, "Only valid if limit has been set");
        this.ja = a.ja;
        this.Jb = !sd(a);
    }
    h = rd.prototype;
    h.G = function(a, b, c, d, e) {
        this.ra.matches(new E(b, c)) || (c = C);
        return a.M(b).Z(c) ? a : a.Db() < this.ja ? this.ra.Vb().G(a, b, c, d, e) : td(this, a, b, c, d, e);
    };
    h.ta = function(a, b, c) {
        var d;
        if (b.N() || b.e()) d = C.mb(this.g); else if (2 * this.ja < b.Db() && b.Ic(this.g)) {
            d = C.mb(this.g);
            b = this.Jb ? b.Zb(this.ra.Fc, this.g) : b.Xb(this.ra.dd, this.g);
            for (var e = 0; 0 < b.Pa.length && e < this.ja; ) {
                var f = H(b), g;
                if (g = this.Jb ? 0 >= this.g.compare(this.ra.dd, f) : 0 >= this.g.compare(f, this.ra.Fc)) d = d.Q(f.name, f.S), 
                e++; else break;
            }
        } else {
            d = b.mb(this.g);
            d = d.da(C);
            var k, l, m;
            if (this.Jb) {
                b = d.rf(this.g);
                k = this.ra.Fc;
                l = this.ra.dd;
                var v = ud(this.g);
                m = function(a, b) {
                    return v(b, a);
                };
            } else b = d.Wb(this.g), k = this.ra.dd, l = this.ra.Fc, m = ud(this.g);
            for (var e = 0, y = !1; 0 < b.Pa.length; ) f = H(b), !y && 0 >= m(k, f) && (y = !0), 
            (g = y && e < this.ja && 0 >= m(f, l)) ? e++ : d = d.Q(f.name, C);
        }
        return this.ra.Vb().ta(a, d, c);
    };
    h.da = function(a) {
        return a;
    };
    h.Ga = function() {
        return !0;
    };
    h.Vb = function() {
        return this.ra.Vb();
    };
    function td(a, b, c, d, e, f) {
        var g;
        if (a.Jb) {
            var k = ud(a.g);
            g = function(a, b) {
                return k(b, a);
            };
        } else g = ud(a.g);
        J(b.Db() == a.ja, "");
        var l = new E(c, d), m = a.Jb ? wd(b, a.g) : xd(b, a.g), v = a.ra.matches(l);
        if (b.Ha(c)) {
            var y = b.M(c), m = e.xe(a.g, m, a.Jb);
            null != m && m.name == c && (m = e.xe(a.g, m, a.Jb));
            e = null == m ? 1 : g(m, l);
            if (v && !d.e() && 0 <= e) return null != f && id(f, new D("child_changed", d, c, y)), 
            b.Q(c, d);
            null != f && id(f, new D("child_removed", y, c));
            b = b.Q(c, C);
            return null != m && a.ra.matches(m) ? (null != f && id(f, new D("child_added", m.S, m.name)), 
            b.Q(m.name, m.S)) : b;
        }
        return d.e() ? b : v && 0 <= g(m, l) ? (null != f && (id(f, new D("child_removed", m.S, m.name)), 
        id(f, new D("child_added", d, c))), b.Q(c, d).Q(m.name, C)) : b;
    }
    function yd(a, b) {
        this.he = a;
        this.cg = b;
    }
    function zd(a) {
        this.I = a;
    }
    zd.prototype.bb = function(a, b, c, d) {
        var e = new hd(), f;
        if (b.type === Vb) b.source.ve ? c = Ad(this, a, b.path, b.Ia, c, d, e) : (J(b.source.of, "Unknown source."), 
        f = b.source.af, c = Bd(this, a, b.path, b.Ia, c, d, f, e)); else if (b.type === Cd) b.source.ve ? c = Dd(this, a, b.path, b.children, c, d, e) : (J(b.source.of, "Unknown source."), 
        f = b.source.af, c = Ed(this, a, b.path, b.children, c, d, f, e)); else if (b.type === Xb) if (b.Ve) if (f = b.path, 
        null != c.sc(f)) c = a; else {
            b = new qb(c, a, d);
            d = a.D.j();
            if (f.e() || ".priority" === O(f)) Hb(a.u()) ? b = c.ua(tb(a)) : (b = a.u().j(), 
            J(b instanceof T, "serverChildren would be complete if leaf node"), b = c.xc(b)), 
            b = this.I.ta(d, b, e); else {
                f = O(f);
                var g = c.Xa(f, a.u());
                null == g && rb(a.u(), f) && (g = d.M(f));
                b = null != g ? this.I.G(d, f, g, b, e) : a.D.j().Ha(f) ? this.I.G(d, f, C, b, e) : d;
                b.e() && Hb(a.u()) && (d = c.ua(tb(a)), d.N() && (b = this.I.ta(b, d, e)));
            }
            d = Hb(a.u()) || null != c.sc(F);
            c = Fd(a, b, d, this.I.Ga());
        } else c = Gd(this, a, b.path, c, d, e); else if (b.type === $b) d = b.path, b = a.u(), 
        f = b.j(), g = b.$ || d.e(), c = Hd(this, new Id(a.D, new sb(f, g, b.Tb)), d, c, pb, e); else throw Hc("Unknown operation type: " + b.type);
        e = ra(e.eb);
        d = c;
        b = d.D;
        b.$ && (f = b.j().N() || b.j().e(), g = Jd(a), (0 < e.length || !a.D.$ || f && !b.j().Z(g) || !b.j().A().Z(g.A())) && e.push(Db(Jd(d))));
        return new yd(c, e);
    };
    function Hd(a, b, c, d, e, f) {
        var g = b.D;
        if (null != d.sc(c)) return b;
        var k;
        if (c.e()) J(Hb(b.u()), "If change path is empty, we must have complete server data"), 
        b.u().Tb ? (e = tb(b), d = d.xc(e instanceof T ? e : C)) : d = d.ua(tb(b)), f = a.I.ta(b.D.j(), d, f); else {
            var l = O(c);
            if (".priority" == l) J(1 == uc(c), "Can't have a priority with additional path components"), 
            f = g.j(), k = b.u().j(), d = d.hd(c, f, k), f = null != d ? a.I.da(f, d) : g.j(); else {
                var m = G(c);
                rb(g, l) ? (k = b.u().j(), d = d.hd(c, g.j(), k), d = null != d ? g.j().M(l).G(m, d) : g.j().M(l)) : d = d.Xa(l, b.u());
                f = null != d ? a.I.G(g.j(), l, d, e, f) : g.j();
            }
        }
        return Fd(b, f, g.$ || c.e(), a.I.Ga());
    }
    function Bd(a, b, c, d, e, f, g, k) {
        var l = b.u();
        g = g ? a.I : a.I.Vb();
        if (c.e()) d = g.ta(l.j(), d, null); else if (g.Ga() && !l.Tb) d = l.j().G(c, d), 
        d = g.ta(l.j(), d, null); else {
            var m = O(c);
            if ((c.e() ? !l.$ || l.Tb : !rb(l, O(c))) && 1 < uc(c)) return b;
            d = l.j().M(m).G(G(c), d);
            d = ".priority" == m ? g.da(l.j(), d) : g.G(l.j(), m, d, pb, null);
        }
        l = l.$ || c.e();
        b = new Id(b.D, new sb(d, l, g.Ga()));
        return Hd(a, b, c, e, new qb(e, b, f), k);
    }
    function Ad(a, b, c, d, e, f, g) {
        var k = b.D;
        e = new qb(e, b, f);
        if (c.e()) g = a.I.ta(b.D.j(), d, g), a = Fd(b, g, !0, a.I.Ga()); else if (f = O(c), 
        ".priority" === f) g = a.I.da(b.D.j(), d), a = Fd(b, g, k.$, k.Tb); else {
            var l = G(c);
            c = k.j().M(f);
            if (!l.e()) {
                var m = e.pf(f);
                d = null != m ? ".priority" === vc(l) && m.oa(l.parent()).e() ? m : m.G(l, d) : C;
            }
            c.Z(d) ? a = b : (g = a.I.G(k.j(), f, d, e, g), a = Fd(b, g, k.$, a.I.Ga()));
        }
        return a;
    }
    function Dd(a, b, c, d, e, f, g) {
        var k = b;
        Kd(d, function(d, m) {
            var v = c.w(d);
            rb(b.D, O(v)) && (k = Ad(a, k, v, m, e, f, g));
        });
        Kd(d, function(d, m) {
            var v = c.w(d);
            rb(b.D, O(v)) || (k = Ad(a, k, v, m, e, f, g));
        });
        return k;
    }
    function Ld(a, b) {
        Kd(b, function(b, d) {
            a = a.G(b, d);
        });
        return a;
    }
    function Ed(a, b, c, d, e, f, g, k) {
        if (b.u().j().e() && !Hb(b.u())) return b;
        var l = b;
        c = c.e() ? d : Md(Nd, c, d);
        var m = b.u().j();
        c.children.ha(function(c, d) {
            if (m.Ha(c)) {
                var I = b.u().j().M(c), I = Ld(I, d);
                l = Bd(a, l, new K(c), I, e, f, g, k);
            }
        });
        c.children.ha(function(c, d) {
            var I = !Hb(b.u()) && null == d.value;
            m.Ha(c) || I || (I = b.u().j().M(c), I = Ld(I, d), l = Bd(a, l, new K(c), I, e, f, g, k));
        });
        return l;
    }
    function Gd(a, b, c, d, e, f) {
        if (null != d.sc(c)) return b;
        var g = new qb(d, b, e), k = e = b.D.j();
        if (Hb(b.u())) {
            if (c.e()) e = d.ua(tb(b)), k = a.I.ta(b.D.j(), e, f); else if (".priority" === O(c)) {
                var l = d.Xa(O(c), b.u());
                null == l || e.e() || e.A().Z(l) || (k = a.I.da(e, l));
            } else l = O(c), e = d.Xa(l, b.u()), null != e && (k = a.I.G(b.D.j(), l, e, g, f));
            e = !0;
        } else if (b.D.$ || c.e()) k = e, e = b.D.j(), e.N() || e.U(M, function(c) {
            var e = d.Xa(c, b.u());
            null != e && (k = a.I.G(k, c, e, g, f));
        }), e = b.D.$; else {
            l = O(c);
            if (1 == uc(c) || rb(b.D, l)) c = d.Xa(l, b.u()), null != c && (k = a.I.G(e, l, c, g, f));
            e = !1;
        }
        return Fd(b, k, e, a.I.Ga());
    }
    function Od() {}
    var Pd = {};
    function ud(a) {
        return q(a.compare, a);
    }
    Od.prototype.xd = function(a, b) {
        return 0 !== this.compare(new E("[MIN_NAME]", a), new E("[MIN_NAME]", b));
    };
    Od.prototype.Sc = function() {
        return Qd;
    };
    function Rd(a) {
        this.bc = a;
    }
    ma(Rd, Od);
    h = Rd.prototype;
    h.Hc = function(a) {
        return !a.M(this.bc).e();
    };
    h.compare = function(a, b) {
        var c = a.S.M(this.bc), d = b.S.M(this.bc), c = c.Cc(d);
        return 0 === c ? Sb(a.name, b.name) : c;
    };
    h.Oc = function(a, b) {
        var c = L(a), c = C.Q(this.bc, c);
        return new E(b, c);
    };
    h.Pc = function() {
        var a = C.Q(this.bc, Sd);
        return new E("[MAX_NAME]", a);
    };
    h.toString = function() {
        return this.bc;
    };
    function Td() {}
    ma(Td, Od);
    h = Td.prototype;
    h.compare = function(a, b) {
        var c = a.S.A(), d = b.S.A(), c = c.Cc(d);
        return 0 === c ? Sb(a.name, b.name) : c;
    };
    h.Hc = function(a) {
        return !a.A().e();
    };
    h.xd = function(a, b) {
        return !a.A().Z(b.A());
    };
    h.Sc = function() {
        return Qd;
    };
    h.Pc = function() {
        return new E("[MAX_NAME]", new tc("[PRIORITY-POST]", Sd));
    };
    h.Oc = function(a, b) {
        var c = L(a);
        return new E(b, new tc("[PRIORITY-POST]", c));
    };
    h.toString = function() {
        return ".priority";
    };
    var M = new Td();
    function Ud() {}
    ma(Ud, Od);
    h = Ud.prototype;
    h.compare = function(a, b) {
        return Sb(a.name, b.name);
    };
    h.Hc = function() {
        throw Hc("KeyIndex.isDefinedOn not expected to be called.");
    };
    h.xd = function() {
        return !1;
    };
    h.Sc = function() {
        return Qd;
    };
    h.Pc = function() {
        return new E("[MAX_NAME]", C);
    };
    h.Oc = function(a) {
        J(p(a), "KeyIndex indexValue must always be a string.");
        return new E(a, C);
    };
    h.toString = function() {
        return ".key";
    };
    var Vd = new Ud();
    function Wd() {}
    ma(Wd, Od);
    h = Wd.prototype;
    h.compare = function(a, b) {
        var c = a.S.Cc(b.S);
        return 0 === c ? Sb(a.name, b.name) : c;
    };
    h.Hc = function() {
        return !0;
    };
    h.xd = function(a, b) {
        return !a.Z(b);
    };
    h.Sc = function() {
        return Qd;
    };
    h.Pc = function() {
        return Xd;
    };
    h.Oc = function(a, b) {
        var c = L(a);
        return new E(b, c);
    };
    h.toString = function() {
        return ".value";
    };
    var Yd = new Wd();
    function Zd() {
        this.Rb = this.na = this.Lb = this.la = this.ia = !1;
        this.ja = 0;
        this.Nb = "";
        this.dc = null;
        this.xb = "";
        this.ac = null;
        this.vb = "";
        this.g = M;
    }
    var $d = new Zd();
    function sd(a) {
        return "" === a.Nb ? a.la : "l" === a.Nb;
    }
    function od(a) {
        J(a.la, "Only valid if start has been set");
        return a.dc;
    }
    function nd(a) {
        J(a.la, "Only valid if start has been set");
        return a.Lb ? a.xb : "[MIN_NAME]";
    }
    function qd(a) {
        J(a.na, "Only valid if end has been set");
        return a.ac;
    }
    function pd(a) {
        J(a.na, "Only valid if end has been set");
        return a.Rb ? a.vb : "[MAX_NAME]";
    }
    function ae(a) {
        var b = new Zd();
        b.ia = a.ia;
        b.ja = a.ja;
        b.la = a.la;
        b.dc = a.dc;
        b.Lb = a.Lb;
        b.xb = a.xb;
        b.na = a.na;
        b.ac = a.ac;
        b.Rb = a.Rb;
        b.vb = a.vb;
        b.g = a.g;
        return b;
    }
    h = Zd.prototype;
    h.Ge = function(a) {
        var b = ae(this);
        b.ia = !0;
        b.ja = a;
        b.Nb = "";
        return b;
    };
    h.He = function(a) {
        var b = ae(this);
        b.ia = !0;
        b.ja = a;
        b.Nb = "l";
        return b;
    };
    h.Ie = function(a) {
        var b = ae(this);
        b.ia = !0;
        b.ja = a;
        b.Nb = "r";
        return b;
    };
    h.Xd = function(a, b) {
        var c = ae(this);
        c.la = !0;
        n(a) || (a = null);
        c.dc = a;
        null != b ? (c.Lb = !0, c.xb = b) : (c.Lb = !1, c.xb = "");
        return c;
    };
    h.qd = function(a, b) {
        var c = ae(this);
        c.na = !0;
        n(a) || (a = null);
        c.ac = a;
        n(b) ? (c.Rb = !0, c.vb = b) : (c.Yg = !1, c.vb = "");
        return c;
    };
    function be(a, b) {
        var c = ae(a);
        c.g = b;
        return c;
    }
    function ce(a) {
        var b = {};
        a.la && (b.sp = a.dc, a.Lb && (b.sn = a.xb));
        a.na && (b.ep = a.ac, a.Rb && (b.en = a.vb));
        if (a.ia) {
            b.l = a.ja;
            var c = a.Nb;
            "" === c && (c = sd(a) ? "l" : "r");
            b.vf = c;
        }
        a.g !== M && (b.i = a.g.toString());
        return b;
    }
    function de(a) {
        return !(a.la || a.na || a.ia);
    }
    function ee(a) {
        var b = {};
        if (de(a) && a.g == M) return b;
        var c;
        a.g === M ? c = "$priority" : a.g === Yd ? c = "$value" : (J(a.g instanceof Rd, "Unrecognized index type!"), 
        c = a.g.toString());
        b.orderBy = B(c);
        a.la && (b.startAt = B(a.dc), a.Lb && (b.startAt += "," + B(a.xb)));
        a.na && (b.endAt = B(a.ac), a.Rb && (b.endAt += "," + B(a.vb)));
        a.ia && (sd(a) ? b.limitToFirst = a.ja : b.limitToLast = a.ja);
        return b;
    }
    h.toString = function() {
        return B(ce(this));
    };
    function fe(a, b) {
        this.yd = a;
        this.cc = b;
    }
    fe.prototype.get = function(a) {
        var b = w(this.yd, a);
        if (!b) throw Error("No index defined for " + a);
        return b === Pd ? null : b;
    };
    function ge(a, b, c) {
        var d = na(a.yd, function(d, f) {
            var g = w(a.cc, f);
            J(g, "Missing index implementation for " + f);
            if (d === Pd) {
                if (g.Hc(b.S)) {
                    for (var k = [], l = c.Wb(Qb), m = H(l); m; ) m.name != b.name && k.push(m), m = H(l);
                    k.push(b);
                    return he(k, ud(g));
                }
                return Pd;
            }
            g = c.get(b.name);
            k = d;
            g && (k = k.remove(new E(b.name, g)));
            return k.Na(b, b.S);
        });
        return new fe(d, a.cc);
    }
    function ie(a, b, c) {
        var d = na(a.yd, function(a) {
            if (a === Pd) return a;
            var d = c.get(b.name);
            return d ? a.remove(new E(b.name, d)) : a;
        });
        return new fe(d, a.cc);
    }
    var je = new fe({
        ".priority": Pd
    }, {
        ".priority": M
    });
    function tc(a, b) {
        this.C = a;
        J(n(this.C) && null !== this.C, "LeafNode shouldn't be created with null/undefined value.");
        this.ba = b || C;
        ke(this.ba);
        this.Bb = null;
    }
    h = tc.prototype;
    h.N = function() {
        return !0;
    };
    h.A = function() {
        return this.ba;
    };
    h.da = function(a) {
        return new tc(this.C, a);
    };
    h.M = function(a) {
        return ".priority" === a ? this.ba : C;
    };
    h.oa = function(a) {
        return a.e() ? this : ".priority" === O(a) ? this.ba : C;
    };
    h.Ha = function() {
        return !1;
    };
    h.qf = function() {
        return null;
    };
    h.Q = function(a, b) {
        return ".priority" === a ? this.da(b) : b.e() && ".priority" !== a ? this : C.Q(a, b).da(this.ba);
    };
    h.G = function(a, b) {
        var c = O(a);
        if (null === c) return b;
        if (b.e() && ".priority" !== c) return this;
        J(".priority" !== c || 1 === uc(a), ".priority must be the last token in a path");
        return this.Q(c, C.G(G(a), b));
    };
    h.e = function() {
        return !1;
    };
    h.Db = function() {
        return 0;
    };
    h.K = function(a) {
        return a && !this.A().e() ? {
            ".value": this.Ba(),
            ".priority": this.A().K()
        } : this.Ba();
    };
    h.hash = function() {
        if (null === this.Bb) {
            var a = "";
            this.ba.e() || (a += "priority:" + le(this.ba.K()) + ":");
            var b = typeof this.C, a = a + (b + ":"), a = "number" === b ? a + Zc(this.C) : a + this.C;
            this.Bb = Jc(a);
        }
        return this.Bb;
    };
    h.Ba = function() {
        return this.C;
    };
    h.Cc = function(a) {
        if (a === C) return 1;
        if (a instanceof T) return -1;
        J(a.N(), "Unknown node type");
        var b = typeof a.C, c = typeof this.C, d = Na(me, b), e = Na(me, c);
        J(0 <= d, "Unknown leaf type: " + b);
        J(0 <= e, "Unknown leaf type: " + c);
        return d === e ? "object" === c ? 0 : this.C < a.C ? -1 : this.C === a.C ? 0 : 1 : e - d;
    };
    var me = [ "object", "boolean", "number", "string" ];
    tc.prototype.mb = function() {
        return this;
    };
    tc.prototype.Ic = function() {
        return !0;
    };
    tc.prototype.Z = function(a) {
        return a === this ? !0 : a.N() ? this.C === a.C && this.ba.Z(a.ba) : !1;
    };
    tc.prototype.toString = function() {
        return B(this.K(!0));
    };
    function T(a, b, c) {
        this.m = a;
        (this.ba = b) && ke(this.ba);
        a.e() && J(!this.ba || this.ba.e(), "An empty node cannot have a priority");
        this.wb = c;
        this.Bb = null;
    }
    h = T.prototype;
    h.N = function() {
        return !1;
    };
    h.A = function() {
        return this.ba || C;
    };
    h.da = function(a) {
        return this.m.e() ? this : new T(this.m, a, this.wb);
    };
    h.M = function(a) {
        if (".priority" === a) return this.A();
        a = this.m.get(a);
        return null === a ? C : a;
    };
    h.oa = function(a) {
        var b = O(a);
        return null === b ? this : this.M(b).oa(G(a));
    };
    h.Ha = function(a) {
        return null !== this.m.get(a);
    };
    h.Q = function(a, b) {
        J(b, "We should always be passing snapshot nodes");
        if (".priority" === a) return this.da(b);
        var c = new E(a, b), d, e;
        b.e() ? (d = this.m.remove(a), c = ie(this.wb, c, this.m)) : (d = this.m.Na(a, b), 
        c = ge(this.wb, c, this.m));
        e = d.e() ? C : this.ba;
        return new T(d, e, c);
    };
    h.G = function(a, b) {
        var c = O(a);
        if (null === c) return b;
        J(".priority" !== O(a) || 1 === uc(a), ".priority must be the last token in a path");
        var d = this.M(c).G(G(a), b);
        return this.Q(c, d);
    };
    h.e = function() {
        return this.m.e();
    };
    h.Db = function() {
        return this.m.count();
    };
    var ne = /^(0|[1-9]\d*)$/;
    h = T.prototype;
    h.K = function(a) {
        if (this.e()) return null;
        var b = {}, c = 0, d = 0, e = !0;
        this.U(M, function(f, g) {
            b[f] = g.K(a);
            c++;
            e && ne.test(f) ? d = Math.max(d, Number(f)) : e = !1;
        });
        if (!a && e && d < 2 * c) {
            var f = [], g;
            for (g in b) f[g] = b[g];
            return f;
        }
        a && !this.A().e() && (b[".priority"] = this.A().K());
        return b;
    };
    h.hash = function() {
        if (null === this.Bb) {
            var a = "";
            this.A().e() || (a += "priority:" + le(this.A().K()) + ":");
            this.U(M, function(b, c) {
                var d = c.hash();
                "" !== d && (a += ":" + b + ":" + d);
            });
            this.Bb = "" === a ? "" : Jc(a);
        }
        return this.Bb;
    };
    h.qf = function(a, b, c) {
        return (c = oe(this, c)) ? (a = cc(c, new E(a, b))) ? a.name : null : cc(this.m, a);
    };
    function wd(a, b) {
        var c;
        c = (c = oe(a, b)) ? (c = c.Rc()) && c.name : a.m.Rc();
        return c ? new E(c, a.m.get(c)) : null;
    }
    function xd(a, b) {
        var c;
        c = (c = oe(a, b)) ? (c = c.ec()) && c.name : a.m.ec();
        return c ? new E(c, a.m.get(c)) : null;
    }
    h.U = function(a, b) {
        var c = oe(this, a);
        return c ? c.ha(function(a) {
            return b(a.name, a.S);
        }) : this.m.ha(b);
    };
    h.Wb = function(a) {
        return this.Xb(a.Sc(), a);
    };
    h.Xb = function(a, b) {
        var c = oe(this, b);
        if (c) return c.Xb(a, function(a) {
            return a;
        });
        for (var c = this.m.Xb(a.name, Qb), d = ec(c); null != d && 0 > b.compare(d, a); ) H(c), 
        d = ec(c);
        return c;
    };
    h.rf = function(a) {
        return this.Zb(a.Pc(), a);
    };
    h.Zb = function(a, b) {
        var c = oe(this, b);
        if (c) return c.Zb(a, function(a) {
            return a;
        });
        for (var c = this.m.Zb(a.name, Qb), d = ec(c); null != d && 0 < b.compare(d, a); ) H(c), 
        d = ec(c);
        return c;
    };
    h.Cc = function(a) {
        return this.e() ? a.e() ? 0 : -1 : a.N() || a.e() ? 1 : a === Sd ? -1 : 0;
    };
    h.mb = function(a) {
        if (a === Vd || ta(this.wb.cc, a.toString())) return this;
        var b = this.wb, c = this.m;
        J(a !== Vd, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        for (var d = [], e = !1, c = c.Wb(Qb), f = H(c); f; ) e = e || a.Hc(f.S), d.push(f), 
        f = H(c);
        d = e ? he(d, ud(a)) : Pd;
        e = a.toString();
        c = xa(b.cc);
        c[e] = a;
        a = xa(b.yd);
        a[e] = d;
        return new T(this.m, this.ba, new fe(a, c));
    };
    h.Ic = function(a) {
        return a === Vd || ta(this.wb.cc, a.toString());
    };
    h.Z = function(a) {
        if (a === this) return !0;
        if (a.N()) return !1;
        if (this.A().Z(a.A()) && this.m.count() === a.m.count()) {
            var b = this.Wb(M);
            a = a.Wb(M);
            for (var c = H(b), d = H(a); c && d; ) {
                if (c.name !== d.name || !c.S.Z(d.S)) return !1;
                c = H(b);
                d = H(a);
            }
            return null === c && null === d;
        }
        return !1;
    };
    function oe(a, b) {
        return b === Vd ? null : a.wb.get(b.toString());
    }
    h.toString = function() {
        return B(this.K(!0));
    };
    function L(a, b) {
        if (null === a) return C;
        var c = null;
        "object" === typeof a && ".priority" in a ? c = a[".priority"] : "undefined" !== typeof b && (c = b);
        J(null === c || "string" === typeof c || "number" === typeof c || "object" === typeof c && ".sv" in c, "Invalid priority type found: " + typeof c);
        "object" === typeof a && ".value" in a && null !== a[".value"] && (a = a[".value"]);
        if ("object" !== typeof a || ".sv" in a) return new tc(a, L(c));
        if (a instanceof Array) {
            var d = C, e = a;
            r(e, function(a, b) {
                if (u(e, b) && "." !== b.substring(0, 1)) {
                    var c = L(a);
                    if (c.N() || !c.e()) d = d.Q(b, c);
                }
            });
            return d.da(L(c));
        }
        var f = [], g = !1, k = a;
        hb(k, function(a) {
            if ("string" !== typeof a || "." !== a.substring(0, 1)) {
                var b = L(k[a]);
                b.e() || (g = g || !b.A().e(), f.push(new E(a, b)));
            }
        });
        if (0 == f.length) return C;
        var l = he(f, Rb, function(a) {
            return a.name;
        }, Tb);
        if (g) {
            var m = he(f, ud(M));
            return new T(l, L(c), new fe({
                ".priority": m
            }, {
                ".priority": M
            }));
        }
        return new T(l, L(c), je);
    }
    var pe = Math.log(2);
    function qe(a) {
        this.count = parseInt(Math.log(a + 1) / pe, 10);
        this.hf = this.count - 1;
        this.bg = a + 1 & parseInt(Array(this.count + 1).join("1"), 2);
    }
    function re(a) {
        var b = !(a.bg & 1 << a.hf);
        a.hf--;
        return b;
    }
    function he(a, b, c, d) {
        function e(b, d) {
            var f = d - b;
            if (0 == f) return null;
            if (1 == f) {
                var m = a[b], v = c ? c(m) : m;
                return new fc(v, m.S, !1, null, null);
            }
            var m = parseInt(f / 2, 10) + b, f = e(b, m), y = e(m + 1, d), m = a[m], v = c ? c(m) : m;
            return new fc(v, m.S, !1, f, y);
        }
        a.sort(b);
        var f = function(b) {
            function d(b, g) {
                var k = v - b, y = v;
                v -= b;
                var y = e(k + 1, y), k = a[k], I = c ? c(k) : k, y = new fc(I, k.S, g, null, y);
                f ? f.left = y : m = y;
                f = y;
            }
            for (var f = null, m = null, v = a.length, y = 0; y < b.count; ++y) {
                var I = re(b), vd = Math.pow(2, b.count - (y + 1));
                I ? d(vd, !1) : (d(vd, !1), d(vd, !0));
            }
            return m;
        }(new qe(a.length));
        return null !== f ? new ac(d || b, f) : new ac(d || b);
    }
    function le(a) {
        return "number" === typeof a ? "number:" + Zc(a) : "string:" + a;
    }
    function ke(a) {
        if (a.N()) {
            var b = a.K();
            J("string" === typeof b || "number" === typeof b || "object" === typeof b && u(b, ".sv"), "Priority must be a string or number.");
        } else J(a === Sd || a.e(), "priority of unexpected type.");
        J(a === Sd || a.A().e(), "Priority nodes can't have a priority of their own.");
    }
    var C = new T(new ac(Tb), null, je);
    function se() {
        T.call(this, new ac(Tb), C, je);
    }
    ma(se, T);
    h = se.prototype;
    h.Cc = function(a) {
        return a === this ? 0 : 1;
    };
    h.Z = function(a) {
        return a === this;
    };
    h.A = function() {
        return this;
    };
    h.M = function() {
        return C;
    };
    h.e = function() {
        return !1;
    };
    var Sd = new se(), Qd = new E("[MIN_NAME]", C), Xd = new E("[MAX_NAME]", Sd);
    function Id(a, b) {
        this.D = a;
        this.Ud = b;
    }
    function Fd(a, b, c, d) {
        return new Id(new sb(b, c, d), a.Ud);
    }
    function Jd(a) {
        return a.D.$ ? a.D.j() : null;
    }
    Id.prototype.u = function() {
        return this.Ud;
    };
    function tb(a) {
        return a.Ud.$ ? a.Ud.j() : null;
    }
    function te(a, b) {
        this.V = a;
        var c = a.n, d = new ld(c.g), c = de(c) ? new ld(c.g) : c.ia ? new rd(c) : new md(c);
        this.Gf = new zd(c);
        var e = b.u(), f = b.D, g = d.ta(C, e.j(), null), k = c.ta(C, f.j(), null);
        this.Ka = new Id(new sb(k, f.$, c.Ga()), new sb(g, e.$, d.Ga()));
        this.Za = [];
        this.ig = new dd(a);
    }
    function ue(a) {
        return a.V;
    }
    h = te.prototype;
    h.u = function() {
        return this.Ka.u().j();
    };
    h.hb = function(a) {
        var b = tb(this.Ka);
        return b && (de(this.V.n) || !a.e() && !b.M(O(a)).e()) ? b.oa(a) : null;
    };
    h.e = function() {
        return 0 === this.Za.length;
    };
    h.Ob = function(a) {
        this.Za.push(a);
    };
    h.kb = function(a, b) {
        var c = [];
        if (b) {
            J(null == a, "A cancel should cancel all event registrations.");
            var d = this.V.path;
            Oa(this.Za, function(a) {
                (a = a.ff(b, d)) && c.push(a);
            });
        }
        if (a) {
            for (var e = [], f = 0; f < this.Za.length; ++f) {
                var g = this.Za[f];
                if (!g.matches(a)) e.push(g); else if (a.sf()) {
                    e = e.concat(this.Za.slice(f + 1));
                    break;
                }
            }
            this.Za = e;
        } else this.Za = [];
        return c;
    };
    h.bb = function(a, b, c) {
        a.type === Cd && null !== a.source.Ib && (J(tb(this.Ka), "We should always have a full cache before handling merges"), 
        J(Jd(this.Ka), "Missing event cache, even though we have a server cache"));
        var d = this.Ka;
        a = this.Gf.bb(d, a, b, c);
        b = this.Gf;
        c = a.he;
        J(c.D.j().Ic(b.I.g), "Event snap not indexed");
        J(c.u().j().Ic(b.I.g), "Server snap not indexed");
        J(Hb(a.he.u()) || !Hb(d.u()), "Once a server snap is complete, it should never go back");
        this.Ka = a.he;
        return ve(this, a.cg, a.he.D.j(), null);
    };
    function we(a, b) {
        var c = a.Ka.D, d = [];
        c.j().N() || c.j().U(M, function(a, b) {
            d.push(new D("child_added", b, a));
        });
        c.$ && d.push(Db(c.j()));
        return ve(a, d, c.j(), b);
    }
    function ve(a, b, c, d) {
        return ed(a.ig, b, c, d ? [ d ] : a.Za);
    }
    function xe(a, b, c) {
        this.type = Cd;
        this.source = a;
        this.path = b;
        this.children = c;
    }
    xe.prototype.Wc = function(a) {
        if (this.path.e()) return a = this.children.subtree(new K(a)), a.e() ? null : a.value ? new Ub(this.source, F, a.value) : new xe(this.source, F, a);
        J(O(this.path) === a, "Can't get a merge for a child not on the path of the operation");
        return new xe(this.source, G(this.path), this.children);
    };
    xe.prototype.toString = function() {
        return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
    };
    var Vb = 0, Cd = 1, Xb = 2, $b = 3;
    function ye(a, b, c, d) {
        this.ve = a;
        this.of = b;
        this.Ib = c;
        this.af = d;
        J(!d || b, "Tagged queries must be from server.");
    }
    var Yb = new ye(!0, !1, null, !1), ze = new ye(!1, !0, null, !1);
    ye.prototype.toString = function() {
        return this.ve ? "user" : this.af ? "server(queryID=" + this.Ib + ")" : "server";
    };
    function Ae(a, b) {
        this.f = Oc("p:rest:");
        this.H = a;
        this.Gb = b;
        this.Fa = null;
        this.aa = {};
    }
    function Be(a, b) {
        if (n(b)) return "tag$" + b;
        var c = a.n;
        J(de(c) && c.g == M, "should have a tag if it's not a default query.");
        return a.path.toString();
    }
    h = Ae.prototype;
    h.xf = function(a, b, c, d) {
        var e = a.path.toString();
        this.f("Listen called for " + e + " " + a.wa());
        var f = Be(a, c), g = {};
        this.aa[f] = g;
        a = ee(a.n);
        var k = this;
        Ce(this, e + ".json", a, function(a, b) {
            var v = b;
            404 === a && (a = v = null);
            null === a && k.Gb(e, v, !1, c);
            w(k.aa, f) === g && d(a ? 401 == a ? "permission_denied" : "rest_error:" + a : "ok", null);
        });
    };
    h.Of = function(a, b) {
        var c = Be(a, b);
        delete this.aa[c];
    };
    h.P = function(a, b) {
        this.Fa = a;
        var c = ad(a), d = c.data, c = c.Ac && c.Ac.exp;
        b && b("ok", {
            auth: d,
            expires: c
        });
    };
    h.ee = function(a) {
        this.Fa = null;
        a("ok", null);
    };
    h.Le = function() {};
    h.Bf = function() {};
    h.Gd = function() {};
    h.put = function() {};
    h.yf = function() {};
    h.Te = function() {};
    function Ce(a, b, c, d) {
        c = c || {};
        c.format = "export";
        a.Fa && (c.auth = a.Fa);
        var e = (a.H.lb ? "https://" : "http://") + a.H.host + b + "?" + jb(c);
        a.f("Sending REST request for " + e);
        var f = new XMLHttpRequest();
        f.onreadystatechange = function() {
            if (d && 4 === f.readyState) {
                a.f("REST Response for " + e + " received. status:", f.status, "response:", f.responseText);
                var b = null;
                if (200 <= f.status && 300 > f.status) {
                    try {
                        b = mb(f.responseText);
                    } catch (c) {
                        Q("Failed to parse JSON response for " + e + ": " + f.responseText);
                    }
                    d(null, b);
                } else 401 !== f.status && 404 !== f.status && Q("Got unsuccessful REST response for " + e + " Status: " + f.status), 
                d(f.status);
                d = null;
            }
        };
        f.open("GET", e, !0);
        f.send();
    }
    function De(a, b) {
        this.value = a;
        this.children = b || Ee;
    }
    var Ee = new ac(function(a, b) {
        return a === b ? 0 : a < b ? -1 : 1;
    });
    function Fe(a) {
        var b = Nd;
        r(a, function(a, d) {
            b = b.set(new K(d), a);
        });
        return b;
    }
    h = De.prototype;
    h.e = function() {
        return null === this.value && this.children.e();
    };
    function Ge(a, b, c) {
        if (null != a.value && c(a.value)) return {
            path: F,
            value: a.value
        };
        if (b.e()) return null;
        var d = O(b);
        a = a.children.get(d);
        return null !== a ? (b = Ge(a, G(b), c), null != b ? {
            path: new K(d).w(b.path),
            value: b.value
        } : null) : null;
    }
    function He(a, b) {
        return Ge(a, b, function() {
            return !0;
        });
    }
    h.subtree = function(a) {
        if (a.e()) return this;
        var b = this.children.get(O(a));
        return null !== b ? b.subtree(G(a)) : Nd;
    };
    h.set = function(a, b) {
        if (a.e()) return new De(b, this.children);
        var c = O(a), d = (this.children.get(c) || Nd).set(G(a), b), c = this.children.Na(c, d);
        return new De(this.value, c);
    };
    h.remove = function(a) {
        if (a.e()) return this.children.e() ? Nd : new De(null, this.children);
        var b = O(a), c = this.children.get(b);
        return c ? (a = c.remove(G(a)), b = a.e() ? this.children.remove(b) : this.children.Na(b, a), 
        null === this.value && b.e() ? Nd : new De(this.value, b)) : this;
    };
    h.get = function(a) {
        if (a.e()) return this.value;
        var b = this.children.get(O(a));
        return b ? b.get(G(a)) : null;
    };
    function Md(a, b, c) {
        if (b.e()) return c;
        var d = O(b);
        b = Md(a.children.get(d) || Nd, G(b), c);
        d = b.e() ? a.children.remove(d) : a.children.Na(d, b);
        return new De(a.value, d);
    }
    function Ie(a, b) {
        return Je(a, F, b);
    }
    function Je(a, b, c) {
        var d = {};
        a.children.ha(function(a, f) {
            d[a] = Je(f, b.w(a), c);
        });
        return c(b, a.value, d);
    }
    function Ke(a, b, c) {
        return Le(a, b, F, c);
    }
    function Le(a, b, c, d) {
        var e = a.value ? d(c, a.value) : !1;
        if (e) return e;
        if (b.e()) return null;
        e = O(b);
        return (a = a.children.get(e)) ? Le(a, G(b), c.w(e), d) : null;
    }
    function Me(a, b, c) {
        var d = F;
        if (!b.e()) {
            var e = !0;
            a.value && (e = c(d, a.value));
            !0 === e && (e = O(b), (a = a.children.get(e)) && Ne(a, G(b), d.w(e), c));
        }
    }
    function Ne(a, b, c, d) {
        if (b.e()) return a;
        a.value && d(c, a.value);
        var e = O(b);
        return (a = a.children.get(e)) ? Ne(a, G(b), c.w(e), d) : Nd;
    }
    function Kd(a, b) {
        Oe(a, F, b);
    }
    function Oe(a, b, c) {
        a.children.ha(function(a, e) {
            Oe(e, b.w(a), c);
        });
        a.value && c(b, a.value);
    }
    function Pe(a, b) {
        a.children.ha(function(a, d) {
            d.value && b(a, d.value);
        });
    }
    var Nd = new De(null);
    De.prototype.toString = function() {
        var a = {};
        Kd(this, function(b, c) {
            a[b.toString()] = c.toString();
        });
        return B(a);
    };
    function Qe(a) {
        this.W = a;
    }
    var Re = new Qe(new De(null));
    function Se(a, b, c) {
        if (b.e()) return new Qe(new De(c));
        var d = He(a.W, b);
        if (null != d) {
            var e = d.path, d = d.value;
            b = N(e, b);
            d = d.G(b, c);
            return new Qe(a.W.set(e, d));
        }
        a = Md(a.W, b, new De(c));
        return new Qe(a);
    }
    function Te(a, b, c) {
        var d = a;
        hb(c, function(a, c) {
            d = Se(d, b.w(a), c);
        });
        return d;
    }
    Qe.prototype.Od = function(a) {
        if (a.e()) return Re;
        a = Md(this.W, a, Nd);
        return new Qe(a);
    };
    function Ue(a, b) {
        var c = He(a.W, b);
        return null != c ? a.W.get(c.path).oa(N(c.path, b)) : null;
    }
    function Ve(a) {
        var b = [], c = a.W.value;
        null != c ? c.N() || c.U(M, function(a, c) {
            b.push(new E(a, c));
        }) : a.W.children.ha(function(a, c) {
            null != c.value && b.push(new E(a, c.value));
        });
        return b;
    }
    function We(a, b) {
        if (b.e()) return a;
        var c = Ue(a, b);
        return null != c ? new Qe(new De(c)) : new Qe(a.W.subtree(b));
    }
    Qe.prototype.e = function() {
        return this.W.e();
    };
    Qe.prototype.apply = function(a) {
        return Xe(F, this.W, a);
    };
    function Xe(a, b, c) {
        if (null != b.value) return c.G(a, b.value);
        var d = null;
        b.children.ha(function(b, f) {
            ".priority" === b ? (J(null !== f.value, "Priority writes must always be leaf nodes"), 
            d = f.value) : c = Xe(a.w(b), f, c);
        });
        c.oa(a).e() || null === d || (c = c.G(a.w(".priority"), d));
        return c;
    }
    function Ye() {
        this.T = Re;
        this.za = [];
        this.Lc = -1;
    }
    h = Ye.prototype;
    h.Od = function(a) {
        var b = Ua(this.za, function(b) {
            return b.ie === a;
        });
        J(0 <= b, "removeWrite called with nonexistent writeId.");
        var c = this.za[b];
        this.za.splice(b, 1);
        for (var d = c.visible, e = !1, f = this.za.length - 1; d && 0 <= f; ) {
            var g = this.za[f];
            g.visible && (f >= b && Ze(g, c.path) ? d = !1 : c.path.contains(g.path) && (e = !0));
            f--;
        }
        if (d) {
            if (e) this.T = $e(this.za, af, F), this.Lc = 0 < this.za.length ? this.za[this.za.length - 1].ie : -1; else if (c.Ia) this.T = this.T.Od(c.path); else {
                var k = this;
                r(c.children, function(a, b) {
                    k.T = k.T.Od(c.path.w(b));
                });
            }
            return c.path;
        }
        return null;
    };
    h.ua = function(a, b, c, d) {
        if (c || d) {
            var e = We(this.T, a);
            return !d && e.e() ? b : d || null != b || null != Ue(e, F) ? (e = $e(this.za, function(b) {
                return (b.visible || d) && (!c || !(0 <= Na(c, b.ie))) && (b.path.contains(a) || a.contains(b.path));
            }, a), b = b || C, e.apply(b)) : null;
        }
        e = Ue(this.T, a);
        if (null != e) return e;
        e = We(this.T, a);
        return e.e() ? b : null != b || null != Ue(e, F) ? (b = b || C, e.apply(b)) : null;
    };
    h.xc = function(a, b) {
        var c = C, d = Ue(this.T, a);
        if (d) d.N() || d.U(M, function(a, b) {
            c = c.Q(a, b);
        }); else if (b) {
            var e = We(this.T, a);
            b.U(M, function(a, b) {
                var d = We(e, new K(a)).apply(b);
                c = c.Q(a, d);
            });
            Oa(Ve(e), function(a) {
                c = c.Q(a.name, a.S);
            });
        } else e = We(this.T, a), Oa(Ve(e), function(a) {
            c = c.Q(a.name, a.S);
        });
        return c;
    };
    h.hd = function(a, b, c, d) {
        J(c || d, "Either existingEventSnap or existingServerSnap must exist");
        a = a.w(b);
        if (null != Ue(this.T, a)) return null;
        a = We(this.T, a);
        return a.e() ? d.oa(b) : a.apply(d.oa(b));
    };
    h.Xa = function(a, b, c) {
        a = a.w(b);
        var d = Ue(this.T, a);
        return null != d ? d : rb(c, b) ? We(this.T, a).apply(c.j().M(b)) : null;
    };
    h.sc = function(a) {
        return Ue(this.T, a);
    };
    h.me = function(a, b, c, d, e, f) {
        var g;
        a = We(this.T, a);
        g = Ue(a, F);
        if (null == g) if (null != b) g = a.apply(b); else return [];
        g = g.mb(f);
        if (g.e() || g.N()) return [];
        b = [];
        a = ud(f);
        e = e ? g.Zb(c, f) : g.Xb(c, f);
        for (f = H(e); f && b.length < d; ) 0 !== a(f, c) && b.push(f), f = H(e);
        return b;
    };
    function Ze(a, b) {
        return a.Ia ? a.path.contains(b) : !!ua(a.children, function(c, d) {
            return a.path.w(d).contains(b);
        });
    }
    function af(a) {
        return a.visible;
    }
    function $e(a, b, c) {
        for (var d = Re, e = 0; e < a.length; ++e) {
            var f = a[e];
            if (b(f)) {
                var g = f.path;
                if (f.Ia) c.contains(g) ? (g = N(c, g), d = Se(d, g, f.Ia)) : g.contains(c) && (g = N(g, c), 
                d = Se(d, F, f.Ia.oa(g))); else if (f.children) if (c.contains(g)) g = N(c, g), 
                d = Te(d, g, f.children); else {
                    if (g.contains(c)) if (g = N(g, c), g.e()) d = Te(d, F, f.children); else if (f = w(f.children, O(g))) f = f.oa(G(g)), 
                    d = Se(d, F, f);
                } else throw Hc("WriteRecord should have .snap or .children");
            }
        }
        return d;
    }
    function bf(a, b) {
        this.Mb = a;
        this.W = b;
    }
    h = bf.prototype;
    h.ua = function(a, b, c) {
        return this.W.ua(this.Mb, a, b, c);
    };
    h.xc = function(a) {
        return this.W.xc(this.Mb, a);
    };
    h.hd = function(a, b, c) {
        return this.W.hd(this.Mb, a, b, c);
    };
    h.sc = function(a) {
        return this.W.sc(this.Mb.w(a));
    };
    h.me = function(a, b, c, d, e) {
        return this.W.me(this.Mb, a, b, c, d, e);
    };
    h.Xa = function(a, b) {
        return this.W.Xa(this.Mb, a, b);
    };
    h.w = function(a) {
        return new bf(this.Mb.w(a), this.W);
    };
    function cf() {
        this.ya = {};
    }
    h = cf.prototype;
    h.e = function() {
        return wa(this.ya);
    };
    h.bb = function(a, b, c) {
        var d = a.source.Ib;
        if (null !== d) return d = w(this.ya, d), J(null != d, "SyncTree gave us an op for an invalid query."), 
        d.bb(a, b, c);
        var e = [];
        r(this.ya, function(d) {
            e = e.concat(d.bb(a, b, c));
        });
        return e;
    };
    h.Ob = function(a, b, c, d, e) {
        var f = a.wa(), g = w(this.ya, f);
        if (!g) {
            var g = c.ua(e ? d : null), k = !1;
            g ? k = !0 : (g = d instanceof T ? c.xc(d) : C, k = !1);
            g = new te(a, new Id(new sb(g, k, !1), new sb(d, e, !1)));
            this.ya[f] = g;
        }
        g.Ob(b);
        return we(g, b);
    };
    h.kb = function(a, b, c) {
        var d = a.wa(), e = [], f = [], g = null != df(this);
        if ("default" === d) {
            var k = this;
            r(this.ya, function(a, d) {
                f = f.concat(a.kb(b, c));
                a.e() && (delete k.ya[d], de(a.V.n) || e.push(a.V));
            });
        } else {
            var l = w(this.ya, d);
            l && (f = f.concat(l.kb(b, c)), l.e() && (delete this.ya[d], de(l.V.n) || e.push(l.V)));
        }
        g && null == df(this) && e.push(new U(a.k, a.path));
        return {
            Hg: e,
            jg: f
        };
    };
    function ef(a) {
        return Pa(ra(a.ya), function(a) {
            return !de(a.V.n);
        });
    }
    h.hb = function(a) {
        var b = null;
        r(this.ya, function(c) {
            b = b || c.hb(a);
        });
        return b;
    };
    function ff(a, b) {
        if (de(b.n)) return df(a);
        var c = b.wa();
        return w(a.ya, c);
    }
    function df(a) {
        return va(a.ya, function(a) {
            return de(a.V.n);
        }) || null;
    }
    function gf(a) {
        this.sa = Nd;
        this.Hb = new Ye();
        this.$e = {};
        this.kc = {};
        this.Mc = a;
    }
    function hf(a, b, c, d, e) {
        var f = a.Hb, g = e;
        J(d > f.Lc, "Stacking an older write on top of newer ones");
        n(g) || (g = !0);
        f.za.push({
            path: b,
            Ia: c,
            ie: d,
            visible: g
        });
        g && (f.T = Se(f.T, b, c));
        f.Lc = d;
        return e ? jf(a, new Ub(Yb, b, c)) : [];
    }
    function kf(a, b, c, d) {
        var e = a.Hb;
        J(d > e.Lc, "Stacking an older merge on top of newer ones");
        e.za.push({
            path: b,
            children: c,
            ie: d,
            visible: !0
        });
        e.T = Te(e.T, b, c);
        e.Lc = d;
        c = Fe(c);
        return jf(a, new xe(Yb, b, c));
    }
    function lf(a, b, c) {
        c = c || !1;
        b = a.Hb.Od(b);
        return null == b ? [] : jf(a, new Wb(b, c));
    }
    function mf(a, b, c) {
        c = Fe(c);
        return jf(a, new xe(ze, b, c));
    }
    function nf(a, b, c, d) {
        d = of(a, d);
        if (null != d) {
            var e = pf(d);
            d = e.path;
            e = e.Ib;
            b = N(d, b);
            c = new Ub(new ye(!1, !0, e, !0), b, c);
            return qf(a, d, c);
        }
        return [];
    }
    function rf(a, b, c, d) {
        if (d = of(a, d)) {
            var e = pf(d);
            d = e.path;
            e = e.Ib;
            b = N(d, b);
            c = Fe(c);
            c = new xe(new ye(!1, !0, e, !0), b, c);
            return qf(a, d, c);
        }
        return [];
    }
    gf.prototype.Ob = function(a, b) {
        var c = a.path, d = null, e = !1;
        Me(this.sa, c, function(a, b) {
            var f = N(a, c);
            d = b.hb(f);
            e = e || null != df(b);
            return !d;
        });
        var f = this.sa.get(c);
        f ? (e = e || null != df(f), d = d || f.hb(F)) : (f = new cf(), this.sa = this.sa.set(c, f));
        var g;
        null != d ? g = !0 : (g = !1, d = C, Pe(this.sa.subtree(c), function(a, b) {
            var c = b.hb(F);
            c && (d = d.Q(a, c));
        }));
        var k = null != ff(f, a);
        if (!k && !de(a.n)) {
            var l = sf(a);
            J(!(l in this.kc), "View does not exist, but we have a tag");
            var m = tf++;
            this.kc[l] = m;
            this.$e["_" + m] = l;
        }
        g = f.Ob(a, b, new bf(c, this.Hb), d, g);
        k || e || (f = ff(f, a), g = g.concat(uf(this, a, f)));
        return g;
    };
    gf.prototype.kb = function(a, b, c) {
        var d = a.path, e = this.sa.get(d), f = [];
        if (e && ("default" === a.wa() || null != ff(e, a))) {
            f = e.kb(a, b, c);
            e.e() && (this.sa = this.sa.remove(d));
            e = f.Hg;
            f = f.jg;
            b = -1 !== Ua(e, function(a) {
                return de(a.n);
            });
            var g = Ke(this.sa, d, function(a, b) {
                return null != df(b);
            });
            if (b && !g && (d = this.sa.subtree(d), !d.e())) for (var d = vf(d), k = 0; k < d.length; ++k) {
                var l = d[k], m = l.V, l = wf(this, l);
                this.Mc.Xe(m, xf(this, m), l.ud, l.J);
            }
            if (!g && 0 < e.length && !c) if (b) this.Mc.Zd(a, null); else {
                var v = this;
                Oa(e, function(a) {
                    a.wa();
                    var b = v.kc[sf(a)];
                    v.Mc.Zd(a, b);
                });
            }
            yf(this, e);
        }
        return f;
    };
    gf.prototype.ua = function(a, b) {
        var c = this.Hb, d = Ke(this.sa, a, function(b, c) {
            var d = N(b, a);
            if (d = c.hb(d)) return d;
        });
        return c.ua(a, d, b, !0);
    };
    function vf(a) {
        return Ie(a, function(a, c, d) {
            if (c && null != df(c)) return [ df(c) ];
            var e = [];
            c && (e = ef(c));
            r(d, function(a) {
                e = e.concat(a);
            });
            return e;
        });
    }
    function yf(a, b) {
        for (var c = 0; c < b.length; ++c) {
            var d = b[c];
            if (!de(d.n)) {
                var d = sf(d), e = a.kc[d];
                delete a.kc[d];
                delete a.$e["_" + e];
            }
        }
    }
    function uf(a, b, c) {
        var d = b.path, e = xf(a, b);
        c = wf(a, c);
        b = a.Mc.Xe(b, e, c.ud, c.J);
        d = a.sa.subtree(d);
        if (e) J(null == df(d.value), "If we're adding a query, it shouldn't be shadowed"); else for (e = Ie(d, function(a, b, c) {
            if (!a.e() && b && null != df(b)) return [ ue(df(b)) ];
            var d = [];
            b && (d = d.concat(Qa(ef(b), function(a) {
                return a.V;
            })));
            r(c, function(a) {
                d = d.concat(a);
            });
            return d;
        }), d = 0; d < e.length; ++d) c = e[d], a.Mc.Zd(c, xf(a, c));
        return b;
    }
    function wf(a, b) {
        var c = b.V, d = xf(a, c);
        return {
            ud: function() {
                return (b.u() || C).hash();
            },
            J: function(b) {
                if ("ok" === b) {
                    if (d) {
                        var f = c.path;
                        if (b = of(a, d)) {
                            var g = pf(b);
                            b = g.path;
                            g = g.Ib;
                            f = N(b, f);
                            f = new Zb(new ye(!1, !0, g, !0), f);
                            b = qf(a, b, f);
                        } else b = [];
                    } else b = jf(a, new Zb(ze, c.path));
                    return b;
                }
                f = "Unknown Error";
                "too_big" === b ? f = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" == b ? f = "Client doesn't have permission to access the desired data." : "unavailable" == b && (f = "The service is unavailable");
                f = Error(b + ": " + f);
                f.code = b.toUpperCase();
                return a.kb(c, null, f);
            }
        };
    }
    function sf(a) {
        return a.path.toString() + "$" + a.wa();
    }
    function pf(a) {
        var b = a.indexOf("$");
        J(-1 !== b && b < a.length - 1, "Bad queryKey.");
        return {
            Ib: a.substr(b + 1),
            path: new K(a.substr(0, b))
        };
    }
    function of(a, b) {
        var c = a.$e, d = "_" + b;
        return d in c ? c[d] : void 0;
    }
    function xf(a, b) {
        var c = sf(b);
        return w(a.kc, c);
    }
    var tf = 1;
    function qf(a, b, c) {
        var d = a.sa.get(b);
        J(d, "Missing sync point for query tag that we're tracking");
        return d.bb(c, new bf(b, a.Hb), null);
    }
    function jf(a, b) {
        return zf(a, b, a.sa, null, new bf(F, a.Hb));
    }
    function zf(a, b, c, d, e) {
        if (b.path.e()) return Af(a, b, c, d, e);
        var f = c.get(F);
        null == d && null != f && (d = f.hb(F));
        var g = [], k = O(b.path), l = b.Wc(k);
        if ((c = c.children.get(k)) && l) var m = d ? d.M(k) : null, k = e.w(k), g = g.concat(zf(a, l, c, m, k));
        f && (g = g.concat(f.bb(b, e, d)));
        return g;
    }
    function Af(a, b, c, d, e) {
        var f = c.get(F);
        null == d && null != f && (d = f.hb(F));
        var g = [];
        c.children.ha(function(c, f) {
            var m = d ? d.M(c) : null, v = e.w(c), y = b.Wc(c);
            y && (g = g.concat(Af(a, y, f, m, v)));
        });
        f && (g = g.concat(f.bb(b, e, d)));
        return g;
    }
    function Bf() {
        this.children = {};
        this.kd = 0;
        this.value = null;
    }
    function Cf(a, b, c) {
        this.Dd = a ? a : "";
        this.Yc = b ? b : null;
        this.B = c ? c : new Bf();
    }
    function Df(a, b) {
        for (var c = b instanceof K ? b : new K(b), d = a, e; null !== (e = O(c)); ) d = new Cf(e, d, w(d.B.children, e) || new Bf()), 
        c = G(c);
        return d;
    }
    h = Cf.prototype;
    h.Ba = function() {
        return this.B.value;
    };
    function Ef(a, b) {
        J("undefined" !== typeof b, "Cannot set value to undefined");
        a.B.value = b;
        Ff(a);
    }
    h.clear = function() {
        this.B.value = null;
        this.B.children = {};
        this.B.kd = 0;
        Ff(this);
    };
    h.td = function() {
        return 0 < this.B.kd;
    };
    h.e = function() {
        return null === this.Ba() && !this.td();
    };
    h.U = function(a) {
        var b = this;
        r(this.B.children, function(c, d) {
            a(new Cf(d, b, c));
        });
    };
    function Gf(a, b, c, d) {
        c && !d && b(a);
        a.U(function(a) {
            Gf(a, b, !0, d);
        });
        c && d && b(a);
    }
    function Hf(a, b) {
        for (var c = a.parent(); null !== c && !b(c); ) c = c.parent();
    }
    h.path = function() {
        return new K(null === this.Yc ? this.Dd : this.Yc.path() + "/" + this.Dd);
    };
    h.name = function() {
        return this.Dd;
    };
    h.parent = function() {
        return this.Yc;
    };
    function Ff(a) {
        if (null !== a.Yc) {
            var b = a.Yc, c = a.Dd, d = a.e(), e = u(b.B.children, c);
            d && e ? (delete b.B.children[c], b.B.kd--, Ff(b)) : d || e || (b.B.children[c] = a.B, 
            b.B.kd++, Ff(b));
        }
    }
    function If(a) {
        J(ea(a) && 0 < a.length, "Requires a non-empty array");
        this.Uf = a;
        this.Nc = {};
    }
    If.prototype.de = function(a, b) {
        for (var c = this.Nc[a] || [], d = 0; d < c.length; d++) c[d].yc.apply(c[d].Ma, Array.prototype.slice.call(arguments, 1));
    };
    If.prototype.Eb = function(a, b, c) {
        Jf(this, a);
        this.Nc[a] = this.Nc[a] || [];
        this.Nc[a].push({
            yc: b,
            Ma: c
        });
        (a = this.ze(a)) && b.apply(c, a);
    };
    If.prototype.gc = function(a, b, c) {
        Jf(this, a);
        a = this.Nc[a] || [];
        for (var d = 0; d < a.length; d++) if (a[d].yc === b && (!c || c === a[d].Ma)) {
            a.splice(d, 1);
            break;
        }
    };
    function Jf(a, b) {
        J(Ta(a.Uf, function(a) {
            return a === b;
        }), "Unknown event: " + b);
    }
    var Kf = function() {
        var a = 0, b = [];
        return function(c) {
            var d = c === a;
            a = c;
            for (var e = Array(8), f = 7; 0 <= f; f--) e[f] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c % 64), 
            c = Math.floor(c / 64);
            J(0 === c, "Cannot push at time == 0");
            c = e.join("");
            if (d) {
                for (f = 11; 0 <= f && 63 === b[f]; f--) b[f] = 0;
                b[f]++;
            } else for (f = 0; 12 > f; f++) b[f] = Math.floor(64 * Math.random());
            for (f = 0; 12 > f; f++) c += "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);
            J(20 === c.length, "nextPushId: Length should be 20.");
            return c;
        };
    }();
    function Lf() {
        If.call(this, [ "online" ]);
        this.ic = !0;
        if ("undefined" !== typeof window && "undefined" !== typeof window.addEventListener) {
            var a = this;
            window.addEventListener("online", function() {
                a.ic || (a.ic = !0, a.de("online", !0));
            }, !1);
            window.addEventListener("offline", function() {
                a.ic && (a.ic = !1, a.de("online", !1));
            }, !1);
        }
    }
    ma(Lf, If);
    Lf.prototype.ze = function(a) {
        J("online" === a, "Unknown event type: " + a);
        return [ this.ic ];
    };
    ca(Lf);
    function Mf() {
        If.call(this, [ "visible" ]);
        var a, b;
        "undefined" !== typeof document && "undefined" !== typeof document.addEventListener && ("undefined" !== typeof document.hidden ? (b = "visibilitychange", 
        a = "hidden") : "undefined" !== typeof document.mozHidden ? (b = "mozvisibilitychange", 
        a = "mozHidden") : "undefined" !== typeof document.msHidden ? (b = "msvisibilitychange", 
        a = "msHidden") : "undefined" !== typeof document.webkitHidden && (b = "webkitvisibilitychange", 
        a = "webkitHidden"));
        this.uc = !0;
        if (b) {
            var c = this;
            document.addEventListener(b, function() {
                var b = !document[a];
                b !== c.uc && (c.uc = b, c.de("visible", b));
            }, !1);
        }
    }
    ma(Mf, If);
    Mf.prototype.ze = function(a) {
        J("visible" === a, "Unknown event type: " + a);
        return [ this.uc ];
    };
    ca(Mf);
    var Nf = /[\[\].#$\/\u0000-\u001F\u007F]/, Of = /[\[\].#$\u0000-\u001F\u007F]/;
    function Pf(a) {
        return p(a) && 0 !== a.length && !Nf.test(a);
    }
    function Qf(a) {
        return null === a || p(a) || ga(a) && !Sc(a) || ia(a) && u(a, ".sv");
    }
    function Rf(a, b, c, d) {
        d && !n(b) || Sf(z(a, 1, d), b, c);
    }
    function Sf(a, b, c) {
        c instanceof K && (c = new wc(c, a));
        if (!n(b)) throw Error(a + "contains undefined " + zc(c));
        if (ha(b)) throw Error(a + "contains a function " + zc(c) + " with contents: " + b.toString());
        if (Sc(b)) throw Error(a + "contains " + b.toString() + " " + zc(c));
        if (p(b) && b.length > 10485760 / 3 && 10485760 < xc(b)) throw Error(a + "contains a string greater than 10485760 utf8 bytes " + zc(c) + " ('" + b.substring(0, 50) + "...')");
        if (ia(b)) {
            var d = !1, e = !1;
            hb(b, function(b, g) {
                if (".value" === b) d = !0; else if (".priority" !== b && ".sv" !== b && (e = !0, 
                !Pf(b))) throw Error(a + " contains an invalid key (" + b + ") " + zc(c) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
                c.push(b);
                Sf(a, g, c);
                c.pop();
            });
            if (d && e) throw Error(a + ' contains ".value" child ' + zc(c) + " in addition to actual children.");
        }
    }
    function Tf(a, b, c) {
        if (!ia(b) || ea(b)) throw Error(z(a, 1, !1) + " must be an Object containing the children to replace.");
        if (u(b, ".value")) throw Error(z(a, 1, !1) + ' must not contain ".value".  To overwrite with a leaf value, just use .set() instead.');
        Rf(a, b, c, !1);
    }
    function Uf(a, b, c) {
        if (Sc(c)) throw Error(z(a, b, !1) + "is " + c.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
        if (!Qf(c)) throw Error(z(a, b, !1) + "must be a valid Firebase priority (a string, finite number, server value, or null).");
    }
    function Vf(a, b, c) {
        if (!c || n(b)) switch (b) {
          case "value":
          case "child_added":
          case "child_removed":
          case "child_changed":
          case "child_moved":
            break;

          default:
            throw Error(z(a, 1, c) + 'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');
        }
    }
    function Wf(a, b, c, d) {
        if ((!d || n(c)) && !Pf(c)) throw Error(z(a, b, d) + 'was an invalid key: "' + c + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');
    }
    function Xf(a, b) {
        if (!p(b) || 0 === b.length || Of.test(b)) throw Error(z(a, 1, !1) + 'was an invalid path: "' + b + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');
    }
    function Yf(a, b) {
        if (".info" === O(b)) throw Error(a + " failed: Can't modify data under /.info/");
    }
    function Zf(a, b) {
        if (!p(b)) throw Error(z(a, 1, !1) + "must be a valid credential (a string).");
    }
    function $f(a, b, c) {
        if (!p(c)) throw Error(z(a, b, !1) + "must be a valid string.");
    }
    function ag(a, b, c, d) {
        if (!d || n(c)) if (!ia(c) || null === c) throw Error(z(a, b, d) + "must be a valid object.");
    }
    function bg(a, b, c) {
        if (!ia(b) || null === b || !u(b, c)) throw Error(z(a, 1, !1) + 'must contain the key "' + c + '"');
        if (!p(w(b, c))) throw Error(z(a, 1, !1) + 'must contain the key "' + c + '" with type "string"');
    }
    function cg() {
        this.set = {};
    }
    h = cg.prototype;
    h.add = function(a, b) {
        this.set[a] = null !== b ? b : !0;
    };
    h.contains = function(a) {
        return u(this.set, a);
    };
    h.get = function(a) {
        return this.contains(a) ? this.set[a] : void 0;
    };
    h.remove = function(a) {
        delete this.set[a];
    };
    h.clear = function() {
        this.set = {};
    };
    h.e = function() {
        return wa(this.set);
    };
    h.count = function() {
        return pa(this.set);
    };
    function dg(a, b) {
        r(a.set, function(a, d) {
            b(d, a);
        });
    }
    h.keys = function() {
        var a = [];
        r(this.set, function(b, c) {
            a.push(c);
        });
        return a;
    };
    function qc() {
        this.m = this.C = null;
    }
    qc.prototype.find = function(a) {
        if (null != this.C) return this.C.oa(a);
        if (a.e() || null == this.m) return null;
        var b = O(a);
        a = G(a);
        return this.m.contains(b) ? this.m.get(b).find(a) : null;
    };
    qc.prototype.mc = function(a, b) {
        if (a.e()) this.C = b, this.m = null; else if (null !== this.C) this.C = this.C.G(a, b); else {
            null == this.m && (this.m = new cg());
            var c = O(a);
            this.m.contains(c) || this.m.add(c, new qc());
            c = this.m.get(c);
            a = G(a);
            c.mc(a, b);
        }
    };
    function eg(a, b) {
        if (b.e()) return a.C = null, a.m = null, !0;
        if (null !== a.C) {
            if (a.C.N()) return !1;
            var c = a.C;
            a.C = null;
            c.U(M, function(b, c) {
                a.mc(new K(b), c);
            });
            return eg(a, b);
        }
        return null !== a.m ? (c = O(b), b = G(b), a.m.contains(c) && eg(a.m.get(c), b) && a.m.remove(c), 
        a.m.e() ? (a.m = null, !0) : !1) : !0;
    }
    function rc(a, b, c) {
        null !== a.C ? c(b, a.C) : a.U(function(a, e) {
            var f = new K(b.toString() + "/" + a);
            rc(e, f, c);
        });
    }
    qc.prototype.U = function(a) {
        null !== this.m && dg(this.m, function(b, c) {
            a(b, c);
        });
    };
    var fg = "auth.firebase.com";
    function gg(a, b, c) {
        this.ld = a || {};
        this.ce = b || {};
        this.ab = c || {};
        this.ld.remember || (this.ld.remember = "default");
    }
    var hg = [ "remember", "redirectTo" ];
    function ig(a) {
        var b = {}, c = {};
        hb(a || {}, function(a, e) {
            0 <= Na(hg, a) ? b[a] = e : c[a] = e;
        });
        return new gg(b, {}, c);
    }
    function jg(a, b) {
        this.Pe = [ "session", a.Ld, a.Cb ].join(":");
        this.$d = b;
    }
    jg.prototype.set = function(a, b) {
        if (!b) if (this.$d.length) b = this.$d[0]; else throw Error("fb.login.SessionManager : No storage options available!");
        b.set(this.Pe, a);
    };
    jg.prototype.get = function() {
        var a = Qa(this.$d, q(this.ng, this)), a = Pa(a, function(a) {
            return null !== a;
        });
        Xa(a, function(a, c) {
            return bd(c.token) - bd(a.token);
        });
        return 0 < a.length ? a.shift() : null;
    };
    jg.prototype.ng = function(a) {
        try {
            var b = a.get(this.Pe);
            if (b && b.token) return b;
        } catch (c) {}
        return null;
    };
    jg.prototype.clear = function() {
        var a = this;
        Oa(this.$d, function(b) {
            b.remove(a.Pe);
        });
    };
    function kg() {
        return "undefined" !== typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(navigator.userAgent);
    }
    function lg() {
        return "undefined" !== typeof location && /^file:\//.test(location.href);
    }
    function mg() {
        if ("undefined" === typeof navigator) return !1;
        var a = navigator.userAgent;
        if ("Microsoft Internet Explorer" === navigator.appName) {
            if ((a = a.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/)) && 1 < a.length) return 8 <= parseFloat(a[1]);
        } else if (-1 < a.indexOf("Trident") && (a = a.match(/rv:([0-9]{2,2}[\.0-9]{0,})/)) && 1 < a.length) return 8 <= parseFloat(a[1]);
        return !1;
    }
    function ng() {
        var a = window.opener.frames, b;
        for (b = a.length - 1; 0 <= b; b--) try {
            if (a[b].location.protocol === window.location.protocol && a[b].location.host === window.location.host && "__winchan_relay_frame" === a[b].name) return a[b];
        } catch (c) {}
        return null;
    }
    function og(a, b, c) {
        a.attachEvent ? a.attachEvent("on" + b, c) : a.addEventListener && a.addEventListener(b, c, !1);
    }
    function pg(a, b, c) {
        a.detachEvent ? a.detachEvent("on" + b, c) : a.removeEventListener && a.removeEventListener(b, c, !1);
    }
    function qg(a) {
        /^https?:\/\//.test(a) || (a = window.location.href);
        var b = /^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);
        return b ? b[1] : a;
    }
    function rg(a) {
        var b = "";
        try {
            a = a.replace("#", "");
            var c = kb(a);
            c && u(c, "__firebase_request_key") && (b = w(c, "__firebase_request_key"));
        } catch (d) {}
        return b;
    }
    function sg() {
        var a = Rc(fg);
        return a.scheme + "://" + a.host + "/v2";
    }
    function tg(a) {
        return sg() + "/" + a + "/auth/channel";
    }
    function ug(a) {
        var b = this;
        this.zc = a;
        this.ae = "*";
        mg() ? this.Qc = this.wd = ng() : (this.Qc = window.opener, this.wd = window);
        if (!b.Qc) throw "Unable to find relay frame";
        og(this.wd, "message", q(this.hc, this));
        og(this.wd, "message", q(this.Af, this));
        try {
            vg(this, {
                a: "ready"
            });
        } catch (c) {
            og(this.Qc, "load", function() {
                vg(b, {
                    a: "ready"
                });
            });
        }
        og(window, "unload", q(this.yg, this));
    }
    function vg(a, b) {
        b = B(b);
        mg() ? a.Qc.doPost(b, a.ae) : a.Qc.postMessage(b, a.ae);
    }
    ug.prototype.hc = function(a) {
        var b = this, c;
        try {
            c = mb(a.data);
        } catch (d) {}
        c && "request" === c.a && (pg(window, "message", this.hc), this.ae = a.origin, this.zc && setTimeout(function() {
            b.zc(b.ae, c.d, function(a, c) {
                b.ag = !c;
                b.zc = void 0;
                vg(b, {
                    a: "response",
                    d: a,
                    forceKeepWindowOpen: c
                });
            });
        }, 0));
    };
    ug.prototype.yg = function() {
        try {
            pg(this.wd, "message", this.Af);
        } catch (a) {}
        this.zc && (vg(this, {
            a: "error",
            d: "unknown closed window"
        }), this.zc = void 0);
        try {
            window.close();
        } catch (b) {}
    };
    ug.prototype.Af = function(a) {
        if (this.ag && "die" === a.data) try {
            window.close();
        } catch (b) {}
    };
    function wg(a) {
        this.oc = Ga() + Ga() + Ga();
        this.Df = a;
    }
    wg.prototype.open = function(a, b) {
        P.set("redirect_request_id", this.oc);
        P.set("redirect_request_id", this.oc);
        b.requestId = this.oc;
        b.redirectTo = b.redirectTo || window.location.href;
        a += (/\?/.test(a) ? "" : "?") + jb(b);
        window.location = a;
    };
    wg.isAvailable = function() {
        return !lg() && !kg();
    };
    wg.prototype.Bc = function() {
        return "redirect";
    };
    var xg = {
        NETWORK_ERROR: "Unable to contact the Firebase server.",
        SERVER_ERROR: "An unknown server error occurred.",
        TRANSPORT_UNAVAILABLE: "There are no login transports available for the requested method.",
        REQUEST_INTERRUPTED: "The browser redirected the page before the login request could complete.",
        USER_CANCELLED: "The user cancelled authentication."
    };
    function yg(a) {
        var b = Error(w(xg, a), a);
        b.code = a;
        return b;
    }
    function zg(a) {
        if (!a.window_features || "undefined" !== typeof navigator && (-1 !== navigator.userAgent.indexOf("Fennec/") || -1 !== navigator.userAgent.indexOf("Firefox/") && -1 !== navigator.userAgent.indexOf("Android"))) a.window_features = void 0;
        a.window_name || (a.window_name = "_blank");
        this.options = a;
    }
    zg.prototype.open = function(a, b, c) {
        function d(a) {
            g && (document.body.removeChild(g), g = void 0);
            v && (v = clearInterval(v));
            pg(window, "message", e);
            pg(window, "unload", d);
            if (m && !a) try {
                m.close();
            } catch (b) {
                k.postMessage("die", l);
            }
            m = k = void 0;
        }
        function e(a) {
            if (a.origin === l) try {
                var b = mb(a.data);
                "ready" === b.a ? k.postMessage(y, l) : "error" === b.a ? (d(!1), c && (c(b.d), 
                c = null)) : "response" === b.a && (d(b.forceKeepWindowOpen), c && (c(null, b.d), 
                c = null));
            } catch (e) {}
        }
        var f = mg(), g, k;
        if (!this.options.relay_url) return c(Error("invalid arguments: origin of url and relay_url must match"));
        var l = qg(a);
        if (l !== qg(this.options.relay_url)) c && setTimeout(function() {
            c(Error("invalid arguments: origin of url and relay_url must match"));
        }, 0); else {
            f && (g = document.createElement("iframe"), g.setAttribute("src", this.options.relay_url), 
            g.style.display = "none", g.setAttribute("name", "__winchan_relay_frame"), document.body.appendChild(g), 
            k = g.contentWindow);
            a += (/\?/.test(a) ? "" : "?") + jb(b);
            var m = window.open(a, this.options.window_name, this.options.window_features);
            k || (k = m);
            var v = setInterval(function() {
                m && m.closed && (d(!1), c && (c(yg("USER_CANCELLED")), c = null));
            }, 500), y = B({
                a: "request",
                d: b
            });
            og(window, "unload", d);
            og(window, "message", e);
        }
    };
    zg.isAvailable = function() {
        return "postMessage" in window && !lg() && !(kg() || "undefined" !== typeof navigator && (navigator.userAgent.match(/Windows Phone/) || window.Windows && /^ms-appx:/.test(location.href)) || "undefined" !== typeof navigator && "undefined" !== typeof window && (navigator.userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i) || navigator.userAgent.match(/CriOS/) || navigator.userAgent.match(/Twitter for iPhone/) || navigator.userAgent.match(/FBAN\/FBIOS/) || window.navigator.standalone)) && !("undefined" !== typeof navigator && navigator.userAgent.match(/PhantomJS/));
    };
    zg.prototype.Bc = function() {
        return "popup";
    };
    function Ag(a) {
        a.method || (a.method = "GET");
        a.headers || (a.headers = {});
        a.headers.content_type || (a.headers.content_type = "application/json");
        a.headers.content_type = a.headers.content_type.toLowerCase();
        this.options = a;
    }
    Ag.prototype.open = function(a, b, c) {
        function d() {
            c && (c(yg("REQUEST_INTERRUPTED")), c = null);
        }
        var e = new XMLHttpRequest(), f = this.options.method.toUpperCase(), g;
        og(window, "beforeunload", d);
        e.onreadystatechange = function() {
            if (c && 4 === e.readyState) {
                var a;
                if (200 <= e.status && 300 > e.status) {
                    try {
                        a = mb(e.responseText);
                    } catch (b) {}
                    c(null, a);
                } else 500 <= e.status && 600 > e.status ? c(yg("SERVER_ERROR")) : c(yg("NETWORK_ERROR"));
                c = null;
                pg(window, "beforeunload", d);
            }
        };
        if ("GET" === f) a += (/\?/.test(a) ? "" : "?") + jb(b), g = null; else {
            var k = this.options.headers.content_type;
            "application/json" === k && (g = B(b));
            "application/x-www-form-urlencoded" === k && (g = jb(b));
        }
        e.open(f, a, !0);
        a = {
            "X-Requested-With": "XMLHttpRequest",
            Accept: "application/json;text/plain"
        };
        za(a, this.options.headers);
        for (var l in a) e.setRequestHeader(l, a[l]);
        e.send(g);
    };
    Ag.isAvailable = function() {
        return !!window.XMLHttpRequest && "string" === typeof new XMLHttpRequest().responseType && (!("undefined" !== typeof navigator && (navigator.userAgent.match(/MSIE/) || navigator.userAgent.match(/Trident/))) || mg());
    };
    Ag.prototype.Bc = function() {
        return "json";
    };
    function Bg(a) {
        this.oc = Ga() + Ga() + Ga();
        this.Df = a;
    }
    Bg.prototype.open = function(a, b, c) {
        function d() {
            c && (c(yg("USER_CANCELLED")), c = null);
        }
        var e = this, f = Rc(fg), g;
        b.requestId = this.oc;
        b.redirectTo = f.scheme + "://" + f.host + "/blank/page.html";
        a += /\?/.test(a) ? "" : "?";
        a += jb(b);
        (g = window.open(a, "_blank", "location=no")) && ha(g.addEventListener) ? (g.addEventListener("loadstart", function(a) {
            var b;
            if (b = a && a.url) a: {
                try {
                    var m = document.createElement("a");
                    m.href = a.url;
                    b = m.host === f.host && "/blank/page.html" === m.pathname;
                    break a;
                } catch (v) {}
                b = !1;
            }
            b && (a = rg(a.url), g.removeEventListener("exit", d), g.close(), a = new gg(null, null, {
                requestId: e.oc,
                requestKey: a
            }), e.Df.requestWithCredential("/auth/session", a, c), c = null);
        }), g.addEventListener("exit", d)) : c(yg("TRANSPORT_UNAVAILABLE"));
    };
    Bg.isAvailable = function() {
        return kg();
    };
    Bg.prototype.Bc = function() {
        return "redirect";
    };
    function Cg(a) {
        a.callback_parameter || (a.callback_parameter = "callback");
        this.options = a;
        window.__firebase_auth_jsonp = window.__firebase_auth_jsonp || {};
    }
    Cg.prototype.open = function(a, b, c) {
        function d() {
            c && (c(yg("REQUEST_INTERRUPTED")), c = null);
        }
        function e() {
            setTimeout(function() {
                window.__firebase_auth_jsonp[f] = void 0;
                wa(window.__firebase_auth_jsonp) && (window.__firebase_auth_jsonp = void 0);
                try {
                    var a = document.getElementById(f);
                    a && a.parentNode.removeChild(a);
                } catch (b) {}
            }, 1);
            pg(window, "beforeunload", d);
        }
        var f = "fn" + new Date().getTime() + Math.floor(99999 * Math.random());
        b[this.options.callback_parameter] = "__firebase_auth_jsonp." + f;
        a += (/\?/.test(a) ? "" : "?") + jb(b);
        og(window, "beforeunload", d);
        window.__firebase_auth_jsonp[f] = function(a) {
            c && (c(null, a), c = null);
            e();
        };
        Dg(f, a, c);
    };
    function Dg(a, b, c) {
        setTimeout(function() {
            try {
                var d = document.createElement("script");
                d.type = "text/javascript";
                d.id = a;
                d.async = !0;
                d.src = b;
                d.onerror = function() {
                    var b = document.getElementById(a);
                    null !== b && b.parentNode.removeChild(b);
                    c && c(yg("NETWORK_ERROR"));
                };
                var e = document.getElementsByTagName("head");
                (e && 0 != e.length ? e[0] : document.documentElement).appendChild(d);
            } catch (f) {
                c && c(yg("NETWORK_ERROR"));
            }
        }, 0);
    }
    Cg.isAvailable = function() {
        return !0;
    };
    Cg.prototype.Bc = function() {
        return "json";
    };
    function Eg(a, b, c, d) {
        If.call(this, [ "auth_status" ]);
        this.H = a;
        this.df = b;
        this.Sg = c;
        this.Ke = d;
        this.rc = new jg(a, [ Dc, P ]);
        this.nb = null;
        this.Re = !1;
        Fg(this);
    }
    ma(Eg, If);
    h = Eg.prototype;
    h.we = function() {
        return this.nb || null;
    };
    function Fg(a) {
        P.get("redirect_request_id") && Gg(a);
        var b = a.rc.get();
        b && b.token ? (Hg(a, b), a.df(b.token, function(c, d) {
            Ig(a, c, d, !1, b.token, b);
        }, function(b, d) {
            Jg(a, "resumeSession()", b, d);
        })) : Hg(a, null);
    }
    function Kg(a, b, c, d, e, f) {
        "firebaseio-demo.com" === a.H.domain && Q("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");
        a.df(b, function(f, k) {
            Ig(a, f, k, !0, b, c, d || {}, e);
        }, function(b, c) {
            Jg(a, "auth()", b, c, f);
        });
    }
    function Lg(a, b) {
        a.rc.clear();
        Hg(a, null);
        a.Sg(function(a, d) {
            if ("ok" === a) R(b, null); else {
                var e = (a || "error").toUpperCase(), f = e;
                d && (f += ": " + d);
                f = Error(f);
                f.code = e;
                R(b, f);
            }
        });
    }
    function Ig(a, b, c, d, e, f, g, k) {
        "ok" === b ? (d && (b = c.auth, f.auth = b, f.expires = c.expires, f.token = cd(e) ? e : "", 
        c = null, b && u(b, "uid") ? c = w(b, "uid") : u(f, "uid") && (c = w(f, "uid")), 
        f.uid = c, c = "custom", b && u(b, "provider") ? c = w(b, "provider") : u(f, "provider") && (c = w(f, "provider")), 
        f.provider = c, a.rc.clear(), cd(e) && (g = g || {}, c = Dc, "sessionOnly" === g.remember && (c = P), 
        "none" !== g.remember && a.rc.set(f, c)), Hg(a, f)), R(k, null, f)) : (a.rc.clear(), 
        Hg(a, null), f = a = (b || "error").toUpperCase(), c && (f += ": " + c), f = Error(f), 
        f.code = a, R(k, f));
    }
    function Jg(a, b, c, d, e) {
        Q(b + " was canceled: " + d);
        a.rc.clear();
        Hg(a, null);
        a = Error(d);
        a.code = c.toUpperCase();
        R(e, a);
    }
    function Mg(a, b, c, d, e) {
        Ng(a);
        c = new gg(d || {}, {}, c || {});
        Og(a, [ Ag, Cg ], "/auth/" + b, c, e);
    }
    function Pg(a, b, c, d) {
        Ng(a);
        var e = [ zg, Bg ];
        c = ig(c);
        "anonymous" === b || "password" === b ? setTimeout(function() {
            R(d, yg("TRANSPORT_UNAVAILABLE"));
        }, 0) : (c.ce.window_features = "menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top=" + ("object" === typeof screen ? .5 * (screen.height - 625) : 0) + ",left=" + ("object" === typeof screen ? .5 * (screen.width - 625) : 0), 
        c.ce.relay_url = tg(a.H.Cb), c.ce.requestWithCredential = q(a.pc, a), Og(a, e, "/auth/" + b, c, d));
    }
    function Gg(a) {
        var b = P.get("redirect_request_id");
        if (b) {
            var c = P.get("redirect_client_options");
            P.remove("redirect_request_id");
            P.remove("redirect_client_options");
            var d = [ Ag, Cg ], b = {
                requestId: b,
                requestKey: rg(document.location.hash)
            }, c = new gg(c, {}, b);
            a.Re = !0;
            try {
                document.location.hash = document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/, "");
            } catch (e) {}
            Og(a, d, "/auth/session", c, function() {
                this.Re = !1;
            }.bind(a));
        }
    }
    h.re = function(a, b) {
        Ng(this);
        var c = ig(a);
        c.ab._method = "POST";
        this.pc("/users", c, function(a, c) {
            a ? R(b, a) : R(b, a, c);
        });
    };
    h.Se = function(a, b) {
        var c = this;
        Ng(this);
        var d = "/users/" + encodeURIComponent(a.email), e = ig(a);
        e.ab._method = "DELETE";
        this.pc(d, e, function(a, d) {
            !a && d && d.uid && c.nb && c.nb.uid && c.nb.uid === d.uid && Lg(c);
            R(b, a);
        });
    };
    h.oe = function(a, b) {
        Ng(this);
        var c = "/users/" + encodeURIComponent(a.email) + "/password", d = ig(a);
        d.ab._method = "PUT";
        d.ab.password = a.newPassword;
        this.pc(c, d, function(a) {
            R(b, a);
        });
    };
    h.ne = function(a, b) {
        Ng(this);
        var c = "/users/" + encodeURIComponent(a.oldEmail) + "/email", d = ig(a);
        d.ab._method = "PUT";
        d.ab.email = a.newEmail;
        d.ab.password = a.password;
        this.pc(c, d, function(a) {
            R(b, a);
        });
    };
    h.Ue = function(a, b) {
        Ng(this);
        var c = "/users/" + encodeURIComponent(a.email) + "/password", d = ig(a);
        d.ab._method = "POST";
        this.pc(c, d, function(a) {
            R(b, a);
        });
    };
    h.pc = function(a, b, c) {
        Qg(this, [ Ag, Cg ], a, b, c);
    };
    function Og(a, b, c, d, e) {
        Qg(a, b, c, d, function(b, c) {
            !b && c && c.token && c.uid ? Kg(a, c.token, c, d.ld, function(a, b) {
                a ? R(e, a) : R(e, null, b);
            }) : R(e, b || yg("UNKNOWN_ERROR"));
        });
    }
    function Qg(a, b, c, d, e) {
        b = Pa(b, function(a) {
            return "function" === typeof a.isAvailable && a.isAvailable();
        });
        0 === b.length ? setTimeout(function() {
            R(e, yg("TRANSPORT_UNAVAILABLE"));
        }, 0) : (b = new (b.shift())(d.ce), d = ib(d.ab), d.v = "js-2.2.4", d.transport = b.Bc(), 
        d.suppress_status_codes = !0, a = sg() + "/" + a.H.Cb + c, b.open(a, d, function(a, b) {
            if (a) R(e, a); else if (b && b.error) {
                var c = Error(b.error.message);
                c.code = b.error.code;
                c.details = b.error.details;
                R(e, c);
            } else R(e, null, b);
        }));
    }
    function Hg(a, b) {
        var c = null !== a.nb || null !== b;
        a.nb = b;
        c && a.de("auth_status", b);
        a.Ke(null !== b);
    }
    h.ze = function(a) {
        J("auth_status" === a, 'initial event must be of type "auth_status"');
        return this.Re ? null : [ this.nb ];
    };
    function Ng(a) {
        var b = a.H;
        if ("firebaseio.com" !== b.domain && "firebaseio-demo.com" !== b.domain && "auth.firebase.com" === fg) throw Error("This custom Firebase server ('" + a.H.domain + "') does not support delegated login.");
    }
    function Rg(a) {
        this.hc = a;
        this.Kd = [];
        this.Qb = 0;
        this.pe = -1;
        this.Fb = null;
    }
    function Sg(a, b, c) {
        a.pe = b;
        a.Fb = c;
        a.pe < a.Qb && (a.Fb(), a.Fb = null);
    }
    function Tg(a, b, c) {
        for (a.Kd[b] = c; a.Kd[a.Qb]; ) {
            var d = a.Kd[a.Qb];
            delete a.Kd[a.Qb];
            for (var e = 0; e < d.length; ++e) if (d[e]) {
                var f = a;
                Cb(function() {
                    f.hc(d[e]);
                });
            }
            if (a.Qb === a.pe) {
                a.Fb && (clearTimeout(a.Fb), a.Fb(), a.Fb = null);
                break;
            }
            a.Qb++;
        }
    }
    function Ug(a, b, c) {
        this.qe = a;
        this.f = Oc(a);
        this.ob = this.pb = 0;
        this.Va = Ob(b);
        this.Vd = c;
        this.Gc = !1;
        this.gd = function(a) {
            b.host !== b.Oa && (a.ns = b.Cb);
            var c = [], f;
            for (f in a) a.hasOwnProperty(f) && c.push(f + "=" + a[f]);
            return (b.lb ? "https://" : "http://") + b.Oa + "/.lp?" + c.join("&");
        };
    }
    var Vg, Wg;
    Ug.prototype.open = function(a, b) {
        this.gf = 0;
        this.ka = b;
        this.zf = new Rg(a);
        this.zb = !1;
        var c = this;
        this.rb = setTimeout(function() {
            c.f("Timed out trying to connect.");
            c.ib();
            c.rb = null;
        }, Math.floor(3e4));
        Tc(function() {
            if (!c.zb) {
                c.Ta = new Xg(function(a, b, d, k, l) {
                    Yg(c, arguments);
                    if (c.Ta) if (c.rb && (clearTimeout(c.rb), c.rb = null), c.Gc = !0, "start" == a) c.id = b, 
                    c.Ff = d; else if ("close" === a) b ? (c.Ta.Td = !1, Sg(c.zf, b, function() {
                        c.ib();
                    })) : c.ib(); else throw Error("Unrecognized command received: " + a);
                }, function(a, b) {
                    Yg(c, arguments);
                    Tg(c.zf, a, b);
                }, function() {
                    c.ib();
                }, c.gd);
                var a = {
                    start: "t"
                };
                a.ser = Math.floor(1e8 * Math.random());
                c.Ta.fe && (a.cb = c.Ta.fe);
                a.v = "5";
                c.Vd && (a.s = c.Vd);
                "undefined" !== typeof location && location.href && -1 !== location.href.indexOf("firebaseio.com") && (a.r = "f");
                a = c.gd(a);
                c.f("Connecting via long-poll to " + a);
                Zg(c.Ta, a, function() {});
            }
        });
    };
    Ug.prototype.start = function() {
        var a = this.Ta, b = this.Ff;
        a.rg = this.id;
        a.sg = b;
        for (a.ke = !0; $g(a); ) ;
        a = this.id;
        b = this.Ff;
        this.fc = document.createElement("iframe");
        var c = {
            dframe: "t"
        };
        c.id = a;
        c.pw = b;
        this.fc.src = this.gd(c);
        this.fc.style.display = "none";
        document.body.appendChild(this.fc);
    };
    Ug.isAvailable = function() {
        return !Wg && !("object" === typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href)) && !("object" === typeof Windows && "object" === typeof Windows.Ug) && (Vg || !0);
    };
    h = Ug.prototype;
    h.Bd = function() {};
    h.cd = function() {
        this.zb = !0;
        this.Ta && (this.Ta.close(), this.Ta = null);
        this.fc && (document.body.removeChild(this.fc), this.fc = null);
        this.rb && (clearTimeout(this.rb), this.rb = null);
    };
    h.ib = function() {
        this.zb || (this.f("Longpoll is closing itself"), this.cd(), this.ka && (this.ka(this.Gc), 
        this.ka = null));
    };
    h.close = function() {
        this.zb || (this.f("Longpoll is being closed."), this.cd());
    };
    h.send = function(a) {
        a = B(a);
        this.pb += a.length;
        Lb(this.Va, "bytes_sent", a.length);
        a = Kc(a);
        a = fb(a, !0);
        a = Xc(a, 1840);
        for (var b = 0; b < a.length; b++) {
            var c = this.Ta;
            c.$c.push({
                Jg: this.gf,
                Rg: a.length,
                jf: a[b]
            });
            c.ke && $g(c);
            this.gf++;
        }
    };
    function Yg(a, b) {
        var c = B(b).length;
        a.ob += c;
        Lb(a.Va, "bytes_received", c);
    }
    function Xg(a, b, c, d) {
        this.gd = d;
        this.jb = c;
        this.Oe = new cg();
        this.$c = [];
        this.se = Math.floor(1e8 * Math.random());
        this.Td = !0;
        this.fe = Gc();
        window["pLPCommand" + this.fe] = a;
        window["pRTLPCB" + this.fe] = b;
        a = document.createElement("iframe");
        a.style.display = "none";
        if (document.body) {
            document.body.appendChild(a);
            try {
                a.contentWindow.document || Bb("No IE domain setting required");
            } catch (e) {
                a.src = "javascript:void((function(){document.open();document.domain='" + document.domain + "';document.close();})())";
            }
        } else throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        a.contentDocument ? a.gb = a.contentDocument : a.contentWindow ? a.gb = a.contentWindow.document : a.document && (a.gb = a.document);
        this.Ca = a;
        a = "";
        this.Ca.src && "javascript:" === this.Ca.src.substr(0, 11) && (a = '<script>document.domain="' + document.domain + '";</script>');
        a = "<html><body>" + a + "</body></html>";
        try {
            this.Ca.gb.open(), this.Ca.gb.write(a), this.Ca.gb.close();
        } catch (f) {
            Bb("frame writing exception"), f.stack && Bb(f.stack), Bb(f);
        }
    }
    Xg.prototype.close = function() {
        this.ke = !1;
        if (this.Ca) {
            this.Ca.gb.body.innerHTML = "";
            var a = this;
            setTimeout(function() {
                null !== a.Ca && (document.body.removeChild(a.Ca), a.Ca = null);
            }, Math.floor(0));
        }
        var b = this.jb;
        b && (this.jb = null, b());
    };
    function $g(a) {
        if (a.ke && a.Td && a.Oe.count() < (0 < a.$c.length ? 2 : 1)) {
            a.se++;
            var b = {};
            b.id = a.rg;
            b.pw = a.sg;
            b.ser = a.se;
            for (var b = a.gd(b), c = "", d = 0; 0 < a.$c.length; ) if (1870 >= a.$c[0].jf.length + 30 + c.length) {
                var e = a.$c.shift(), c = c + "&seg" + d + "=" + e.Jg + "&ts" + d + "=" + e.Rg + "&d" + d + "=" + e.jf;
                d++;
            } else break;
            ah(a, b + c, a.se);
            return !0;
        }
        return !1;
    }
    function ah(a, b, c) {
        function d() {
            a.Oe.remove(c);
            $g(a);
        }
        a.Oe.add(c, 1);
        var e = setTimeout(d, Math.floor(25e3));
        Zg(a, b, function() {
            clearTimeout(e);
            d();
        });
    }
    function Zg(a, b, c) {
        setTimeout(function() {
            try {
                if (a.Td) {
                    var d = a.Ca.gb.createElement("script");
                    d.type = "text/javascript";
                    d.async = !0;
                    d.src = b;
                    d.onload = d.onreadystatechange = function() {
                        var a = d.readyState;
                        a && "loaded" !== a && "complete" !== a || (d.onload = d.onreadystatechange = null, 
                        d.parentNode && d.parentNode.removeChild(d), c());
                    };
                    d.onerror = function() {
                        Bb("Long-poll script failed to load: " + b);
                        a.Td = !1;
                        a.close();
                    };
                    a.Ca.gb.body.appendChild(d);
                }
            } catch (e) {}
        }, Math.floor(1));
    }
    var bh = null;
    "undefined" !== typeof MozWebSocket ? bh = MozWebSocket : "undefined" !== typeof WebSocket && (bh = WebSocket);
    function ch(a, b, c) {
        this.qe = a;
        this.f = Oc(this.qe);
        this.frames = this.Jc = null;
        this.ob = this.pb = this.bf = 0;
        this.Va = Ob(b);
        this.fb = (b.lb ? "wss://" : "ws://") + b.Oa + "/.ws?v=5";
        "undefined" !== typeof location && location.href && -1 !== location.href.indexOf("firebaseio.com") && (this.fb += "&r=f");
        b.host !== b.Oa && (this.fb = this.fb + "&ns=" + b.Cb);
        c && (this.fb = this.fb + "&s=" + c);
    }
    var dh;
    ch.prototype.open = function(a, b) {
        this.jb = b;
        this.wg = a;
        this.f("Websocket connecting to " + this.fb);
        this.Gc = !1;
        Dc.set("previous_websocket_failure", !0);
        try {
            this.va = new bh(this.fb);
        } catch (c) {
            this.f("Error instantiating WebSocket.");
            var d = c.message || c.data;
            d && this.f(d);
            this.ib();
            return;
        }
        var e = this;
        this.va.onopen = function() {
            e.f("Websocket connected.");
            e.Gc = !0;
        };
        this.va.onclose = function() {
            e.f("Websocket connection was disconnected.");
            e.va = null;
            e.ib();
        };
        this.va.onmessage = function(a) {
            if (null !== e.va) if (a = a.data, e.ob += a.length, Lb(e.Va, "bytes_received", a.length), 
            eh(e), null !== e.frames) fh(e, a); else {
                a: {
                    J(null === e.frames, "We already have a frame buffer");
                    if (6 >= a.length) {
                        var b = Number(a);
                        if (!isNaN(b)) {
                            e.bf = b;
                            e.frames = [];
                            a = null;
                            break a;
                        }
                    }
                    e.bf = 1;
                    e.frames = [];
                }
                null !== a && fh(e, a);
            }
        };
        this.va.onerror = function(a) {
            e.f("WebSocket error.  Closing connection.");
            (a = a.message || a.data) && e.f(a);
            e.ib();
        };
    };
    ch.prototype.start = function() {};
    ch.isAvailable = function() {
        var a = !1;
        if ("undefined" !== typeof navigator && navigator.userAgent) {
            var b = navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);
            b && 1 < b.length && 4.4 > parseFloat(b[1]) && (a = !0);
        }
        return !a && null !== bh && !dh;
    };
    ch.responsesRequiredToBeHealthy = 2;
    ch.healthyTimeout = 3e4;
    h = ch.prototype;
    h.Bd = function() {
        Dc.remove("previous_websocket_failure");
    };
    function fh(a, b) {
        a.frames.push(b);
        if (a.frames.length == a.bf) {
            var c = a.frames.join("");
            a.frames = null;
            c = mb(c);
            a.wg(c);
        }
    }
    h.send = function(a) {
        eh(this);
        a = B(a);
        this.pb += a.length;
        Lb(this.Va, "bytes_sent", a.length);
        a = Xc(a, 16384);
        1 < a.length && this.va.send(String(a.length));
        for (var b = 0; b < a.length; b++) this.va.send(a[b]);
    };
    h.cd = function() {
        this.zb = !0;
        this.Jc && (clearInterval(this.Jc), this.Jc = null);
        this.va && (this.va.close(), this.va = null);
    };
    h.ib = function() {
        this.zb || (this.f("WebSocket is closing itself"), this.cd(), this.jb && (this.jb(this.Gc), 
        this.jb = null));
    };
    h.close = function() {
        this.zb || (this.f("WebSocket is being closed"), this.cd());
    };
    function eh(a) {
        clearInterval(a.Jc);
        a.Jc = setInterval(function() {
            a.va && a.va.send("0");
            eh(a);
        }, Math.floor(45e3));
    }
    function gh(a) {
        hh(this, a);
    }
    var ih = [ Ug, ch ];
    function hh(a, b) {
        var c = ch && ch.isAvailable(), d = c && !(Dc.uf || !0 === Dc.get("previous_websocket_failure"));
        b.Tg && (c || Q("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), 
        d = !0);
        if (d) a.ed = [ ch ]; else {
            var e = a.ed = [];
            Yc(ih, function(a, b) {
                b && b.isAvailable() && e.push(b);
            });
        }
    }
    function jh(a) {
        if (0 < a.ed.length) return a.ed[0];
        throw Error("No transports available");
    }
    function kh(a, b, c, d, e, f) {
        this.id = a;
        this.f = Oc("c:" + this.id + ":");
        this.hc = c;
        this.Vc = d;
        this.ka = e;
        this.Me = f;
        this.H = b;
        this.Jd = [];
        this.ef = 0;
        this.Nf = new gh(b);
        this.Ua = 0;
        this.f("Connection created");
        lh(this);
    }
    function lh(a) {
        var b = jh(a.Nf);
        a.L = new b("c:" + a.id + ":" + a.ef++, a.H);
        a.Qe = b.responsesRequiredToBeHealthy || 0;
        var c = mh(a, a.L), d = nh(a, a.L);
        a.fd = a.L;
        a.bd = a.L;
        a.F = null;
        a.Ab = !1;
        setTimeout(function() {
            a.L && a.L.open(c, d);
        }, Math.floor(0));
        b = b.healthyTimeout || 0;
        0 < b && (a.vd = setTimeout(function() {
            a.vd = null;
            a.Ab || (a.L && 102400 < a.L.ob ? (a.f("Connection exceeded healthy timeout but has received " + a.L.ob + " bytes.  Marking connection healthy."), 
            a.Ab = !0, a.L.Bd()) : a.L && 10240 < a.L.pb ? a.f("Connection exceeded healthy timeout but has sent " + a.L.pb + " bytes.  Leaving connection alive.") : (a.f("Closing unhealthy connection after timeout."), 
            a.close()));
        }, Math.floor(b)));
    }
    function nh(a, b) {
        return function(c) {
            b === a.L ? (a.L = null, c || 0 !== a.Ua ? 1 === a.Ua && a.f("Realtime connection lost.") : (a.f("Realtime connection failed."), 
            "s-" === a.H.Oa.substr(0, 2) && (Dc.remove("host:" + a.H.host), a.H.Oa = a.H.host)), 
            a.close()) : b === a.F ? (a.f("Secondary connection lost."), c = a.F, a.F = null, 
            a.fd !== c && a.bd !== c || a.close()) : a.f("closing an old connection");
        };
    }
    function mh(a, b) {
        return function(c) {
            if (2 != a.Ua) if (b === a.bd) {
                var d = Vc("t", c);
                c = Vc("d", c);
                if ("c" == d) {
                    if (d = Vc("t", c), "d" in c) if (c = c.d, "h" === d) {
                        var d = c.ts, e = c.v, f = c.h;
                        a.Vd = c.s;
                        Fc(a.H, f);
                        0 == a.Ua && (a.L.start(), oh(a, a.L, d), "5" !== e && Q("Protocol version mismatch detected"), 
                        c = a.Nf, (c = 1 < c.ed.length ? c.ed[1] : null) && ph(a, c));
                    } else if ("n" === d) {
                        a.f("recvd end transmission on primary");
                        a.bd = a.F;
                        for (c = 0; c < a.Jd.length; ++c) a.Fd(a.Jd[c]);
                        a.Jd = [];
                        qh(a);
                    } else "s" === d ? (a.f("Connection shutdown command received. Shutting down..."), 
                    a.Me && (a.Me(c), a.Me = null), a.ka = null, a.close()) : "r" === d ? (a.f("Reset packet received.  New host: " + c), 
                    Fc(a.H, c), 1 === a.Ua ? a.close() : (rh(a), lh(a))) : "e" === d ? Pc("Server Error: " + c) : "o" === d ? (a.f("got pong on primary."), 
                    sh(a), th(a)) : Pc("Unknown control packet command: " + d);
                } else "d" == d && a.Fd(c);
            } else if (b === a.F) if (d = Vc("t", c), c = Vc("d", c), "c" == d) "t" in c && (c = c.t, 
            "a" === c ? uh(a) : "r" === c ? (a.f("Got a reset on secondary, closing it"), a.F.close(), 
            a.fd !== a.F && a.bd !== a.F || a.close()) : "o" === c && (a.f("got pong on secondary."), 
            a.Lf--, uh(a))); else if ("d" == d) a.Jd.push(c); else throw Error("Unknown protocol layer: " + d); else a.f("message on old connection");
        };
    }
    kh.prototype.Da = function(a) {
        vh(this, {
            t: "d",
            d: a
        });
    };
    function qh(a) {
        a.fd === a.F && a.bd === a.F && (a.f("cleaning up and promoting a connection: " + a.F.qe), 
        a.L = a.F, a.F = null);
    }
    function uh(a) {
        0 >= a.Lf ? (a.f("Secondary connection is healthy."), a.Ab = !0, a.F.Bd(), a.F.start(), 
        a.f("sending client ack on secondary"), a.F.send({
            t: "c",
            d: {
                t: "a",
                d: {}
            }
        }), a.f("Ending transmission on primary"), a.L.send({
            t: "c",
            d: {
                t: "n",
                d: {}
            }
        }), a.fd = a.F, qh(a)) : (a.f("sending ping on secondary."), a.F.send({
            t: "c",
            d: {
                t: "p",
                d: {}
            }
        }));
    }
    kh.prototype.Fd = function(a) {
        sh(this);
        this.hc(a);
    };
    function sh(a) {
        a.Ab || (a.Qe--, 0 >= a.Qe && (a.f("Primary connection is healthy."), a.Ab = !0, 
        a.L.Bd()));
    }
    function ph(a, b) {
        a.F = new b("c:" + a.id + ":" + a.ef++, a.H, a.Vd);
        a.Lf = b.responsesRequiredToBeHealthy || 0;
        a.F.open(mh(a, a.F), nh(a, a.F));
        setTimeout(function() {
            a.F && (a.f("Timed out trying to upgrade."), a.F.close());
        }, Math.floor(6e4));
    }
    function oh(a, b, c) {
        a.f("Realtime connection established.");
        a.L = b;
        a.Ua = 1;
        a.Vc && (a.Vc(c), a.Vc = null);
        0 === a.Qe ? (a.f("Primary connection is healthy."), a.Ab = !0) : setTimeout(function() {
            th(a);
        }, Math.floor(5e3));
    }
    function th(a) {
        a.Ab || 1 !== a.Ua || (a.f("sending ping on primary."), vh(a, {
            t: "c",
            d: {
                t: "p",
                d: {}
            }
        }));
    }
    function vh(a, b) {
        if (1 !== a.Ua) throw "Connection is not connected";
        a.fd.send(b);
    }
    kh.prototype.close = function() {
        2 !== this.Ua && (this.f("Closing realtime connection."), this.Ua = 2, rh(this), 
        this.ka && (this.ka(), this.ka = null));
    };
    function rh(a) {
        a.f("Shutting down all connections");
        a.L && (a.L.close(), a.L = null);
        a.F && (a.F.close(), a.F = null);
        a.vd && (clearTimeout(a.vd), a.vd = null);
    }
    function wh(a, b, c, d) {
        this.id = xh++;
        this.f = Oc("p:" + this.id + ":");
        this.wf = this.De = !1;
        this.aa = {};
        this.pa = [];
        this.Xc = 0;
        this.Uc = [];
        this.ma = !1;
        this.$a = 1e3;
        this.Cd = 3e5;
        this.Gb = b;
        this.Tc = c;
        this.Ne = d;
        this.H = a;
        this.We = null;
        this.Qd = {};
        this.Ig = 0;
        this.mf = !0;
        this.Kc = this.Fe = null;
        yh(this, 0);
        Mf.ub().Eb("visible", this.zg, this);
        -1 === a.host.indexOf("fblocal") && Lf.ub().Eb("online", this.xg, this);
    }
    var xh = 0, zh = 0;
    h = wh.prototype;
    h.Da = function(a, b, c) {
        var d = ++this.Ig;
        a = {
            r: d,
            a: a,
            b: b
        };
        this.f(B(a));
        J(this.ma, "sendRequest call when we're not connected not allowed.");
        this.Sa.Da(a);
        c && (this.Qd[d] = c);
    };
    h.xf = function(a, b, c, d) {
        var e = a.wa(), f = a.path.toString();
        this.f("Listen called for " + f + " " + e);
        this.aa[f] = this.aa[f] || {};
        J(!this.aa[f][e], "listen() called twice for same path/queryId.");
        a = {
            J: d,
            ud: b,
            Fg: a,
            tag: c
        };
        this.aa[f][e] = a;
        this.ma && Ah(this, a);
    };
    function Ah(a, b) {
        var c = b.Fg, d = c.path.toString(), e = c.wa();
        a.f("Listen on " + d + " for " + e);
        var f = {
            p: d
        };
        b.tag && (f.q = ce(c.n), f.t = b.tag);
        f.h = b.ud();
        a.Da("q", f, function(f) {
            var k = f.d, l = f.s;
            if (k && "object" === typeof k && u(k, "w")) {
                var m = w(k, "w");
                ea(m) && 0 <= Na(m, "no_index") && Q("Using an unspecified index. Consider adding " + ('".indexOn": "' + c.n.g.toString() + '"') + " at " + c.path.toString() + " to your security rules for better performance");
            }
            (a.aa[d] && a.aa[d][e]) === b && (a.f("listen response", f), "ok" !== l && Bh(a, d, e), 
            b.J && b.J(l, k));
        });
    }
    h.P = function(a, b, c) {
        this.Fa = {
            fg: a,
            nf: !1,
            yc: b,
            jd: c
        };
        this.f("Authenticating using credential: " + a);
        Ch(this);
        (b = 40 == a.length) || (a = ad(a).Ac, b = "object" === typeof a && !0 === w(a, "admin"));
        b && (this.f("Admin auth credential detected.  Reducing max reconnect time."), this.Cd = 3e4);
    };
    h.ee = function(a) {
        delete this.Fa;
        this.ma && this.Da("unauth", {}, function(b) {
            a(b.s, b.d);
        });
    };
    function Ch(a) {
        var b = a.Fa;
        a.ma && b && a.Da("auth", {
            cred: b.fg
        }, function(c) {
            var d = c.s;
            c = c.d || "error";
            "ok" !== d && a.Fa === b && delete a.Fa;
            b.nf ? "ok" !== d && b.jd && b.jd(d, c) : (b.nf = !0, b.yc && b.yc(d, c));
        });
    }
    h.Of = function(a, b) {
        var c = a.path.toString(), d = a.wa();
        this.f("Unlisten called for " + c + " " + d);
        if (Bh(this, c, d) && this.ma) {
            var e = ce(a.n);
            this.f("Unlisten on " + c + " for " + d);
            c = {
                p: c
            };
            b && (c.q = e, c.t = b);
            this.Da("n", c);
        }
    };
    h.Le = function(a, b, c) {
        this.ma ? Dh(this, "o", a, b, c) : this.Uc.push({
            Zc: a,
            action: "o",
            data: b,
            J: c
        });
    };
    h.Bf = function(a, b, c) {
        this.ma ? Dh(this, "om", a, b, c) : this.Uc.push({
            Zc: a,
            action: "om",
            data: b,
            J: c
        });
    };
    h.Gd = function(a, b) {
        this.ma ? Dh(this, "oc", a, null, b) : this.Uc.push({
            Zc: a,
            action: "oc",
            data: null,
            J: b
        });
    };
    function Dh(a, b, c, d, e) {
        c = {
            p: c,
            d: d
        };
        a.f("onDisconnect " + b, c);
        a.Da(b, c, function(a) {
            e && setTimeout(function() {
                e(a.s, a.d);
            }, Math.floor(0));
        });
    }
    h.put = function(a, b, c, d) {
        Eh(this, "p", a, b, c, d);
    };
    h.yf = function(a, b, c, d) {
        Eh(this, "m", a, b, c, d);
    };
    function Eh(a, b, c, d, e, f) {
        d = {
            p: c,
            d: d
        };
        n(f) && (d.h = f);
        a.pa.push({
            action: b,
            If: d,
            J: e
        });
        a.Xc++;
        b = a.pa.length - 1;
        a.ma ? Fh(a, b) : a.f("Buffering put: " + c);
    }
    function Fh(a, b) {
        var c = a.pa[b].action, d = a.pa[b].If, e = a.pa[b].J;
        a.pa[b].Gg = a.ma;
        a.Da(c, d, function(d) {
            a.f(c + " response", d);
            delete a.pa[b];
            a.Xc--;
            0 === a.Xc && (a.pa = []);
            e && e(d.s, d.d);
        });
    }
    h.Te = function(a) {
        this.ma && (a = {
            c: a
        }, this.f("reportStats", a), this.Da("s", a, function(a) {
            "ok" !== a.s && this.f("reportStats", "Error sending stats: " + a.d);
        }));
    };
    h.Fd = function(a) {
        if ("r" in a) {
            this.f("from server: " + B(a));
            var b = a.r, c = this.Qd[b];
            c && (delete this.Qd[b], c(a.b));
        } else {
            if ("error" in a) throw "A server-side error has occurred: " + a.error;
            "a" in a && (b = a.a, c = a.b, this.f("handleServerMessage", b, c), "d" === b ? this.Gb(c.p, c.d, !1, c.t) : "m" === b ? this.Gb(c.p, c.d, !0, c.t) : "c" === b ? Gh(this, c.p, c.q) : "ac" === b ? (a = c.s, 
            b = c.d, c = this.Fa, delete this.Fa, c && c.jd && c.jd(a, b)) : "sd" === b ? this.We ? this.We(c) : "msg" in c && "undefined" !== typeof console && console.log("FIREBASE: " + c.msg.replace("\n", "\nFIREBASE: ")) : Pc("Unrecognized action received from server: " + B(b) + "\nAre you using the latest client?"));
        }
    };
    h.Vc = function(a) {
        this.f("connection ready");
        this.ma = !0;
        this.Kc = new Date().getTime();
        this.Ne({
            serverTimeOffset: a - new Date().getTime()
        });
        this.mf && (a = {}, a["sdk.js." + "2.2.4".replace(/\./g, "-")] = 1, kg() && (a["framework.cordova"] = 1), 
        this.Te(a));
        Hh(this);
        this.mf = !1;
        this.Tc(!0);
    };
    function yh(a, b) {
        J(!a.Sa, "Scheduling a connect when we're already connected/ing?");
        a.Sb && clearTimeout(a.Sb);
        a.Sb = setTimeout(function() {
            a.Sb = null;
            Ih(a);
        }, Math.floor(b));
    }
    h.zg = function(a) {
        a && !this.uc && this.$a === this.Cd && (this.f("Window became visible.  Reducing delay."), 
        this.$a = 1e3, this.Sa || yh(this, 0));
        this.uc = a;
    };
    h.xg = function(a) {
        a ? (this.f("Browser went online."), this.$a = 1e3, this.Sa || yh(this, 0)) : (this.f("Browser went offline.  Killing connection."), 
        this.Sa && this.Sa.close());
    };
    h.Cf = function() {
        this.f("data client disconnected");
        this.ma = !1;
        this.Sa = null;
        for (var a = 0; a < this.pa.length; a++) {
            var b = this.pa[a];
            b && "h" in b.If && b.Gg && (b.J && b.J("disconnect"), delete this.pa[a], this.Xc--);
        }
        0 === this.Xc && (this.pa = []);
        this.Qd = {};
        Jh(this) && (this.uc ? this.Kc && (3e4 < new Date().getTime() - this.Kc && (this.$a = 1e3), 
        this.Kc = null) : (this.f("Window isn't visible.  Delaying reconnect."), this.$a = this.Cd, 
        this.Fe = new Date().getTime()), a = Math.max(0, this.$a - (new Date().getTime() - this.Fe)), 
        a *= Math.random(), this.f("Trying to reconnect in " + a + "ms"), yh(this, a), this.$a = Math.min(this.Cd, 1.3 * this.$a));
        this.Tc(!1);
    };
    function Ih(a) {
        if (Jh(a)) {
            a.f("Making a connection attempt");
            a.Fe = new Date().getTime();
            a.Kc = null;
            var b = q(a.Fd, a), c = q(a.Vc, a), d = q(a.Cf, a), e = a.id + ":" + zh++;
            a.Sa = new kh(e, a.H, b, c, d, function(b) {
                Q(b + " (" + a.H.toString() + ")");
                a.wf = !0;
            });
        }
    }
    h.yb = function() {
        this.De = !0;
        this.Sa ? this.Sa.close() : (this.Sb && (clearTimeout(this.Sb), this.Sb = null), 
        this.ma && this.Cf());
    };
    h.qc = function() {
        this.De = !1;
        this.$a = 1e3;
        this.Sa || yh(this, 0);
    };
    function Gh(a, b, c) {
        c = c ? Qa(c, function(a) {
            return Wc(a);
        }).join("$") : "default";
        (a = Bh(a, b, c)) && a.J && a.J("permission_denied");
    }
    function Bh(a, b, c) {
        b = new K(b).toString();
        var d;
        n(a.aa[b]) ? (d = a.aa[b][c], delete a.aa[b][c], 0 === pa(a.aa[b]) && delete a.aa[b]) : d = void 0;
        return d;
    }
    function Hh(a) {
        Ch(a);
        r(a.aa, function(b) {
            r(b, function(b) {
                Ah(a, b);
            });
        });
        for (var b = 0; b < a.pa.length; b++) a.pa[b] && Fh(a, b);
        for (;a.Uc.length; ) b = a.Uc.shift(), Dh(a, b.action, b.Zc, b.data, b.J);
    }
    function Jh(a) {
        var b;
        b = Lf.ub().ic;
        return !a.wf && !a.De && b;
    }
    var V = {
        lg: function() {
            Vg = dh = !0;
        }
    };
    V.forceLongPolling = V.lg;
    V.mg = function() {
        Wg = !0;
    };
    V.forceWebSockets = V.mg;
    V.Mg = function(a, b) {
        a.k.Ra.We = b;
    };
    V.setSecurityDebugCallback = V.Mg;
    V.Ye = function(a, b) {
        a.k.Ye(b);
    };
    V.stats = V.Ye;
    V.Ze = function(a, b) {
        a.k.Ze(b);
    };
    V.statsIncrementCounter = V.Ze;
    V.pd = function(a) {
        return a.k.pd;
    };
    V.dataUpdateCount = V.pd;
    V.pg = function(a, b) {
        a.k.Ce = b;
    };
    V.interceptServerData = V.pg;
    V.vg = function(a) {
        new ug(a);
    };
    V.onPopupOpen = V.vg;
    V.Kg = function(a) {
        fg = a;
    };
    V.setAuthenticationServer = V.Kg;
    function S(a, b, c) {
        this.B = a;
        this.V = b;
        this.g = c;
    }
    S.prototype.K = function() {
        x("Firebase.DataSnapshot.val", 0, 0, arguments.length);
        return this.B.K();
    };
    S.prototype.val = S.prototype.K;
    S.prototype.lf = function() {
        x("Firebase.DataSnapshot.exportVal", 0, 0, arguments.length);
        return this.B.K(!0);
    };
    S.prototype.exportVal = S.prototype.lf;
    S.prototype.kg = function() {
        x("Firebase.DataSnapshot.exists", 0, 0, arguments.length);
        return !this.B.e();
    };
    S.prototype.exists = S.prototype.kg;
    S.prototype.w = function(a) {
        x("Firebase.DataSnapshot.child", 0, 1, arguments.length);
        ga(a) && (a = String(a));
        Xf("Firebase.DataSnapshot.child", a);
        var b = new K(a), c = this.V.w(b);
        return new S(this.B.oa(b), c, M);
    };
    S.prototype.child = S.prototype.w;
    S.prototype.Ha = function(a) {
        x("Firebase.DataSnapshot.hasChild", 1, 1, arguments.length);
        Xf("Firebase.DataSnapshot.hasChild", a);
        var b = new K(a);
        return !this.B.oa(b).e();
    };
    S.prototype.hasChild = S.prototype.Ha;
    S.prototype.A = function() {
        x("Firebase.DataSnapshot.getPriority", 0, 0, arguments.length);
        return this.B.A().K();
    };
    S.prototype.getPriority = S.prototype.A;
    S.prototype.forEach = function(a) {
        x("Firebase.DataSnapshot.forEach", 1, 1, arguments.length);
        A("Firebase.DataSnapshot.forEach", 1, a, !1);
        if (this.B.N()) return !1;
        var b = this;
        return !!this.B.U(this.g, function(c, d) {
            return a(new S(d, b.V.w(c), M));
        });
    };
    S.prototype.forEach = S.prototype.forEach;
    S.prototype.td = function() {
        x("Firebase.DataSnapshot.hasChildren", 0, 0, arguments.length);
        return this.B.N() ? !1 : !this.B.e();
    };
    S.prototype.hasChildren = S.prototype.td;
    S.prototype.name = function() {
        Q("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");
        x("Firebase.DataSnapshot.name", 0, 0, arguments.length);
        return this.key();
    };
    S.prototype.name = S.prototype.name;
    S.prototype.key = function() {
        x("Firebase.DataSnapshot.key", 0, 0, arguments.length);
        return this.V.key();
    };
    S.prototype.key = S.prototype.key;
    S.prototype.Db = function() {
        x("Firebase.DataSnapshot.numChildren", 0, 0, arguments.length);
        return this.B.Db();
    };
    S.prototype.numChildren = S.prototype.Db;
    S.prototype.lc = function() {
        x("Firebase.DataSnapshot.ref", 0, 0, arguments.length);
        return this.V;
    };
    S.prototype.ref = S.prototype.lc;
    function Kh(a, b) {
        this.H = a;
        this.Va = Ob(a);
        this.ea = new ub();
        this.Ed = 1;
        this.Ra = null;
        b || 0 <= ("object" === typeof window && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) ? (this.ca = new Ae(this.H, q(this.Gb, this)), 
        setTimeout(q(this.Tc, this, !0), 0)) : this.ca = this.Ra = new wh(this.H, q(this.Gb, this), q(this.Tc, this), q(this.Ne, this));
        this.Pg = Pb(a, q(function() {
            return new Jb(this.Va, this.ca);
        }, this));
        this.tc = new Cf();
        this.Be = new nb();
        var c = this;
        this.zd = new gf({
            Xe: function(a, b, f, g) {
                b = [];
                f = c.Be.j(a.path);
                f.e() || (b = jf(c.zd, new Ub(ze, a.path, f)), setTimeout(function() {
                    g("ok");
                }, 0));
                return b;
            },
            Zd: ba
        });
        Lh(this, "connected", !1);
        this.ka = new qc();
        this.P = new Eg(a, q(this.ca.P, this.ca), q(this.ca.ee, this.ca), q(this.Ke, this));
        this.pd = 0;
        this.Ce = null;
        this.O = new gf({
            Xe: function(a, b, f, g) {
                c.ca.xf(a, f, b, function(b, e) {
                    var f = g(b, e);
                    zb(c.ea, a.path, f);
                });
                return [];
            },
            Zd: function(a, b) {
                c.ca.Of(a, b);
            }
        });
    }
    h = Kh.prototype;
    h.toString = function() {
        return (this.H.lb ? "https://" : "http://") + this.H.host;
    };
    h.name = function() {
        return this.H.Cb;
    };
    function Mh(a) {
        a = a.Be.j(new K(".info/serverTimeOffset")).K() || 0;
        return new Date().getTime() + a;
    }
    function Nh(a) {
        a = a = {
            timestamp: Mh(a)
        };
        a.timestamp = a.timestamp || new Date().getTime();
        return a;
    }
    h.Gb = function(a, b, c, d) {
        this.pd++;
        var e = new K(a);
        b = this.Ce ? this.Ce(a, b) : b;
        a = [];
        d ? c ? (b = na(b, function(a) {
            return L(a);
        }), a = rf(this.O, e, b, d)) : (b = L(b), a = nf(this.O, e, b, d)) : c ? (d = na(b, function(a) {
            return L(a);
        }), a = mf(this.O, e, d)) : (d = L(b), a = jf(this.O, new Ub(ze, e, d)));
        d = e;
        0 < a.length && (d = Oh(this, e));
        zb(this.ea, d, a);
    };
    h.Tc = function(a) {
        Lh(this, "connected", a);
        !1 === a && Ph(this);
    };
    h.Ne = function(a) {
        var b = this;
        Yc(a, function(a, d) {
            Lh(b, d, a);
        });
    };
    h.Ke = function(a) {
        Lh(this, "authenticated", a);
    };
    function Lh(a, b, c) {
        b = new K("/.info/" + b);
        c = L(c);
        var d = a.Be;
        d.Sd = d.Sd.G(b, c);
        c = jf(a.zd, new Ub(ze, b, c));
        zb(a.ea, b, c);
    }
    h.Kb = function(a, b, c, d) {
        this.f("set", {
            path: a.toString(),
            value: b,
            Xg: c
        });
        var e = Nh(this);
        b = L(b, c);
        var e = sc(b, e), f = this.Ed++, e = hf(this.O, a, e, f, !0);
        vb(this.ea, e);
        var g = this;
        this.ca.put(a.toString(), b.K(!0), function(b, c) {
            var e = "ok" === b;
            e || Q("set at " + a + " failed: " + b);
            e = lf(g.O, f, !e);
            zb(g.ea, a, e);
            Qh(d, b, c);
        });
        e = Rh(this, a);
        Oh(this, e);
        zb(this.ea, e, []);
    };
    h.update = function(a, b, c) {
        this.f("update", {
            path: a.toString(),
            value: b
        });
        var d = !0, e = Nh(this), f = {};
        r(b, function(a, b) {
            d = !1;
            var c = L(a);
            f[b] = sc(c, e);
        });
        if (d) Bb("update() called with empty data.  Don't do anything."), Qh(c, "ok"); else {
            var g = this.Ed++, k = kf(this.O, a, f, g);
            vb(this.ea, k);
            var l = this;
            this.ca.yf(a.toString(), b, function(b, d) {
                var e = "ok" === b;
                e || Q("update at " + a + " failed: " + b);
                var e = lf(l.O, g, !e), f = a;
                0 < e.length && (f = Oh(l, a));
                zb(l.ea, f, e);
                Qh(c, b, d);
            });
            b = Rh(this, a);
            Oh(this, b);
            zb(this.ea, a, []);
        }
    };
    function Ph(a) {
        a.f("onDisconnectEvents");
        var b = Nh(a), c = [];
        rc(pc(a.ka, b), F, function(b, e) {
            c = c.concat(jf(a.O, new Ub(ze, b, e)));
            var f = Rh(a, b);
            Oh(a, f);
        });
        a.ka = new qc();
        zb(a.ea, F, c);
    }
    h.Gd = function(a, b) {
        var c = this;
        this.ca.Gd(a.toString(), function(d, e) {
            "ok" === d && eg(c.ka, a);
            Qh(b, d, e);
        });
    };
    function Sh(a, b, c, d) {
        var e = L(c);
        a.ca.Le(b.toString(), e.K(!0), function(c, g) {
            "ok" === c && a.ka.mc(b, e);
            Qh(d, c, g);
        });
    }
    function Th(a, b, c, d, e) {
        var f = L(c, d);
        a.ca.Le(b.toString(), f.K(!0), function(c, d) {
            "ok" === c && a.ka.mc(b, f);
            Qh(e, c, d);
        });
    }
    function Uh(a, b, c, d) {
        var e = !0, f;
        for (f in c) e = !1;
        e ? (Bb("onDisconnect().update() called with empty data.  Don't do anything."), 
        Qh(d, "ok")) : a.ca.Bf(b.toString(), c, function(e, f) {
            if ("ok" === e) for (var l in c) {
                var m = L(c[l]);
                a.ka.mc(b.w(l), m);
            }
            Qh(d, e, f);
        });
    }
    function Vh(a, b, c) {
        c = ".info" === O(b.path) ? a.zd.Ob(b, c) : a.O.Ob(b, c);
        xb(a.ea, b.path, c);
    }
    h.yb = function() {
        this.Ra && this.Ra.yb();
    };
    h.qc = function() {
        this.Ra && this.Ra.qc();
    };
    h.Ye = function(a) {
        if ("undefined" !== typeof console) {
            a ? (this.Yd || (this.Yd = new Ib(this.Va)), a = this.Yd.get()) : a = this.Va.get();
            var b = Ra(sa(a), function(a, b) {
                return Math.max(b.length, a);
            }, 0), c;
            for (c in a) {
                for (var d = a[c], e = c.length; e < b + 2; e++) c += " ";
                console.log(c + d);
            }
        }
    };
    h.Ze = function(a) {
        Lb(this.Va, a);
        this.Pg.Mf[a] = !0;
    };
    h.f = function(a) {
        var b = "";
        this.Ra && (b = this.Ra.id + ":");
        Bb(b, arguments);
    };
    function Qh(a, b, c) {
        a && Cb(function() {
            if ("ok" == b) a(null); else {
                var d = (b || "error").toUpperCase(), e = d;
                c && (e += ": " + c);
                e = Error(e);
                e.code = d;
                a(e);
            }
        });
    }
    function Wh(a, b, c, d, e) {
        function f() {}
        a.f("transaction on " + b);
        var g = new U(a, b);
        g.Eb("value", f);
        c = {
            path: b,
            update: c,
            J: d,
            status: null,
            Ef: Gc(),
            cf: e,
            Kf: 0,
            ge: function() {
                g.gc("value", f);
            },
            je: null,
            Aa: null,
            md: null,
            nd: null,
            od: null
        };
        d = a.O.ua(b, void 0) || C;
        c.md = d;
        d = c.update(d.K());
        if (n(d)) {
            Sf("transaction failed: Data returned ", d, c.path);
            c.status = 1;
            e = Df(a.tc, b);
            var k = e.Ba() || [];
            k.push(c);
            Ef(e, k);
            "object" === typeof d && null !== d && u(d, ".priority") ? (k = w(d, ".priority"), 
            J(Qf(k), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")) : k = (a.O.ua(b) || C).A().K();
            e = Nh(a);
            d = L(d, k);
            e = sc(d, e);
            c.nd = d;
            c.od = e;
            c.Aa = a.Ed++;
            c = hf(a.O, b, e, c.Aa, c.cf);
            zb(a.ea, b, c);
            Xh(a);
        } else c.ge(), c.nd = null, c.od = null, c.J && (a = new S(c.md, new U(a, c.path), M), 
        c.J(null, !1, a));
    }
    function Xh(a, b) {
        var c = b || a.tc;
        b || Yh(a, c);
        if (null !== c.Ba()) {
            var d = Zh(a, c);
            J(0 < d.length, "Sending zero length transaction queue");
            Sa(d, function(a) {
                return 1 === a.status;
            }) && $h(a, c.path(), d);
        } else c.td() && c.U(function(b) {
            Xh(a, b);
        });
    }
    function $h(a, b, c) {
        for (var d = Qa(c, function(a) {
            return a.Aa;
        }), e = a.O.ua(b, d) || C, d = e, e = e.hash(), f = 0; f < c.length; f++) {
            var g = c[f];
            J(1 === g.status, "tryToSendTransactionQueue_: items in queue should all be run.");
            g.status = 2;
            g.Kf++;
            var k = N(b, g.path), d = d.G(k, g.nd);
        }
        d = d.K(!0);
        a.ca.put(b.toString(), d, function(d) {
            a.f("transaction put response", {
                path: b.toString(),
                status: d
            });
            var e = [];
            if ("ok" === d) {
                d = [];
                for (f = 0; f < c.length; f++) {
                    c[f].status = 3;
                    e = e.concat(lf(a.O, c[f].Aa));
                    if (c[f].J) {
                        var g = c[f].od, k = new U(a, c[f].path);
                        d.push(q(c[f].J, null, null, !0, new S(g, k, M)));
                    }
                    c[f].ge();
                }
                Yh(a, Df(a.tc, b));
                Xh(a);
                zb(a.ea, b, e);
                for (f = 0; f < d.length; f++) Cb(d[f]);
            } else {
                if ("datastale" === d) for (f = 0; f < c.length; f++) c[f].status = 4 === c[f].status ? 5 : 1; else for (Q("transaction at " + b.toString() + " failed: " + d), 
                f = 0; f < c.length; f++) c[f].status = 5, c[f].je = d;
                Oh(a, b);
            }
        }, e);
    }
    function Oh(a, b) {
        var c = ai(a, b), d = c.path(), c = Zh(a, c);
        bi(a, c, d);
        return d;
    }
    function bi(a, b, c) {
        if (0 !== b.length) {
            for (var d = [], e = [], f = Qa(b, function(a) {
                return a.Aa;
            }), g = 0; g < b.length; g++) {
                var k = b[g], l = N(c, k.path), m = !1, v;
                J(null !== l, "rerunTransactionsUnderNode_: relativePath should not be null.");
                if (5 === k.status) m = !0, v = k.je, e = e.concat(lf(a.O, k.Aa, !0)); else if (1 === k.status) if (25 <= k.Kf) m = !0, 
                v = "maxretry", e = e.concat(lf(a.O, k.Aa, !0)); else {
                    var y = a.O.ua(k.path, f) || C;
                    k.md = y;
                    var I = b[g].update(y.K());
                    n(I) ? (Sf("transaction failed: Data returned ", I, k.path), l = L(I), "object" === typeof I && null != I && u(I, ".priority") || (l = l.da(y.A())), 
                    y = k.Aa, I = Nh(a), I = sc(l, I), k.nd = l, k.od = I, k.Aa = a.Ed++, Va(f, y), 
                    e = e.concat(hf(a.O, k.path, I, k.Aa, k.cf)), e = e.concat(lf(a.O, y, !0))) : (m = !0, 
                    v = "nodata", e = e.concat(lf(a.O, k.Aa, !0)));
                }
                zb(a.ea, c, e);
                e = [];
                m && (b[g].status = 3, setTimeout(b[g].ge, Math.floor(0)), b[g].J && ("nodata" === v ? (k = new U(a, b[g].path), 
                d.push(q(b[g].J, null, null, !1, new S(b[g].md, k, M)))) : d.push(q(b[g].J, null, Error(v), !1, null))));
            }
            Yh(a, a.tc);
            for (g = 0; g < d.length; g++) Cb(d[g]);
            Xh(a);
        }
    }
    function ai(a, b) {
        for (var c, d = a.tc; null !== (c = O(b)) && null === d.Ba(); ) d = Df(d, c), b = G(b);
        return d;
    }
    function Zh(a, b) {
        var c = [];
        ci(a, b, c);
        c.sort(function(a, b) {
            return a.Ef - b.Ef;
        });
        return c;
    }
    function ci(a, b, c) {
        var d = b.Ba();
        if (null !== d) for (var e = 0; e < d.length; e++) c.push(d[e]);
        b.U(function(b) {
            ci(a, b, c);
        });
    }
    function Yh(a, b) {
        var c = b.Ba();
        if (c) {
            for (var d = 0, e = 0; e < c.length; e++) 3 !== c[e].status && (c[d] = c[e], d++);
            c.length = d;
            Ef(b, 0 < c.length ? c : null);
        }
        b.U(function(b) {
            Yh(a, b);
        });
    }
    function Rh(a, b) {
        var c = ai(a, b).path(), d = Df(a.tc, b);
        Hf(d, function(b) {
            di(a, b);
        });
        di(a, d);
        Gf(d, function(b) {
            di(a, b);
        });
        return c;
    }
    function di(a, b) {
        var c = b.Ba();
        if (null !== c) {
            for (var d = [], e = [], f = -1, g = 0; g < c.length; g++) 4 !== c[g].status && (2 === c[g].status ? (J(f === g - 1, "All SENT items should be at beginning of queue."), 
            f = g, c[g].status = 4, c[g].je = "set") : (J(1 === c[g].status, "Unexpected transaction status in abort"), 
            c[g].ge(), e = e.concat(lf(a.O, c[g].Aa, !0)), c[g].J && d.push(q(c[g].J, null, Error("set"), !1, null))));
            -1 === f ? Ef(b, null) : c.length = f + 1;
            zb(a.ea, b.path(), e);
            for (g = 0; g < d.length; g++) Cb(d[g]);
        }
    }
    function W() {
        this.nc = {};
        this.Pf = !1;
    }
    ca(W);
    W.prototype.yb = function() {
        for (var a in this.nc) this.nc[a].yb();
    };
    W.prototype.interrupt = W.prototype.yb;
    W.prototype.qc = function() {
        for (var a in this.nc) this.nc[a].qc();
    };
    W.prototype.resume = W.prototype.qc;
    W.prototype.ue = function() {
        this.Pf = !0;
    };
    function X(a, b) {
        this.ad = a;
        this.qa = b;
    }
    X.prototype.cancel = function(a) {
        x("Firebase.onDisconnect().cancel", 0, 1, arguments.length);
        A("Firebase.onDisconnect().cancel", 1, a, !0);
        this.ad.Gd(this.qa, a || null);
    };
    X.prototype.cancel = X.prototype.cancel;
    X.prototype.remove = function(a) {
        x("Firebase.onDisconnect().remove", 0, 1, arguments.length);
        Yf("Firebase.onDisconnect().remove", this.qa);
        A("Firebase.onDisconnect().remove", 1, a, !0);
        Sh(this.ad, this.qa, null, a);
    };
    X.prototype.remove = X.prototype.remove;
    X.prototype.set = function(a, b) {
        x("Firebase.onDisconnect().set", 1, 2, arguments.length);
        Yf("Firebase.onDisconnect().set", this.qa);
        Rf("Firebase.onDisconnect().set", a, this.qa, !1);
        A("Firebase.onDisconnect().set", 2, b, !0);
        Sh(this.ad, this.qa, a, b);
    };
    X.prototype.set = X.prototype.set;
    X.prototype.Kb = function(a, b, c) {
        x("Firebase.onDisconnect().setWithPriority", 2, 3, arguments.length);
        Yf("Firebase.onDisconnect().setWithPriority", this.qa);
        Rf("Firebase.onDisconnect().setWithPriority", a, this.qa, !1);
        Uf("Firebase.onDisconnect().setWithPriority", 2, b);
        A("Firebase.onDisconnect().setWithPriority", 3, c, !0);
        Th(this.ad, this.qa, a, b, c);
    };
    X.prototype.setWithPriority = X.prototype.Kb;
    X.prototype.update = function(a, b) {
        x("Firebase.onDisconnect().update", 1, 2, arguments.length);
        Yf("Firebase.onDisconnect().update", this.qa);
        if (ea(a)) {
            for (var c = {}, d = 0; d < a.length; ++d) c["" + d] = a[d];
            a = c;
            Q("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
        }
        Tf("Firebase.onDisconnect().update", a, this.qa);
        A("Firebase.onDisconnect().update", 2, b, !0);
        Uh(this.ad, this.qa, a, b);
    };
    X.prototype.update = X.prototype.update;
    function Y(a, b, c, d) {
        this.k = a;
        this.path = b;
        this.n = c;
        this.jc = d;
    }
    function ei(a) {
        var b = null, c = null;
        a.la && (b = od(a));
        a.na && (c = qd(a));
        if (a.g === Vd) {
            if (a.la) {
                if ("[MIN_NAME]" != nd(a)) throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");
                if ("string" !== typeof b) throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");
            }
            if (a.na) {
                if ("[MAX_NAME]" != pd(a)) throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");
                if ("string" !== typeof c) throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");
            }
        } else if (a.g === M) {
            if (null != b && !Qf(b) || null != c && !Qf(c)) throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");
        } else if (J(a.g instanceof Rd || a.g === Yd, "unknown index type."), null != b && "object" === typeof b || null != c && "object" === typeof c) throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
    }
    function fi(a) {
        if (a.la && a.na && a.ia && (!a.ia || "" === a.Nb)) throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");
    }
    function gi(a, b) {
        if (!0 === a.jc) throw Error(b + ": You can't combine multiple orderBy calls.");
    }
    Y.prototype.lc = function() {
        x("Query.ref", 0, 0, arguments.length);
        return new U(this.k, this.path);
    };
    Y.prototype.ref = Y.prototype.lc;
    Y.prototype.Eb = function(a, b, c, d) {
        x("Query.on", 2, 4, arguments.length);
        Vf("Query.on", a, !1);
        A("Query.on", 2, b, !1);
        var e = hi("Query.on", c, d);
        if ("value" === a) Vh(this.k, this, new jd(b, e.cancel || null, e.Ma || null)); else {
            var f = {};
            f[a] = b;
            Vh(this.k, this, new kd(f, e.cancel, e.Ma));
        }
        return b;
    };
    Y.prototype.on = Y.prototype.Eb;
    Y.prototype.gc = function(a, b, c) {
        x("Query.off", 0, 3, arguments.length);
        Vf("Query.off", a, !0);
        A("Query.off", 2, b, !0);
        lb("Query.off", 3, c);
        var d = null, e = null;
        "value" === a ? d = new jd(b || null, null, c || null) : a && (b && (e = {}, e[a] = b), 
        d = new kd(e, null, c || null));
        e = this.k;
        d = ".info" === O(this.path) ? e.zd.kb(this, d) : e.O.kb(this, d);
        xb(e.ea, this.path, d);
    };
    Y.prototype.off = Y.prototype.gc;
    Y.prototype.Ag = function(a, b) {
        function c(g) {
            f && (f = !1, e.gc(a, c), b.call(d.Ma, g));
        }
        x("Query.once", 2, 4, arguments.length);
        Vf("Query.once", a, !1);
        A("Query.once", 2, b, !1);
        var d = hi("Query.once", arguments[2], arguments[3]), e = this, f = !0;
        this.Eb(a, c, function(b) {
            e.gc(a, c);
            d.cancel && d.cancel.call(d.Ma, b);
        });
    };
    Y.prototype.once = Y.prototype.Ag;
    Y.prototype.Ge = function(a) {
        Q("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");
        x("Query.limit", 1, 1, arguments.length);
        if (!ga(a) || Math.floor(a) !== a || 0 >= a) throw Error("Query.limit: First argument must be a positive integer.");
        if (this.n.ia) throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");
        var b = this.n.Ge(a);
        fi(b);
        return new Y(this.k, this.path, b, this.jc);
    };
    Y.prototype.limit = Y.prototype.Ge;
    Y.prototype.He = function(a) {
        x("Query.limitToFirst", 1, 1, arguments.length);
        if (!ga(a) || Math.floor(a) !== a || 0 >= a) throw Error("Query.limitToFirst: First argument must be a positive integer.");
        if (this.n.ia) throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");
        return new Y(this.k, this.path, this.n.He(a), this.jc);
    };
    Y.prototype.limitToFirst = Y.prototype.He;
    Y.prototype.Ie = function(a) {
        x("Query.limitToLast", 1, 1, arguments.length);
        if (!ga(a) || Math.floor(a) !== a || 0 >= a) throw Error("Query.limitToLast: First argument must be a positive integer.");
        if (this.n.ia) throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");
        return new Y(this.k, this.path, this.n.Ie(a), this.jc);
    };
    Y.prototype.limitToLast = Y.prototype.Ie;
    Y.prototype.Bg = function(a) {
        x("Query.orderByChild", 1, 1, arguments.length);
        if ("$key" === a) throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
        if ("$priority" === a) throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
        if ("$value" === a) throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
        Wf("Query.orderByChild", 1, a, !1);
        gi(this, "Query.orderByChild");
        var b = be(this.n, new Rd(a));
        ei(b);
        return new Y(this.k, this.path, b, !0);
    };
    Y.prototype.orderByChild = Y.prototype.Bg;
    Y.prototype.Cg = function() {
        x("Query.orderByKey", 0, 0, arguments.length);
        gi(this, "Query.orderByKey");
        var a = be(this.n, Vd);
        ei(a);
        return new Y(this.k, this.path, a, !0);
    };
    Y.prototype.orderByKey = Y.prototype.Cg;
    Y.prototype.Dg = function() {
        x("Query.orderByPriority", 0, 0, arguments.length);
        gi(this, "Query.orderByPriority");
        var a = be(this.n, M);
        ei(a);
        return new Y(this.k, this.path, a, !0);
    };
    Y.prototype.orderByPriority = Y.prototype.Dg;
    Y.prototype.Eg = function() {
        x("Query.orderByValue", 0, 0, arguments.length);
        gi(this, "Query.orderByValue");
        var a = be(this.n, Yd);
        ei(a);
        return new Y(this.k, this.path, a, !0);
    };
    Y.prototype.orderByValue = Y.prototype.Eg;
    Y.prototype.Xd = function(a, b) {
        x("Query.startAt", 0, 2, arguments.length);
        Rf("Query.startAt", a, this.path, !0);
        Wf("Query.startAt", 2, b, !0);
        var c = this.n.Xd(a, b);
        fi(c);
        ei(c);
        if (this.n.la) throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");
        n(a) || (b = a = null);
        return new Y(this.k, this.path, c, this.jc);
    };
    Y.prototype.startAt = Y.prototype.Xd;
    Y.prototype.qd = function(a, b) {
        x("Query.endAt", 0, 2, arguments.length);
        Rf("Query.endAt", a, this.path, !0);
        Wf("Query.endAt", 2, b, !0);
        var c = this.n.qd(a, b);
        fi(c);
        ei(c);
        if (this.n.na) throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");
        return new Y(this.k, this.path, c, this.jc);
    };
    Y.prototype.endAt = Y.prototype.qd;
    Y.prototype.hg = function(a, b) {
        x("Query.equalTo", 1, 2, arguments.length);
        Rf("Query.equalTo", a, this.path, !1);
        Wf("Query.equalTo", 2, b, !0);
        if (this.n.la) throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");
        if (this.n.na) throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");
        return this.Xd(a, b).qd(a, b);
    };
    Y.prototype.equalTo = Y.prototype.hg;
    Y.prototype.toString = function() {
        x("Query.toString", 0, 0, arguments.length);
        for (var a = this.path, b = "", c = a.Y; c < a.o.length; c++) "" !== a.o[c] && (b += "/" + encodeURIComponent(String(a.o[c])));
        a = this.k.toString() + (b || "/");
        b = jb(ee(this.n));
        return a += b.replace(/^&/, "");
    };
    Y.prototype.toString = Y.prototype.toString;
    Y.prototype.wa = function() {
        var a = Wc(ce(this.n));
        return "{}" === a ? "default" : a;
    };
    function hi(a, b, c) {
        var d = {
            cancel: null,
            Ma: null
        };
        if (b && c) d.cancel = b, A(a, 3, d.cancel, !0), d.Ma = c, lb(a, 4, d.Ma); else if (b) if ("object" === typeof b && null !== b) d.Ma = b; else if ("function" === typeof b) d.cancel = b; else throw Error(z(a, 3, !0) + " must either be a cancel callback or a context object.");
        return d;
    }
    var Z = {};
    Z.vc = wh;
    Z.DataConnection = Z.vc;
    wh.prototype.Og = function(a, b) {
        this.Da("q", {
            p: a
        }, b);
    };
    Z.vc.prototype.simpleListen = Z.vc.prototype.Og;
    wh.prototype.gg = function(a, b) {
        this.Da("echo", {
            d: a
        }, b);
    };
    Z.vc.prototype.echo = Z.vc.prototype.gg;
    wh.prototype.interrupt = wh.prototype.yb;
    Z.Sf = kh;
    Z.RealTimeConnection = Z.Sf;
    kh.prototype.sendRequest = kh.prototype.Da;
    kh.prototype.close = kh.prototype.close;
    Z.og = function(a) {
        var b = wh.prototype.put;
        wh.prototype.put = function(c, d, e, f) {
            n(f) && (f = a());
            b.call(this, c, d, e, f);
        };
        return function() {
            wh.prototype.put = b;
        };
    };
    Z.hijackHash = Z.og;
    Z.Rf = Ec;
    Z.ConnectionTarget = Z.Rf;
    Z.wa = function(a) {
        return a.wa();
    };
    Z.queryIdentifier = Z.wa;
    Z.qg = function(a) {
        return a.k.Ra.aa;
    };
    Z.listens = Z.qg;
    Z.ue = function(a) {
        a.ue();
    };
    Z.forceRestClient = Z.ue;
    function U(a, b) {
        var c, d, e;
        if (a instanceof Kh) c = a, d = b; else {
            x("new Firebase", 1, 2, arguments.length);
            d = Rc(arguments[0]);
            c = d.Qg;
            "firebase" === d.domain && Qc(d.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
            c || Qc("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
            d.lb || "undefined" !== typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && Q("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
            c = new Ec(d.host, d.lb, c, "ws" === d.scheme || "wss" === d.scheme);
            d = new K(d.Zc);
            e = d.toString();
            var f;
            !(f = !p(c.host) || 0 === c.host.length || !Pf(c.Cb)) && (f = 0 !== e.length) && (e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), 
            f = !(p(e) && 0 !== e.length && !Of.test(e)));
            if (f) throw Error(z("new Firebase", 1, !1) + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');
            if (b) if (b instanceof W) e = b; else if (p(b)) e = W.ub(), c.Ld = b; else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()"); else e = W.ub();
            f = c.toString();
            var g = w(e.nc, f);
            g || (g = new Kh(c, e.Pf), e.nc[f] = g);
            c = g;
        }
        Y.call(this, c, d, $d, !1);
    }
    ma(U, Y);
    var ii = U, ji = [ "Firebase" ], ki = aa;
    ji[0] in ki || !ki.execScript || ki.execScript("var " + ji[0]);
    for (var li; ji.length && (li = ji.shift()); ) !ji.length && n(ii) ? ki[li] = ii : ki = ki[li] ? ki[li] : ki[li] = {};
    U.prototype.name = function() {
        Q("Firebase.name() being deprecated. Please use Firebase.key() instead.");
        x("Firebase.name", 0, 0, arguments.length);
        return this.key();
    };
    U.prototype.name = U.prototype.name;
    U.prototype.key = function() {
        x("Firebase.key", 0, 0, arguments.length);
        return this.path.e() ? null : vc(this.path);
    };
    U.prototype.key = U.prototype.key;
    U.prototype.w = function(a) {
        x("Firebase.child", 1, 1, arguments.length);
        if (ga(a)) a = String(a); else if (!(a instanceof K)) if (null === O(this.path)) {
            var b = a;
            b && (b = b.replace(/^\/*\.info(\/|$)/, "/"));
            Xf("Firebase.child", b);
        } else Xf("Firebase.child", a);
        return new U(this.k, this.path.w(a));
    };
    U.prototype.child = U.prototype.w;
    U.prototype.parent = function() {
        x("Firebase.parent", 0, 0, arguments.length);
        var a = this.path.parent();
        return null === a ? null : new U(this.k, a);
    };
    U.prototype.parent = U.prototype.parent;
    U.prototype.root = function() {
        x("Firebase.ref", 0, 0, arguments.length);
        for (var a = this; null !== a.parent(); ) a = a.parent();
        return a;
    };
    U.prototype.root = U.prototype.root;
    U.prototype.set = function(a, b) {
        x("Firebase.set", 1, 2, arguments.length);
        Yf("Firebase.set", this.path);
        Rf("Firebase.set", a, this.path, !1);
        A("Firebase.set", 2, b, !0);
        this.k.Kb(this.path, a, null, b || null);
    };
    U.prototype.set = U.prototype.set;
    U.prototype.update = function(a, b) {
        x("Firebase.update", 1, 2, arguments.length);
        Yf("Firebase.update", this.path);
        if (ea(a)) {
            for (var c = {}, d = 0; d < a.length; ++d) c["" + d] = a[d];
            a = c;
            Q("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
        }
        Tf("Firebase.update", a, this.path);
        A("Firebase.update", 2, b, !0);
        this.k.update(this.path, a, b || null);
    };
    U.prototype.update = U.prototype.update;
    U.prototype.Kb = function(a, b, c) {
        x("Firebase.setWithPriority", 2, 3, arguments.length);
        Yf("Firebase.setWithPriority", this.path);
        Rf("Firebase.setWithPriority", a, this.path, !1);
        Uf("Firebase.setWithPriority", 2, b);
        A("Firebase.setWithPriority", 3, c, !0);
        if (".length" === this.key() || ".keys" === this.key()) throw "Firebase.setWithPriority failed: " + this.key() + " is a read-only object.";
        this.k.Kb(this.path, a, b, c || null);
    };
    U.prototype.setWithPriority = U.prototype.Kb;
    U.prototype.remove = function(a) {
        x("Firebase.remove", 0, 1, arguments.length);
        Yf("Firebase.remove", this.path);
        A("Firebase.remove", 1, a, !0);
        this.set(null, a);
    };
    U.prototype.remove = U.prototype.remove;
    U.prototype.transaction = function(a, b, c) {
        x("Firebase.transaction", 1, 3, arguments.length);
        Yf("Firebase.transaction", this.path);
        A("Firebase.transaction", 1, a, !1);
        A("Firebase.transaction", 2, b, !0);
        if (n(c) && "boolean" != typeof c) throw Error(z("Firebase.transaction", 3, !0) + "must be a boolean.");
        if (".length" === this.key() || ".keys" === this.key()) throw "Firebase.transaction failed: " + this.key() + " is a read-only object.";
        "undefined" === typeof c && (c = !0);
        Wh(this.k, this.path, a, b || null, c);
    };
    U.prototype.transaction = U.prototype.transaction;
    U.prototype.Lg = function(a, b) {
        x("Firebase.setPriority", 1, 2, arguments.length);
        Yf("Firebase.setPriority", this.path);
        Uf("Firebase.setPriority", 1, a);
        A("Firebase.setPriority", 2, b, !0);
        this.k.Kb(this.path.w(".priority"), a, null, b);
    };
    U.prototype.setPriority = U.prototype.Lg;
    U.prototype.push = function(a, b) {
        x("Firebase.push", 0, 2, arguments.length);
        Yf("Firebase.push", this.path);
        Rf("Firebase.push", a, this.path, !0);
        A("Firebase.push", 2, b, !0);
        var c = Mh(this.k), c = Kf(c), c = this.w(c);
        "undefined" !== typeof a && null !== a && c.set(a, b);
        return c;
    };
    U.prototype.push = U.prototype.push;
    U.prototype.jb = function() {
        Yf("Firebase.onDisconnect", this.path);
        return new X(this.k, this.path);
    };
    U.prototype.onDisconnect = U.prototype.jb;
    U.prototype.P = function(a, b, c) {
        Q("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");
        x("Firebase.auth", 1, 3, arguments.length);
        Zf("Firebase.auth", a);
        A("Firebase.auth", 2, b, !0);
        A("Firebase.auth", 3, b, !0);
        Kg(this.k.P, a, {}, {
            remember: "none"
        }, b, c);
    };
    U.prototype.auth = U.prototype.P;
    U.prototype.ee = function(a) {
        x("Firebase.unauth", 0, 1, arguments.length);
        A("Firebase.unauth", 1, a, !0);
        Lg(this.k.P, a);
    };
    U.prototype.unauth = U.prototype.ee;
    U.prototype.we = function() {
        x("Firebase.getAuth", 0, 0, arguments.length);
        return this.k.P.we();
    };
    U.prototype.getAuth = U.prototype.we;
    U.prototype.ug = function(a, b) {
        x("Firebase.onAuth", 1, 2, arguments.length);
        A("Firebase.onAuth", 1, a, !1);
        lb("Firebase.onAuth", 2, b);
        this.k.P.Eb("auth_status", a, b);
    };
    U.prototype.onAuth = U.prototype.ug;
    U.prototype.tg = function(a, b) {
        x("Firebase.offAuth", 1, 2, arguments.length);
        A("Firebase.offAuth", 1, a, !1);
        lb("Firebase.offAuth", 2, b);
        this.k.P.gc("auth_status", a, b);
    };
    U.prototype.offAuth = U.prototype.tg;
    U.prototype.Wf = function(a, b, c) {
        x("Firebase.authWithCustomToken", 2, 3, arguments.length);
        Zf("Firebase.authWithCustomToken", a);
        A("Firebase.authWithCustomToken", 2, b, !1);
        ag("Firebase.authWithCustomToken", 3, c, !0);
        Kg(this.k.P, a, {}, c || {}, b);
    };
    U.prototype.authWithCustomToken = U.prototype.Wf;
    U.prototype.Xf = function(a, b, c) {
        x("Firebase.authWithOAuthPopup", 2, 3, arguments.length);
        $f("Firebase.authWithOAuthPopup", 1, a);
        A("Firebase.authWithOAuthPopup", 2, b, !1);
        ag("Firebase.authWithOAuthPopup", 3, c, !0);
        Pg(this.k.P, a, c, b);
    };
    U.prototype.authWithOAuthPopup = U.prototype.Xf;
    U.prototype.Yf = function(a, b, c) {
        x("Firebase.authWithOAuthRedirect", 2, 3, arguments.length);
        $f("Firebase.authWithOAuthRedirect", 1, a);
        A("Firebase.authWithOAuthRedirect", 2, b, !1);
        ag("Firebase.authWithOAuthRedirect", 3, c, !0);
        var d = this.k.P;
        Ng(d);
        var e = [ wg ], f = ig(c);
        "anonymous" === a || "firebase" === a ? R(b, yg("TRANSPORT_UNAVAILABLE")) : (P.set("redirect_client_options", f.ld), 
        Og(d, e, "/auth/" + a, f, b));
    };
    U.prototype.authWithOAuthRedirect = U.prototype.Yf;
    U.prototype.Zf = function(a, b, c, d) {
        x("Firebase.authWithOAuthToken", 3, 4, arguments.length);
        $f("Firebase.authWithOAuthToken", 1, a);
        A("Firebase.authWithOAuthToken", 3, c, !1);
        ag("Firebase.authWithOAuthToken", 4, d, !0);
        p(b) ? ($f("Firebase.authWithOAuthToken", 2, b), Mg(this.k.P, a + "/token", {
            access_token: b
        }, d, c)) : (ag("Firebase.authWithOAuthToken", 2, b, !1), Mg(this.k.P, a + "/token", b, d, c));
    };
    U.prototype.authWithOAuthToken = U.prototype.Zf;
    U.prototype.Vf = function(a, b) {
        x("Firebase.authAnonymously", 1, 2, arguments.length);
        A("Firebase.authAnonymously", 1, a, !1);
        ag("Firebase.authAnonymously", 2, b, !0);
        Mg(this.k.P, "anonymous", {}, b, a);
    };
    U.prototype.authAnonymously = U.prototype.Vf;
    U.prototype.$f = function(a, b, c) {
        x("Firebase.authWithPassword", 2, 3, arguments.length);
        ag("Firebase.authWithPassword", 1, a, !1);
        bg("Firebase.authWithPassword", a, "email");
        bg("Firebase.authWithPassword", a, "password");
        A("Firebase.authAnonymously", 2, b, !1);
        ag("Firebase.authAnonymously", 3, c, !0);
        Mg(this.k.P, "password", a, c, b);
    };
    U.prototype.authWithPassword = U.prototype.$f;
    U.prototype.re = function(a, b) {
        x("Firebase.createUser", 2, 2, arguments.length);
        ag("Firebase.createUser", 1, a, !1);
        bg("Firebase.createUser", a, "email");
        bg("Firebase.createUser", a, "password");
        A("Firebase.createUser", 2, b, !1);
        this.k.P.re(a, b);
    };
    U.prototype.createUser = U.prototype.re;
    U.prototype.Se = function(a, b) {
        x("Firebase.removeUser", 2, 2, arguments.length);
        ag("Firebase.removeUser", 1, a, !1);
        bg("Firebase.removeUser", a, "email");
        bg("Firebase.removeUser", a, "password");
        A("Firebase.removeUser", 2, b, !1);
        this.k.P.Se(a, b);
    };
    U.prototype.removeUser = U.prototype.Se;
    U.prototype.oe = function(a, b) {
        x("Firebase.changePassword", 2, 2, arguments.length);
        ag("Firebase.changePassword", 1, a, !1);
        bg("Firebase.changePassword", a, "email");
        bg("Firebase.changePassword", a, "oldPassword");
        bg("Firebase.changePassword", a, "newPassword");
        A("Firebase.changePassword", 2, b, !1);
        this.k.P.oe(a, b);
    };
    U.prototype.changePassword = U.prototype.oe;
    U.prototype.ne = function(a, b) {
        x("Firebase.changeEmail", 2, 2, arguments.length);
        ag("Firebase.changeEmail", 1, a, !1);
        bg("Firebase.changeEmail", a, "oldEmail");
        bg("Firebase.changeEmail", a, "newEmail");
        bg("Firebase.changeEmail", a, "password");
        A("Firebase.changeEmail", 2, b, !1);
        this.k.P.ne(a, b);
    };
    U.prototype.changeEmail = U.prototype.ne;
    U.prototype.Ue = function(a, b) {
        x("Firebase.resetPassword", 2, 2, arguments.length);
        ag("Firebase.resetPassword", 1, a, !1);
        bg("Firebase.resetPassword", a, "email");
        A("Firebase.resetPassword", 2, b, !1);
        this.k.P.Ue(a, b);
    };
    U.prototype.resetPassword = U.prototype.Ue;
    U.goOffline = function() {
        x("Firebase.goOffline", 0, 0, arguments.length);
        W.ub().yb();
    };
    U.goOnline = function() {
        x("Firebase.goOnline", 0, 0, arguments.length);
        W.ub().qc();
    };
    function Nc(a, b) {
        J(!b || !0 === a || !1 === a, "Can't turn on custom loggers persistently.");
        !0 === a ? ("undefined" !== typeof console && ("function" === typeof console.log ? Ab = q(console.log, console) : "object" === typeof console.log && (Ab = function(a) {
            console.log(a);
        })), b && P.set("logging_enabled", !0)) : a ? Ab = a : (Ab = null, P.remove("logging_enabled"));
    }
    U.enableLogging = Nc;
    U.ServerValue = {
        TIMESTAMP: {
            ".sv": "timestamp"
        }
    };
    U.SDK_VERSION = "2.2.4";
    U.INTERNAL = V;
    U.Context = W;
    U.TEST_ACCESS = Z;
})();
(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
})(this, function() {
    "use strict";
    var hookCallback;
    function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }
    function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    var updateInProgress = false;
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(+config._d);
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }
        return value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function Locale() {}
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && typeof module !== "undefined" && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require("./locale/" + name);
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (typeof values === "undefined") {
                data = locale_locales__getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);
            locale_locales__getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }
    function get_set__get(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function get_set__set(mom, unit, value) {
        return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function getSet(units, value) {
        var unit;
        if (typeof units === "object") {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === "function") {
                return this[units](value);
            }
        }
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0;
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return (sign ? forceSign ? "+" : "" : "-") + output;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === "string") {
            func = function() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = typeof regex === "function" ? regex : function(isStrict) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === "string") {
            token = [ token ];
        }
        if (typeof callback === "number") {
            func = function(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias("month", "M");
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", matchWord);
    addRegexToken("MMMM", matchWord);
    addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
    function localeMonths(m) {
        return this._months[m.month()];
    }
    var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    function localeMonthsShort(m) {
        return this._monthsShort[m.month()];
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = create_utc__createUTC([ 2e3, i ]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
                regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, "Month");
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true, msgWithStack = msg + "\n" + new Error().stack;
        return extend(function() {
            if (firstTime) {
                warn(msgWithStack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ];
    var isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
        var i, l, string = config._i, match = from_string__isoRegex.exec(string);
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += "Z";
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    });
    addFormatToken(0, [ "YYYY", 4 ], 0, "year");
    addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
    addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
    addUnitAlias("year", "y");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken([ "YYYY", "YYYYY", "YYYYYY" ], YEAR);
    addParseToken("YY", function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", false);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week");
    addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = createUTCDate(year, 0, 1).getUTCDay();
        var daysToAdd;
        var dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        }
        return [ now.getFullYear(), now.getMonth(), now.getDate() ];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (!valid__isValid(tempConfig)) {
                continue;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = [ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ];
        configFromArray(config);
    }
    function createFromConfig(config) {
        var input = config._i, format = config._f, res;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || format === undefined && input === "") {
            return valid__createInvalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }
        res = new Moment(checkOverflow(config));
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === "string") {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof input === "object") {
            configFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function() {
        var other = local__createLocal.apply(null, arguments);
        return other < this ? this : other;
    });
    var prototypeMax = deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function() {
        var other = local__createLocal.apply(null, arguments);
        return other > this ? this : other;
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset();
            var sign = "+";
            if (offset < 0) {
                offset = -offset;
                sign = "-";
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchOffset);
    addRegexToken("ZZ", matchOffset);
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(string) {
        var matches = (string || "").match(matchOffset) || [];
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - +res;
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
        return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0, localAdjust;
        if (input != null) {
            if (typeof input === "string") {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, "m");
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, "m"), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== "string") {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === "string") {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!input) {
            input = 0;
        } else {
            input = local__createLocal(input).utcOffset();
        }
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (this._a) {
            var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
            return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
        }
        return false;
    }
    function isLocal() {
        return !this._isUTC;
    }
    function isUtcOffset() {
        return this._isUTC;
    }
    function isUtc() {
        return this._isUTC && this._offset === 0;
    }
    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    function create__createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                d: parseIso(match[4], sign),
                h: parseIso(match[5], sign),
                m: parseIso(match[6], sign),
                s: parseIso(match[7], sign),
                w: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, "Date", get_set__get(mom, "Date") + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }
    var add_subtract__add = createAdder(1, "add");
    var add_subtract__subtract = createAdder(-1, "subtract");
    function moment_calendar__calendar(time) {
        var now = time || local__createLocal(), sod = cloneWithOffset(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
        return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }
    function isBefore(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }
    function isBetween(from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }
    function isSame(input, units) {
        var inputMs;
        units = normalizeUnits(units || "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
        }
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function diff(input, units, asFloat) {
        var that = cloneWithOffset(input, this), zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4, delta, output;
        units = normalizeUnits(units);
        if (units === "year" || units === "month" || units === "quarter") {
            output = monthDiff(this, that);
            if (units === "quarter") {
                output = output / 3;
            } else if (units === "year") {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === "second" ? delta / 1e3 : units === "minute" ? delta / 6e4 : units === "hour" ? delta / 36e5 : units === "day" ? (delta - zoneDelta) / 864e5 : units === "week" ? (delta - zoneDelta) / 6048e5 : delta;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust);
    }
    utils_hooks__hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ("function" === typeof Date.prototype.toISOString) {
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        } else {
            return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        }
    }
    function format(inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        if (units === "week") {
            this.weekday(0);
        }
        if (units === "isoWeek") {
            this.isoWeekday(1);
        }
        if (units === "quarter") {
            this.month(Math.floor(this.month() / 3) * 3);
        }
        return this;
    }
    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond") {
            return this;
        }
        return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
    }
    function to_type__valueOf() {
        return +this._d - (this._offset || 0) * 6e4;
    }
    function unix() {
        return Math.floor(+this / 1e3);
    }
    function toDate() {
        return this._offset ? new Date(+this) : this._d;
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function moment_valid__isValid() {
        return valid__isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    });
    addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function getSetWeekYear(input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add(input - year, "y");
    }
    function getSetISOWeekYear(input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add(input - year, "y");
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    addFormatToken("Q", 0, 0, "quarter");
    addUnitAlias("quarter", "Q");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", [ "DD", 2 ], "Do", "date");
    addUnitAlias("date", "D");
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken([ "D", "DD" ], DATE);
    addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", matchWord);
    addRegexToken("ddd", matchWord);
    addRegexToken("dddd", matchWord);
    addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = locale.weekdaysParse(input);
                if (typeof input !== "number") {
                    return null;
                }
            }
        }
        return input;
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    function localeWeekdays(m) {
        return this._weekdays[m.day()];
    }
    var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()];
    }
    var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()];
    }
    function localeWeekdaysParse(weekdayName) {
        var i, mom, regex;
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([ 2e3, 1 ]).day(i);
                regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour");
    addFormatToken("h", [ "hh", 2 ], 0, function() {
        return this.hours() % 12 || 12;
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addParseToken([ "H", "HH" ], HOUR);
    addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? "pm" : "PM";
        } else {
            return isLower ? "am" : "AM";
        }
    }
    var getSetHour = makeGetSet("Hours", true);
    addFormatToken("m", [ "mm", 2 ], 0, "minute");
    addUnitAlias("minute", "m");
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", [ "ss", 2 ], 0, "second");
    addUnitAlias("second", "s");
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    });
    function millisecond__milliseconds(token) {
        addFormatToken(0, [ token, 3 ], 0, "millisecond");
    }
    millisecond__milliseconds("SSS");
    millisecond__milliseconds("SSSS");
    addUnitAlias("millisecond", "ms");
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    addRegexToken("SSSS", matchUnsigned);
    addParseToken([ "S", "SS", "SSS", "SSSS" ], function(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
    });
    var getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = moment_format__toISOString;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    momentPrototype__proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    momentPrototype__proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    momentPrototype__proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", getSetZone);
    var momentPrototype = momentPrototype__proto;
    function moment__createUnix(input) {
        return local__createLocal(input * 1e3);
    }
    function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
    }
    var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    };
    function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return typeof output === "function" ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY LT",
        LLLL: "dddd, MMMM D, YYYY LT"
    };
    function longDateFormat(key) {
        var output = this._longDateFormat[key];
        if (!output && this._longDateFormat[key.toUpperCase()]) {
            output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                return val.slice(1);
            });
            this._longDateFormat[key] = output;
        }
        return output;
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = "%d";
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    function preParsePostFormat(string) {
        return string;
    }
    var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
    }
    function locale_set__set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === "function") {
                this[i] = prop;
            } else {
                this["_" + i] = prop;
            }
        }
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
    }
    var prototype__proto = Locale.prototype;
    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function list(format, index, field, count, setter) {
        if (typeof format === "number") {
            index = format;
            format = undefined;
        }
        format = format || "";
        if (index != null) {
            return lists__get(format, index, field, setter);
        }
        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }
    function lists__listMonths(format, index) {
        return list(format, index, "months", 12, "month");
    }
    function lists__listMonthsShort(format, index) {
        return list(format, index, "monthsShort", 12, "month");
    }
    function lists__listWeekdays(format, index) {
        return list(format, index, "weekdays", 7, "day");
    }
    function lists__listWeekdaysShort(format, index) {
        return list(format, index, "weekdaysShort", 7, "day");
    }
    function lists__listWeekdaysMin(format, index) {
        return list(format, index, "weekdaysMin", 7, "day");
    }
    locale_locales__getSetGlobalLocale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    utils_hooks__hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years = 0;
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        years = absFloor(daysToYears(days));
        days -= absFloor(yearsToDays(years));
        months += absFloor(days / 30);
        days %= 30;
        years += absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToYears(days) {
        return days * 400 / 146097;
    }
    function yearsToDays(years) {
        return years * 146097 / 400;
    }
    function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "year") {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToYears(days) * 12;
            return units === "month" ? months : months / 12;
        } else {
            days = this._days + Math.round(yearsToDays(this._months / 12));
            switch (units) {
              case "week":
                return days / 7 + milliseconds / 6048e5;

              case "day":
                return days + milliseconds / 864e5;

              case "hour":
                return days * 24 + milliseconds / 36e5;

              case "minute":
                return days * 1440 + milliseconds / 6e4;

              case "second":
                return days * 86400 + milliseconds / 1e3;

              case "millisecond":
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error("Unknown unit " + units);
            }
        }
    }
    function duration_as__valueOf() {
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs("ms");
    var asSeconds = makeAs("s");
    var asMinutes = makeAs("m");
    var asHours = makeAs("h");
    var asDays = makeAs("d");
    var asWeeks = makeAs("w");
    var asMonths = makeAs("M");
    var asYears = makeAs("y");
    function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + "s"]();
    }
    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }
    var duration_get__milliseconds = makeGetter("milliseconds");
    var seconds = makeGetter("seconds");
    var minutes = makeGetter("minutes");
    var hours = makeGetter("hours");
    var days = makeGetter("days");
    var months = makeGetter("months");
    var years = makeGetter("years");
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as("s"));
        var minutes = round(duration.as("m"));
        var hours = round(duration.as("h"));
        var days = round(duration.as("d"));
        var months = round(duration.as("M"));
        var years = round(duration.as("y"));
        var a = seconds < thresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }
    function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
        var Y = iso_string__abs(this.years());
        var M = iso_string__abs(this.months());
        var D = iso_string__abs(this.days());
        var h = iso_string__abs(this.hours());
        var m = iso_string__abs(this.minutes());
        var s = iso_string__abs(this.seconds() + this.milliseconds() / 1e3);
        var total = this.asSeconds();
        if (!total) {
            return "P0D";
        }
        return (total < 0 ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "");
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = duration_get__milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = "2.10.3";
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    var _moment = utils_hooks__hooks;
    return _moment;
});
(function(exports) {
    "use strict";
    angular.module("firebase", []).value("Firebase", exports.Firebase);
})(window);

(function() {
    "use strict";
    angular.module("firebase").factory("$firebaseArray", [ "$log", "$firebaseUtils", function($log, $firebaseUtils) {
        function FirebaseArray(ref) {
            if (!(this instanceof FirebaseArray)) {
                return new FirebaseArray(ref);
            }
            var self = this;
            this._observers = [];
            this.$list = [];
            this._ref = ref;
            this._sync = new ArraySyncManager(this);
            $firebaseUtils.assertValidRef(ref, "Must pass a valid Firebase reference " + "to $firebaseArray (not a string or URL)");
            this._indexCache = {};
            $firebaseUtils.getPublicMethods(self, function(fn, key) {
                self.$list[key] = fn.bind(self);
            });
            this._sync.init(this.$list);
            return this.$list;
        }
        FirebaseArray.prototype = {
            $add: function(data) {
                this._assertNotDestroyed("$add");
                var def = $firebaseUtils.defer();
                var ref = this.$ref().ref().push();
                ref.set($firebaseUtils.toJSON(data), $firebaseUtils.makeNodeResolver(def));
                return def.promise.then(function() {
                    return ref;
                });
            },
            $save: function(indexOrItem) {
                this._assertNotDestroyed("$save");
                var self = this;
                var item = self._resolveItem(indexOrItem);
                var key = self.$keyAt(item);
                if (key !== null) {
                    var ref = self.$ref().ref().child(key);
                    var data = $firebaseUtils.toJSON(item);
                    return $firebaseUtils.doSet(ref, data).then(function() {
                        self.$$notify("child_changed", key);
                        return ref;
                    });
                } else {
                    return $firebaseUtils.reject("Invalid record; could determine key for " + indexOrItem);
                }
            },
            $remove: function(indexOrItem) {
                this._assertNotDestroyed("$remove");
                var key = this.$keyAt(indexOrItem);
                if (key !== null) {
                    var ref = this.$ref().ref().child(key);
                    return $firebaseUtils.doRemove(ref).then(function() {
                        return ref;
                    });
                } else {
                    return $firebaseUtils.reject("Invalid record; could not determine key for " + indexOrItem);
                }
            },
            $keyAt: function(indexOrItem) {
                var item = this._resolveItem(indexOrItem);
                return this.$$getKey(item);
            },
            $indexFor: function(key) {
                var self = this;
                var cache = self._indexCache;
                if (!cache.hasOwnProperty(key) || self.$keyAt(cache[key]) !== key) {
                    var pos = self.$list.findIndex(function(rec) {
                        return self.$$getKey(rec) === key;
                    });
                    if (pos !== -1) {
                        cache[key] = pos;
                    }
                }
                return cache.hasOwnProperty(key) ? cache[key] : -1;
            },
            $loaded: function(resolve, reject) {
                var promise = this._sync.ready();
                if (arguments.length) {
                    promise = promise.then.call(promise, resolve, reject);
                }
                return promise;
            },
            $ref: function() {
                return this._ref;
            },
            $watch: function(cb, context) {
                var list = this._observers;
                list.push([ cb, context ]);
                return function() {
                    var i = list.findIndex(function(parts) {
                        return parts[0] === cb && parts[1] === context;
                    });
                    if (i > -1) {
                        list.splice(i, 1);
                    }
                };
            },
            $destroy: function(err) {
                if (!this._isDestroyed) {
                    this._isDestroyed = true;
                    this._sync.destroy(err);
                    this.$list.length = 0;
                }
            },
            $getRecord: function(key) {
                var i = this.$indexFor(key);
                return i > -1 ? this.$list[i] : null;
            },
            $$added: function(snap) {
                var i = this.$indexFor($firebaseUtils.getKey(snap));
                if (i === -1) {
                    var rec = snap.val();
                    if (!angular.isObject(rec)) {
                        rec = {
                            $value: rec
                        };
                    }
                    rec.$id = $firebaseUtils.getKey(snap);
                    rec.$priority = snap.getPriority();
                    $firebaseUtils.applyDefaults(rec, this.$$defaults);
                    return rec;
                }
                return false;
            },
            $$removed: function(snap) {
                return this.$indexFor($firebaseUtils.getKey(snap)) > -1;
            },
            $$updated: function(snap) {
                var changed = false;
                var rec = this.$getRecord($firebaseUtils.getKey(snap));
                if (angular.isObject(rec)) {
                    changed = $firebaseUtils.updateRec(rec, snap);
                    $firebaseUtils.applyDefaults(rec, this.$$defaults);
                }
                return changed;
            },
            $$moved: function(snap) {
                var rec = this.$getRecord($firebaseUtils.getKey(snap));
                if (angular.isObject(rec)) {
                    rec.$priority = snap.getPriority();
                    return true;
                }
                return false;
            },
            $$error: function(err) {
                $log.error(err);
                this.$destroy(err);
            },
            $$getKey: function(rec) {
                return angular.isObject(rec) ? rec.$id : null;
            },
            $$process: function(event, rec, prevChild) {
                var key = this.$$getKey(rec);
                var changed = false;
                var curPos;
                switch (event) {
                  case "child_added":
                    curPos = this.$indexFor(key);
                    break;

                  case "child_moved":
                    curPos = this.$indexFor(key);
                    this._spliceOut(key);
                    break;

                  case "child_removed":
                    changed = this._spliceOut(key) !== null;
                    break;

                  case "child_changed":
                    changed = true;
                    break;

                  default:
                    throw new Error("Invalid event type: " + event);
                }
                if (angular.isDefined(curPos)) {
                    changed = this._addAfter(rec, prevChild) !== curPos;
                }
                if (changed) {
                    this.$$notify(event, key, prevChild);
                }
                return changed;
            },
            $$notify: function(event, key, prevChild) {
                var eventData = {
                    event: event,
                    key: key
                };
                if (angular.isDefined(prevChild)) {
                    eventData.prevChild = prevChild;
                }
                angular.forEach(this._observers, function(parts) {
                    parts[0].call(parts[1], eventData);
                });
            },
            _addAfter: function(rec, prevChild) {
                var i;
                if (prevChild === null) {
                    i = 0;
                } else {
                    i = this.$indexFor(prevChild) + 1;
                    if (i === 0) {
                        i = this.$list.length;
                    }
                }
                this.$list.splice(i, 0, rec);
                this._indexCache[this.$$getKey(rec)] = i;
                return i;
            },
            _spliceOut: function(key) {
                var i = this.$indexFor(key);
                if (i > -1) {
                    delete this._indexCache[key];
                    return this.$list.splice(i, 1)[0];
                }
                return null;
            },
            _resolveItem: function(indexOrItem) {
                var list = this.$list;
                if (angular.isNumber(indexOrItem) && indexOrItem >= 0 && list.length >= indexOrItem) {
                    return list[indexOrItem];
                } else if (angular.isObject(indexOrItem)) {
                    var key = this.$$getKey(indexOrItem);
                    var rec = this.$getRecord(key);
                    return rec === indexOrItem ? rec : null;
                }
                return null;
            },
            _assertNotDestroyed: function(method) {
                if (this._isDestroyed) {
                    throw new Error("Cannot call " + method + " method on a destroyed $firebaseArray object");
                }
            }
        };
        FirebaseArray.$extend = function(ChildClass, methods) {
            if (arguments.length === 1 && angular.isObject(ChildClass)) {
                methods = ChildClass;
                ChildClass = function(ref) {
                    if (!(this instanceof ChildClass)) {
                        return new ChildClass(ref);
                    }
                    FirebaseArray.apply(this, arguments);
                    return this.$list;
                };
            }
            return $firebaseUtils.inherit(ChildClass, FirebaseArray, methods);
        };
        function ArraySyncManager(firebaseArray) {
            function destroy(err) {
                if (!sync.isDestroyed) {
                    sync.isDestroyed = true;
                    var ref = firebaseArray.$ref();
                    ref.off("child_added", created);
                    ref.off("child_moved", moved);
                    ref.off("child_changed", updated);
                    ref.off("child_removed", removed);
                    firebaseArray = null;
                    initComplete(err || "destroyed");
                }
            }
            function init($list) {
                var ref = firebaseArray.$ref();
                ref.on("child_added", created, error);
                ref.on("child_moved", moved, error);
                ref.on("child_changed", updated, error);
                ref.on("child_removed", removed, error);
                ref.once("value", function(snap) {
                    if (angular.isArray(snap.val())) {
                        $log.warn("Storing data using array indices in Firebase can result in unexpected behavior. See https://www.firebase.com/docs/web/guide/understanding-data.html#section-arrays-in-firebase for more information.");
                    }
                    initComplete(null, $list);
                }, initComplete);
            }
            function _initComplete(err, result) {
                if (!isResolved) {
                    isResolved = true;
                    if (err) {
                        def.reject(err);
                    } else {
                        def.resolve(result);
                    }
                }
            }
            var def = $firebaseUtils.defer();
            var created = function(snap, prevChild) {
                var rec = firebaseArray.$$added(snap, prevChild);
                $firebaseUtils.whenUnwrapped(rec, function(rec) {
                    firebaseArray.$$process("child_added", rec, prevChild);
                });
            };
            var updated = function(snap) {
                var rec = firebaseArray.$getRecord($firebaseUtils.getKey(snap));
                if (rec) {
                    var res = firebaseArray.$$updated(snap);
                    $firebaseUtils.whenUnwrapped(res, function() {
                        firebaseArray.$$process("child_changed", rec);
                    });
                }
            };
            var moved = function(snap, prevChild) {
                var rec = firebaseArray.$getRecord($firebaseUtils.getKey(snap));
                if (rec) {
                    var res = firebaseArray.$$moved(snap, prevChild);
                    $firebaseUtils.whenUnwrapped(res, function() {
                        firebaseArray.$$process("child_moved", rec, prevChild);
                    });
                }
            };
            var removed = function(snap) {
                var rec = firebaseArray.$getRecord($firebaseUtils.getKey(snap));
                if (rec) {
                    var res = firebaseArray.$$removed(snap);
                    $firebaseUtils.whenUnwrapped(res, function() {
                        firebaseArray.$$process("child_removed", rec);
                    });
                }
            };
            var isResolved = false;
            var error = $firebaseUtils.batch(function(err) {
                _initComplete(err);
                if (firebaseArray) {
                    firebaseArray.$$error(err);
                }
            });
            var initComplete = $firebaseUtils.batch(_initComplete);
            var sync = {
                destroy: destroy,
                isDestroyed: false,
                init: init,
                ready: function() {
                    return def.promise;
                }
            };
            return sync;
        }
        return FirebaseArray;
    } ]);
    angular.module("firebase").factory("$FirebaseArray", [ "$log", "$firebaseArray", function($log, $firebaseArray) {
        return function() {
            $log.warn("$FirebaseArray has been renamed. Use $firebaseArray instead.");
            return $firebaseArray.apply(null, arguments);
        };
    } ]);
})();

(function() {
    "use strict";
    var FirebaseAuth;
    angular.module("firebase").factory("$firebaseAuth", [ "$q", "$firebaseUtils", function($q, $firebaseUtils) {
        return function(ref) {
            var auth = new FirebaseAuth($q, $firebaseUtils, ref);
            return auth.construct();
        };
    } ]);
    FirebaseAuth = function($q, $firebaseUtils, ref) {
        this._q = $q;
        this._utils = $firebaseUtils;
        if (typeof ref === "string") {
            throw new Error("Please provide a Firebase reference instead of a URL when creating a `$firebaseAuth` object.");
        }
        this._ref = ref;
        this._initialAuthResolver = this._initAuthResolver();
    };
    FirebaseAuth.prototype = {
        construct: function() {
            this._object = {
                $authWithCustomToken: this.authWithCustomToken.bind(this),
                $authAnonymously: this.authAnonymously.bind(this),
                $authWithPassword: this.authWithPassword.bind(this),
                $authWithOAuthPopup: this.authWithOAuthPopup.bind(this),
                $authWithOAuthRedirect: this.authWithOAuthRedirect.bind(this),
                $authWithOAuthToken: this.authWithOAuthToken.bind(this),
                $unauth: this.unauth.bind(this),
                $onAuth: this.onAuth.bind(this),
                $getAuth: this.getAuth.bind(this),
                $requireAuth: this.requireAuth.bind(this),
                $waitForAuth: this.waitForAuth.bind(this),
                $createUser: this.createUser.bind(this),
                $changePassword: this.changePassword.bind(this),
                $changeEmail: this.changeEmail.bind(this),
                $removeUser: this.removeUser.bind(this),
                $resetPassword: this.resetPassword.bind(this)
            };
            return this._object;
        },
        authWithCustomToken: function(authToken, options) {
            var deferred = this._q.defer();
            try {
                this._ref.authWithCustomToken(authToken, this._utils.makeNodeResolver(deferred), options);
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        authAnonymously: function(options) {
            var deferred = this._q.defer();
            try {
                this._ref.authAnonymously(this._utils.makeNodeResolver(deferred), options);
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        authWithPassword: function(credentials, options) {
            var deferred = this._q.defer();
            try {
                this._ref.authWithPassword(credentials, this._utils.makeNodeResolver(deferred), options);
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        authWithOAuthPopup: function(provider, options) {
            var deferred = this._q.defer();
            try {
                this._ref.authWithOAuthPopup(provider, this._utils.makeNodeResolver(deferred), options);
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        authWithOAuthRedirect: function(provider, options) {
            var deferred = this._q.defer();
            try {
                this._ref.authWithOAuthRedirect(provider, this._utils.makeNodeResolver(deferred), options);
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        authWithOAuthToken: function(provider, credentials, options) {
            var deferred = this._q.defer();
            try {
                this._ref.authWithOAuthToken(provider, credentials, this._utils.makeNodeResolver(deferred), options);
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        unauth: function() {
            if (this.getAuth() !== null) {
                this._ref.unauth();
            }
        },
        onAuth: function(callback, context) {
            var self = this;
            var fn = this._utils.debounce(callback, context, 0);
            this._ref.onAuth(fn);
            return function() {
                self._ref.offAuth(fn);
            };
        },
        getAuth: function() {
            return this._ref.getAuth();
        },
        _routerMethodOnAuthPromise: function(rejectIfAuthDataIsNull) {
            var ref = this._ref, utils = this._utils;
            return this._initialAuthResolver.then(function() {
                var authData = ref.getAuth(), res = null;
                if (rejectIfAuthDataIsNull && authData === null) {
                    res = utils.reject("AUTH_REQUIRED");
                } else {
                    res = utils.resolve(authData);
                }
                return res;
            });
        },
        _initAuthResolver: function() {
            var ref = this._ref;
            return this._utils.promise(function(resolve) {
                function callback() {
                    ref.offAuth(callback);
                    resolve();
                }
                ref.onAuth(callback);
            });
        },
        requireAuth: function() {
            return this._routerMethodOnAuthPromise(true);
        },
        waitForAuth: function() {
            return this._routerMethodOnAuthPromise(false);
        },
        createUser: function(credentials) {
            var deferred = this._q.defer();
            if (typeof credentials === "string") {
                throw new Error("$createUser() expects an object containing 'email' and 'password', but got a string.");
            }
            try {
                this._ref.createUser(credentials, this._utils.makeNodeResolver(deferred));
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        changePassword: function(credentials) {
            var deferred = this._q.defer();
            if (typeof credentials === "string") {
                throw new Error("$changePassword() expects an object containing 'email', 'oldPassword', and 'newPassword', but got a string.");
            }
            try {
                this._ref.changePassword(credentials, this._utils.makeNodeResolver(deferred));
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        changeEmail: function(credentials) {
            var deferred = this._q.defer();
            if (typeof this._ref.changeEmail !== "function") {
                throw new Error("$firebaseAuth.$changeEmail() requires Firebase version 2.1.0 or greater.");
            } else if (typeof credentials === "string") {
                throw new Error("$changeEmail() expects an object containing 'oldEmail', 'newEmail', and 'password', but got a string.");
            }
            try {
                this._ref.changeEmail(credentials, this._utils.makeNodeResolver(deferred));
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        removeUser: function(credentials) {
            var deferred = this._q.defer();
            if (typeof credentials === "string") {
                throw new Error("$removeUser() expects an object containing 'email' and 'password', but got a string.");
            }
            try {
                this._ref.removeUser(credentials, this._utils.makeNodeResolver(deferred));
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        },
        resetPassword: function(credentials) {
            var deferred = this._q.defer();
            if (typeof credentials === "string") {
                throw new Error("$resetPassword() expects an object containing 'email', but got a string.");
            }
            try {
                this._ref.resetPassword(credentials, this._utils.makeNodeResolver(deferred));
            } catch (error) {
                deferred.reject(error);
            }
            return deferred.promise;
        }
    };
})();

(function() {
    "use strict";
    angular.module("firebase").factory("$firebaseObject", [ "$parse", "$firebaseUtils", "$log", function($parse, $firebaseUtils, $log) {
        function FirebaseObject(ref) {
            if (!(this instanceof FirebaseObject)) {
                return new FirebaseObject(ref);
            }
            this.$$conf = {
                sync: new ObjectSyncManager(this, ref),
                ref: ref,
                binding: new ThreeWayBinding(this),
                listeners: []
            };
            Object.defineProperty(this, "$$conf", {
                value: this.$$conf
            });
            this.$id = $firebaseUtils.getKey(ref.ref());
            this.$priority = null;
            $firebaseUtils.applyDefaults(this, this.$$defaults);
            this.$$conf.sync.init();
        }
        FirebaseObject.prototype = {
            $save: function() {
                var self = this;
                var ref = self.$ref();
                var data = $firebaseUtils.toJSON(self);
                return $firebaseUtils.doSet(ref, data).then(function() {
                    self.$$notify();
                    return self.$ref();
                });
            },
            $remove: function() {
                var self = this;
                $firebaseUtils.trimKeys(self, {});
                self.$value = null;
                return $firebaseUtils.doRemove(self.$ref()).then(function() {
                    self.$$notify();
                    return self.$ref();
                });
            },
            $loaded: function(resolve, reject) {
                var promise = this.$$conf.sync.ready();
                if (arguments.length) {
                    promise = promise.then.call(promise, resolve, reject);
                }
                return promise;
            },
            $ref: function() {
                return this.$$conf.ref;
            },
            $bindTo: function(scope, varName) {
                var self = this;
                return self.$loaded().then(function() {
                    return self.$$conf.binding.bindTo(scope, varName);
                });
            },
            $watch: function(cb, context) {
                var list = this.$$conf.listeners;
                list.push([ cb, context ]);
                return function() {
                    var i = list.findIndex(function(parts) {
                        return parts[0] === cb && parts[1] === context;
                    });
                    if (i > -1) {
                        list.splice(i, 1);
                    }
                };
            },
            $destroy: function(err) {
                var self = this;
                if (!self.$isDestroyed) {
                    self.$isDestroyed = true;
                    self.$$conf.sync.destroy(err);
                    self.$$conf.binding.destroy();
                    $firebaseUtils.each(self, function(v, k) {
                        delete self[k];
                    });
                }
            },
            $$updated: function(snap) {
                var changed = $firebaseUtils.updateRec(this, snap);
                $firebaseUtils.applyDefaults(this, this.$$defaults);
                return changed;
            },
            $$error: function(err) {
                $log.error(err);
                this.$destroy(err);
            },
            $$scopeUpdated: function(newData) {
                var def = $firebaseUtils.defer();
                this.$ref().set($firebaseUtils.toJSON(newData), $firebaseUtils.makeNodeResolver(def));
                return def.promise;
            },
            $$notify: function() {
                var self = this, list = this.$$conf.listeners.slice();
                angular.forEach(list, function(parts) {
                    parts[0].call(parts[1], {
                        event: "value",
                        key: self.$id
                    });
                });
            },
            forEach: function(iterator, context) {
                return $firebaseUtils.each(this, iterator, context);
            }
        };
        FirebaseObject.$extend = function(ChildClass, methods) {
            if (arguments.length === 1 && angular.isObject(ChildClass)) {
                methods = ChildClass;
                ChildClass = function(ref) {
                    if (!(this instanceof ChildClass)) {
                        return new ChildClass(ref);
                    }
                    FirebaseObject.apply(this, arguments);
                };
            }
            return $firebaseUtils.inherit(ChildClass, FirebaseObject, methods);
        };
        function ThreeWayBinding(rec) {
            this.subs = [];
            this.scope = null;
            this.key = null;
            this.rec = rec;
        }
        ThreeWayBinding.prototype = {
            assertNotBound: function(varName) {
                if (this.scope) {
                    var msg = "Cannot bind to " + varName + " because this instance is already bound to " + this.key + "; one binding per instance " + "(call unbind method or create another FirebaseObject instance)";
                    $log.error(msg);
                    return $firebaseUtils.reject(msg);
                }
            },
            bindTo: function(scope, varName) {
                function _bind(self) {
                    var sending = false;
                    var parsed = $parse(varName);
                    var rec = self.rec;
                    self.scope = scope;
                    self.varName = varName;
                    function equals(scopeValue) {
                        return angular.equals(scopeValue, rec) && scopeValue.$priority === rec.$priority && scopeValue.$value === rec.$value;
                    }
                    function setScope(rec) {
                        parsed.assign(scope, $firebaseUtils.scopeData(rec));
                    }
                    var send = $firebaseUtils.debounce(function(val) {
                        var scopeData = $firebaseUtils.scopeData(val);
                        rec.$$scopeUpdated(scopeData)["finally"](function() {
                            sending = false;
                            if (!scopeData.hasOwnProperty("$value")) {
                                delete rec.$value;
                                delete parsed(scope).$value;
                            }
                        });
                    }, 50, 500);
                    var scopeUpdated = function(newVal) {
                        newVal = newVal[0];
                        if (!equals(newVal)) {
                            sending = true;
                            send(newVal);
                        }
                    };
                    var recUpdated = function() {
                        if (!sending && !equals(parsed(scope))) {
                            setScope(rec);
                        }
                    };
                    function watchExp() {
                        var obj = parsed(scope);
                        return [ obj, obj.$priority, obj.$value ];
                    }
                    setScope(rec);
                    self.subs.push(scope.$on("$destroy", self.unbind.bind(self)));
                    self.subs.push(scope.$watch(watchExp, scopeUpdated, true));
                    self.subs.push(rec.$watch(recUpdated));
                    return self.unbind.bind(self);
                }
                return this.assertNotBound(varName) || _bind(this);
            },
            unbind: function() {
                if (this.scope) {
                    angular.forEach(this.subs, function(unbind) {
                        unbind();
                    });
                    this.subs = [];
                    this.scope = null;
                    this.key = null;
                }
            },
            destroy: function() {
                this.unbind();
                this.rec = null;
            }
        };
        function ObjectSyncManager(firebaseObject, ref) {
            function destroy(err) {
                if (!sync.isDestroyed) {
                    sync.isDestroyed = true;
                    ref.off("value", applyUpdate);
                    firebaseObject = null;
                    initComplete(err || "destroyed");
                }
            }
            function init() {
                ref.on("value", applyUpdate, error);
                ref.once("value", function(snap) {
                    if (angular.isArray(snap.val())) {
                        $log.warn("Storing data using array indices in Firebase can result in unexpected behavior. See https://www.firebase.com/docs/web/guide/understanding-data.html#section-arrays-in-firebase for more information. Also note that you probably wanted $firebaseArray and not $firebaseObject.");
                    }
                    initComplete(null);
                }, initComplete);
            }
            function _initComplete(err) {
                if (!isResolved) {
                    isResolved = true;
                    if (err) {
                        def.reject(err);
                    } else {
                        def.resolve(firebaseObject);
                    }
                }
            }
            var isResolved = false;
            var def = $firebaseUtils.defer();
            var applyUpdate = $firebaseUtils.batch(function(snap) {
                var changed = firebaseObject.$$updated(snap);
                if (changed) {
                    firebaseObject.$$notify();
                }
            });
            var error = $firebaseUtils.batch(function(err) {
                _initComplete(err);
                if (firebaseObject) {
                    firebaseObject.$$error(err);
                }
            });
            var initComplete = $firebaseUtils.batch(_initComplete);
            var sync = {
                isDestroyed: false,
                destroy: destroy,
                init: init,
                ready: function() {
                    return def.promise;
                }
            };
            return sync;
        }
        return FirebaseObject;
    } ]);
    angular.module("firebase").factory("$FirebaseObject", [ "$log", "$firebaseObject", function($log, $firebaseObject) {
        return function() {
            $log.warn("$FirebaseObject has been renamed. Use $firebaseObject instead.");
            return $firebaseObject.apply(null, arguments);
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("firebase").factory("$firebase", function() {
        return function() {
            throw new Error("$firebase has been removed. You may instantiate $firebaseArray and $firebaseObject " + "directly now. For simple write operations, just use the Firebase ref directly. " + "See the AngularFire 1.0.0 changelog for details: https://www.firebase.com/docs/web/libraries/angular/changelog.html");
        };
    });
})();

"use strict";

if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(searchElement, fromIndex) {
        if (this === undefined || this === null) {
            throw new TypeError("'this' is null or not defined");
        }
        var length = this.length >>> 0;
        fromIndex = +fromIndex || 0;
        if (Math.abs(fromIndex) === Infinity) {
            fromIndex = 0;
        }
        if (fromIndex < 0) {
            fromIndex += length;
            if (fromIndex < 0) {
                fromIndex = 0;
            }
        }
        for (;fromIndex < length; fromIndex++) {
            if (this[fromIndex] === searchElement) {
                return fromIndex;
            }
        }
        return -1;
    };
}

if (!Function.prototype.bind) {
    Function.prototype.bind = function(oThis) {
        if (typeof this !== "function") {
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}

if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, "findIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function(predicate) {
            if (this == null) {
                throw new TypeError("Array.prototype.find called on null or undefined");
            }
            if (typeof predicate !== "function") {
                throw new TypeError("predicate must be a function");
            }
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;
            for (var i = 0; i < length; i++) {
                if (i in list) {
                    value = list[i];
                    if (predicate.call(thisArg, value, i, list)) {
                        return i;
                    }
                }
            }
            return -1;
        }
    });
}

if (typeof Object.create != "function") {
    (function() {
        var F = function() {};
        Object.create = function(o) {
            if (arguments.length > 1) {
                throw new Error("Second argument not supported");
            }
            if (o === null) {
                throw new Error("Cannot set a null [[Prototype]]");
            }
            if (typeof o != "object") {
                throw new TypeError("Argument must be an object");
            }
            F.prototype = o;
            return new F();
        };
    })();
}

if (!Object.keys) {
    Object.keys = function() {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{
            toString: null
        }.propertyIsEnumerable("toString"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], dontEnumsLength = dontEnums.length;
        return function(obj) {
            if (typeof obj !== "object" && (typeof obj !== "function" || obj === null)) {
                throw new TypeError("Object.keys called on non-object");
            }
            var result = [], prop, i;
            for (prop in obj) {
                if (hasOwnProperty.call(obj, prop)) {
                    result.push(prop);
                }
            }
            if (hasDontEnumBug) {
                for (i = 0; i < dontEnumsLength; i++) {
                    if (hasOwnProperty.call(obj, dontEnums[i])) {
                        result.push(dontEnums[i]);
                    }
                }
            }
            return result;
        };
    }();
}

if (typeof Object.getPrototypeOf !== "function") {
    if (typeof "test".__proto__ === "object") {
        Object.getPrototypeOf = function(object) {
            return object.__proto__;
        };
    } else {
        Object.getPrototypeOf = function(object) {
            return object.constructor.prototype;
        };
    }
}

(function() {
    "use strict";
    angular.module("firebase").factory("$firebaseConfig", [ "$firebaseArray", "$firebaseObject", "$injector", function($firebaseArray, $firebaseObject, $injector) {
        return function(configOpts) {
            var opts = angular.extend({}, configOpts);
            if (typeof opts.objectFactory === "string") {
                opts.objectFactory = $injector.get(opts.objectFactory);
            }
            if (typeof opts.arrayFactory === "string") {
                opts.arrayFactory = $injector.get(opts.arrayFactory);
            }
            return angular.extend({
                arrayFactory: $firebaseArray,
                objectFactory: $firebaseObject
            }, opts);
        };
    } ]).factory("$firebaseUtils", [ "$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
        function Q(resolver) {
            if (!angular.isFunction(resolver)) {
                throw new Error("missing resolver function");
            }
            var deferred = $q.defer();
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            resolver(resolveFn, rejectFn);
            return deferred.promise;
        }
        var utils = {
            batch: function(action, context) {
                return function() {
                    var args = Array.prototype.slice.call(arguments, 0);
                    utils.compile(function() {
                        action.apply(context, args);
                    });
                };
            },
            debounce: function(fn, ctx, wait, maxWait) {
                var start, cancelTimer, args, runScheduledForNextTick;
                if (typeof ctx === "number") {
                    maxWait = wait;
                    wait = ctx;
                    ctx = null;
                }
                if (typeof wait !== "number") {
                    throw new Error("Must provide a valid integer for wait. Try 0 for a default");
                }
                if (typeof fn !== "function") {
                    throw new Error("Must provide a valid function to debounce");
                }
                if (!maxWait) {
                    maxWait = wait * 10 || 100;
                }
                function resetTimer() {
                    if (cancelTimer) {
                        cancelTimer();
                        cancelTimer = null;
                    }
                    if (start && Date.now() - start > maxWait) {
                        if (!runScheduledForNextTick) {
                            runScheduledForNextTick = true;
                            utils.compile(runNow);
                        }
                    } else {
                        if (!start) {
                            start = Date.now();
                        }
                        cancelTimer = utils.wait(runNow, wait);
                    }
                }
                function runNow() {
                    cancelTimer = null;
                    start = null;
                    runScheduledForNextTick = false;
                    fn.apply(ctx, args);
                }
                function debounced() {
                    args = Array.prototype.slice.call(arguments, 0);
                    resetTimer();
                }
                debounced.running = function() {
                    return start > 0;
                };
                return debounced;
            },
            assertValidRef: function(ref, msg) {
                if (!angular.isObject(ref) || typeof ref.ref !== "function" || typeof ref.ref().transaction !== "function") {
                    throw new Error(msg || "Invalid Firebase reference");
                }
            },
            inherit: function(ChildClass, ParentClass, methods) {
                var childMethods = ChildClass.prototype;
                ChildClass.prototype = Object.create(ParentClass.prototype);
                ChildClass.prototype.constructor = ChildClass;
                angular.forEach(Object.keys(childMethods), function(k) {
                    ChildClass.prototype[k] = childMethods[k];
                });
                if (angular.isObject(methods)) {
                    angular.extend(ChildClass.prototype, methods);
                }
                return ChildClass;
            },
            getPrototypeMethods: function(inst, iterator, context) {
                var methods = {};
                var objProto = Object.getPrototypeOf({});
                var proto = angular.isFunction(inst) && angular.isObject(inst.prototype) ? inst.prototype : Object.getPrototypeOf(inst);
                while (proto && proto !== objProto) {
                    for (var key in proto) {
                        if (proto.hasOwnProperty(key) && !methods.hasOwnProperty(key)) {
                            methods[key] = true;
                            iterator.call(context, proto[key], key, proto);
                        }
                    }
                    proto = Object.getPrototypeOf(proto);
                }
            },
            getPublicMethods: function(inst, iterator, context) {
                utils.getPrototypeMethods(inst, function(m, k) {
                    if (typeof m === "function" && k.charAt(0) !== "_") {
                        iterator.call(context, m, k);
                    }
                });
            },
            defer: $q.defer,
            reject: $q.reject,
            resolve: $q.when,
            whenUnwrapped: function(possiblePromise, callback) {
                if (possiblePromise) {
                    utils.resolve(possiblePromise).then(function(res) {
                        if (res) {
                            callback(res);
                        }
                    });
                }
            },
            promise: angular.isFunction($q) ? $q : Q,
            makeNodeResolver: function(deferred) {
                return function(err, result) {
                    if (err === null) {
                        if (arguments.length > 2) {
                            result = Array.prototype.slice.call(arguments, 1);
                        }
                        deferred.resolve(result);
                    } else {
                        deferred.reject(err);
                    }
                };
            },
            wait: function(fn, wait) {
                var to = $timeout(fn, wait || 0);
                return function() {
                    if (to) {
                        $timeout.cancel(to);
                        to = null;
                    }
                };
            },
            compile: function(fn) {
                return $rootScope.$evalAsync(fn || function() {});
            },
            deepCopy: function(obj) {
                if (!angular.isObject(obj)) {
                    return obj;
                }
                var newCopy = angular.isArray(obj) ? obj.slice() : angular.extend({}, obj);
                for (var key in newCopy) {
                    if (newCopy.hasOwnProperty(key)) {
                        if (angular.isObject(newCopy[key])) {
                            newCopy[key] = utils.deepCopy(newCopy[key]);
                        }
                    }
                }
                return newCopy;
            },
            trimKeys: function(dest, source) {
                utils.each(dest, function(v, k) {
                    if (!source.hasOwnProperty(k)) {
                        delete dest[k];
                    }
                });
            },
            scopeData: function(dataOrRec) {
                var data = {
                    $id: dataOrRec.$id,
                    $priority: dataOrRec.$priority
                };
                var hasPublicProp = false;
                utils.each(dataOrRec, function(v, k) {
                    hasPublicProp = true;
                    data[k] = utils.deepCopy(v);
                });
                if (!hasPublicProp && dataOrRec.hasOwnProperty("$value")) {
                    data.$value = dataOrRec.$value;
                }
                return data;
            },
            updateRec: function(rec, snap) {
                var data = snap.val();
                var oldData = angular.extend({}, rec);
                if (!angular.isObject(data)) {
                    rec.$value = data;
                    data = {};
                } else {
                    delete rec.$value;
                }
                utils.trimKeys(rec, data);
                angular.extend(rec, data);
                rec.$priority = snap.getPriority();
                return !angular.equals(oldData, rec) || oldData.$value !== rec.$value || oldData.$priority !== rec.$priority;
            },
            applyDefaults: function(rec, defaults) {
                if (angular.isObject(defaults)) {
                    angular.forEach(defaults, function(v, k) {
                        if (!rec.hasOwnProperty(k)) {
                            rec[k] = v;
                        }
                    });
                }
                return rec;
            },
            dataKeys: function(obj) {
                var out = [];
                utils.each(obj, function(v, k) {
                    out.push(k);
                });
                return out;
            },
            each: function(obj, iterator, context) {
                if (angular.isObject(obj)) {
                    for (var k in obj) {
                        if (obj.hasOwnProperty(k)) {
                            var c = k.charAt(0);
                            if (c !== "_" && c !== "$" && c !== ".") {
                                iterator.call(context, obj[k], k, obj);
                            }
                        }
                    }
                } else if (angular.isArray(obj)) {
                    for (var i = 0, len = obj.length; i < len; i++) {
                        iterator.call(context, obj[i], i, obj);
                    }
                }
                return obj;
            },
            getKey: function(refOrSnapshot) {
                return typeof refOrSnapshot.key === "function" ? refOrSnapshot.key() : refOrSnapshot.name();
            },
            toJSON: function(rec) {
                var dat;
                if (!angular.isObject(rec)) {
                    rec = {
                        $value: rec
                    };
                }
                if (angular.isFunction(rec.toJSON)) {
                    dat = rec.toJSON();
                } else {
                    dat = {};
                    utils.each(rec, function(v, k) {
                        dat[k] = stripDollarPrefixedKeys(v);
                    });
                }
                if (angular.isDefined(rec.$value) && Object.keys(dat).length === 0 && rec.$value !== null) {
                    dat[".value"] = rec.$value;
                }
                if (angular.isDefined(rec.$priority) && Object.keys(dat).length > 0 && rec.$priority !== null) {
                    dat[".priority"] = rec.$priority;
                }
                angular.forEach(dat, function(v, k) {
                    if (k.match(/[.$\[\]#\/]/) && k !== ".value" && k !== ".priority") {
                        throw new Error("Invalid key " + k + " (cannot contain .$[]#)");
                    } else if (angular.isUndefined(v)) {
                        throw new Error("Key " + k + " was undefined. Cannot pass undefined in JSON. Use null instead.");
                    }
                });
                return dat;
            },
            doSet: function(ref, data) {
                var def = utils.defer();
                if (angular.isFunction(ref.set) || !angular.isObject(data)) {
                    ref.set(data, utils.makeNodeResolver(def));
                } else {
                    var dataCopy = angular.extend({}, data);
                    ref.once("value", function(snap) {
                        snap.forEach(function(ss) {
                            if (!dataCopy.hasOwnProperty(utils.getKey(ss))) {
                                dataCopy[utils.getKey(ss)] = null;
                            }
                        });
                        ref.ref().update(dataCopy, utils.makeNodeResolver(def));
                    }, function(err) {
                        def.reject(err);
                    });
                }
                return def.promise;
            },
            doRemove: function(ref) {
                var def = utils.defer();
                if (angular.isFunction(ref.remove)) {
                    ref.remove(utils.makeNodeResolver(def));
                } else {
                    ref.once("value", function(snap) {
                        var promises = [];
                        snap.forEach(function(ss) {
                            var d = utils.defer();
                            promises.push(d.promise);
                            ss.ref().remove(utils.makeNodeResolver(def));
                        });
                        utils.allPromises(promises).then(function() {
                            def.resolve(ref);
                        }, function(err) {
                            def.reject(err);
                        });
                    }, function(err) {
                        def.reject(err);
                    });
                }
                return def.promise;
            },
            VERSION: "1.1.1",
            allPromises: $q.all.bind($q)
        };
        return utils;
    } ]);
    function stripDollarPrefixedKeys(data) {
        if (!angular.isObject(data)) {
            return data;
        }
        var out = angular.isArray(data) ? [] : {};
        angular.forEach(data, function(v, k) {
            if (typeof k !== "string" || k.charAt(0) !== "$") {
                out[k] = stripDollarPrefixedKeys(v);
            }
        });
        return out;
    }
})();
"format amd";

(function() {
    "use strict";
    function angularMoment(angular, moment) {
        return angular.module("angularMoment", []).constant("angularMomentConfig", {
            preprocess: null,
            timezone: "",
            format: null,
            statefulFilters: true
        }).constant("moment", moment).constant("amTimeAgoConfig", {
            withoutSuffix: false,
            serverTime: null,
            titleFormat: null,
            fullDateThreshold: null,
            fullDateFormat: null
        }).directive("amTimeAgo", [ "$window", "moment", "amMoment", "amTimeAgoConfig", "angularMomentConfig", function($window, moment, amMoment, amTimeAgoConfig, angularMomentConfig) {
            return function(scope, element, attr) {
                var activeTimeout = null;
                var currentValue;
                var currentFormat = angularMomentConfig.format;
                var withoutSuffix = amTimeAgoConfig.withoutSuffix;
                var titleFormat = amTimeAgoConfig.titleFormat;
                var fullDateThreshold = amTimeAgoConfig.fullDateThreshold;
                var fullDateFormat = amTimeAgoConfig.fullDateFormat;
                var localDate = new Date().getTime();
                var preprocess = angularMomentConfig.preprocess;
                var modelName = attr.amTimeAgo;
                var isTimeElement = "TIME" === element[0].nodeName.toUpperCase();
                function getNow() {
                    var now;
                    if (amTimeAgoConfig.serverTime) {
                        var localNow = new Date().getTime();
                        var nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
                        now = moment(nowMillis);
                    } else {
                        now = moment();
                    }
                    return now;
                }
                function cancelTimer() {
                    if (activeTimeout) {
                        $window.clearTimeout(activeTimeout);
                        activeTimeout = null;
                    }
                }
                function updateTime(momentInstance) {
                    var daysAgo = getNow().diff(momentInstance, "day");
                    var showFullDate = fullDateThreshold && daysAgo >= fullDateThreshold;
                    if (showFullDate) {
                        element.text(momentInstance.format(fullDateFormat));
                    } else {
                        element.text(momentInstance.from(getNow(), withoutSuffix));
                    }
                    if (titleFormat && !element.attr("title")) {
                        element.attr("title", momentInstance.local().format(titleFormat));
                    }
                    if (!showFullDate) {
                        var howOld = Math.abs(getNow().diff(momentInstance, "minute"));
                        var secondsUntilUpdate = 3600;
                        if (howOld < 1) {
                            secondsUntilUpdate = 1;
                        } else if (howOld < 60) {
                            secondsUntilUpdate = 30;
                        } else if (howOld < 180) {
                            secondsUntilUpdate = 300;
                        }
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, secondsUntilUpdate * 1e3);
                    }
                }
                function updateDateTimeAttr(value) {
                    if (isTimeElement) {
                        element.attr("datetime", value);
                    }
                }
                function updateMoment() {
                    cancelTimer();
                    if (currentValue) {
                        var momentValue = amMoment.preprocessDate(currentValue, preprocess, currentFormat);
                        updateTime(momentValue);
                        updateDateTimeAttr(momentValue.toISOString());
                    }
                }
                scope.$watch(modelName, function(value) {
                    if (typeof value === "undefined" || value === null || value === "") {
                        cancelTimer();
                        if (currentValue) {
                            element.text("");
                            updateDateTimeAttr("");
                            currentValue = null;
                        }
                        return;
                    }
                    currentValue = value;
                    updateMoment();
                });
                if (angular.isDefined(attr.amWithoutSuffix)) {
                    scope.$watch(attr.amWithoutSuffix, function(value) {
                        if (typeof value === "boolean") {
                            withoutSuffix = value;
                            updateMoment();
                        } else {
                            withoutSuffix = amTimeAgoConfig.withoutSuffix;
                        }
                    });
                }
                attr.$observe("amFormat", function(format) {
                    if (typeof format !== "undefined") {
                        currentFormat = format;
                        updateMoment();
                    }
                });
                attr.$observe("amPreprocess", function(newValue) {
                    preprocess = newValue;
                    updateMoment();
                });
                attr.$observe("amFullDateThreshold", function(newValue) {
                    fullDateThreshold = newValue;
                    updateMoment();
                });
                attr.$observe("amFullDateFormat", function(newValue) {
                    fullDateFormat = newValue;
                    updateMoment();
                });
                scope.$on("$destroy", function() {
                    cancelTimer();
                });
                scope.$on("amMoment:localeChanged", function() {
                    updateMoment();
                });
            };
        } ]).service("amMoment", [ "moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
            this.preprocessors = {
                utc: moment.utc,
                unix: moment.unix
            };
            this.changeLocale = function(locale, customization) {
                var result = moment.locale(locale, customization);
                if (angular.isDefined(locale)) {
                    $rootScope.$broadcast("amMoment:localeChanged");
                }
                return result;
            };
            this.changeTimezone = function(timezone) {
                angularMomentConfig.timezone = timezone;
                $rootScope.$broadcast("amMoment:timezoneChanged");
            };
            this.preprocessDate = function(value, preprocess, format) {
                if (angular.isUndefined(preprocess)) {
                    preprocess = angularMomentConfig.preprocess;
                }
                if (this.preprocessors[preprocess]) {
                    return this.preprocessors[preprocess](value, format);
                }
                if (preprocess) {
                    $log.warn("angular-moment: Ignoring unsupported value for preprocess: " + preprocess);
                }
                if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    return moment(parseInt(value, 10));
                }
                return moment(value, format);
            };
            this.applyTimezone = function(aMoment, timezone) {
                timezone = timezone || angularMomentConfig.timezone;
                if (aMoment && timezone) {
                    if (aMoment.tz) {
                        aMoment = aMoment.tz(timezone);
                    } else {
                        $log.warn("angular-moment: timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js?");
                    }
                }
                return aMoment;
            };
        } ]).filter("amCalendar", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amCalendarFilter(value, preprocess) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).calendar();
            }
            amCalendarFilter.$stateful = angularMomentConfig.statefulFilters;
            return amCalendarFilter;
        } ]).filter("amDifference", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDifferenceFilter(value, otherValue, unit, usePrecision, preprocessValue, preprocessOtherValue) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocessValue);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                var date2;
                if (typeof otherValue === "undefined" || otherValue === null) {
                    date2 = moment();
                } else {
                    otherValue = amMoment.preprocessDate(otherValue, preprocessOtherValue);
                    date2 = moment(otherValue);
                    if (!date2.isValid()) {
                        return "";
                    }
                }
                return amMoment.applyTimezone(date).diff(amMoment.applyTimezone(date2), unit, usePrecision);
            }
            amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDifferenceFilter;
        } ]).filter("amDateFormat", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDateFormatFilter(value, format, preprocess, timezone) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date, timezone).format(format);
            }
            amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDateFormatFilter;
        } ]).filter("amDurationFormat", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amDurationFormatFilter(value, format, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                return moment.duration(value, format).humanize(suffix);
            }
            amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDurationFormatFilter;
        } ]).filter("amTimeAgo", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amTimeAgoFilter(value, preprocess, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).fromNow(suffix);
            }
            amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters;
            return amTimeAgoFilter;
        } ]);
    }
    if (typeof define === "function" && define.amd) {
        define([ "angular", "moment" ], angularMoment);
    } else if (typeof module !== "undefined" && module && module.exports) {
        angularMoment(angular, require("moment"));
        module.exports = "angularMoment";
    } else {
        angularMoment(angular, window.moment);
    }
})();
(function() {
    "use strict";
    angular.module("anim-in-out", [ "ngAnimate" ]).animation(".anim-in-out", [ "$rootScope", "$timeout", "$window", function($rootScope, $timeout, $window) {
        return {
            enter: function(element, done) {
                var sync = $rootScope.$eval(angular.element(element).attr("data-anim-sync")) !== undefined ? $rootScope.$eval(angular.element(element).attr("data-anim-sync")) : false, speed = angular.element(element).attr("data-anim-speed") !== undefined ? $rootScope.$eval(angular.element(element).attr("data-anim-speed")) : 1e3, inSpeed = angular.element(element).attr("data-anim-in-speed") !== undefined ? $rootScope.$eval(angular.element(element).attr("data-anim-in-speed")) : speed, outSpeed = angular.element(element).attr("data-anim-out-speed") !== undefined ? $rootScope.$eval(angular.element(element).attr("data-anim-out-speed")) : speed;
                try {
                    var observer = new MutationObserver(function(mutations) {
                        observer.disconnect();
                        $window.requestAnimationFrame(function() {
                            $timeout(done, sync ? 0 : outSpeed);
                        });
                    });
                    observer.observe(element[0], {
                        attributes: true,
                        childList: false,
                        characterData: false
                    });
                } catch (e) {
                    $timeout(done, Math.max(100, sync ? 0 : outSpeed));
                }
                angular.element(element).addClass("anim-in-setup");
                return function(cancelled) {
                    angular.element(element).removeClass("anim-in-setup");
                    angular.element(element).addClass("anim-in");
                    if (!cancelled) {
                        if (angular.element(element).children().length > 0 && angular.element(element).children().scope() !== undefined) {
                            angular.element(element).children().scope().$broadcast("animIn", element, inSpeed);
                        }
                        $timeout(function() {
                            $rootScope.$emit("animEnd", element, inSpeed);
                            angular.element(element).removeClass("anim-in");
                        }, inSpeed);
                    }
                };
            },
            leave: function(element, done) {
                var speed = angular.element(element).attr("data-anim-speed") !== undefined ? $rootScope.$eval(angular.element(element).attr("data-anim-speed")) : 1e3, outSpeed = angular.element(element).attr("data-anim-out-speed") !== undefined ? $rootScope.$eval(angular.element(element).attr("data-anim-out-speed")) : speed;
                $rootScope.$emit("animStart", element, outSpeed);
                if (angular.element(element).children().length > 0) {
                    angular.element(element).children().scope().$broadcast("animOut", element, outSpeed);
                }
                try {
                    var observer = new MutationObserver(function(mutations) {
                        observer.disconnect();
                        $window.requestAnimationFrame(function() {
                            angular.element(element).removeClass("anim-out-setup");
                            angular.element(element).addClass("anim-out");
                            $timeout(done, outSpeed);
                        });
                    });
                    observer.observe(element[0], {
                        attributes: true,
                        childList: false,
                        characterData: false
                    });
                } catch (e) {
                    angular.element(element).removeClass("anim-out-setup");
                    angular.element(element).addClass("anim-out");
                    $timeout(done, Math.max(100, outSpeed));
                }
                angular.element(element).addClass("anim-out-setup");
            }
        };
    } ]);
})();
angular.module("templates", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("features/home/_home.html", '<div class="wrapper center">\n  <a class="button" ui-sref="write">{{user.latest?\'Continue writing\':\'Start writing\'}}</a>\n  <ul>\n    <li ng-if="!!stream" ng-repeat="stream in user.streams">\n      <h2>\n        {{stream.title}}\n      </h2>\n      <p>\n        {{stream.completed | amCalendar}}\n      </p>\n    </li>\n  </ul>\n</div>\n');
    $templateCache.put("features/_feature/_feature.html", "\n");
    $templateCache.put("features/stream/_stream.html", "\n");
    $templateCache.put("features/login/_login.html", '<div class="wrapper center">\n  <a class="button" ng-click="login()">Login with Twitter</a>\n</div>\n');
    $templateCache.put("features/title/_title.html", '<div class="wrapper">\n  <input autofocus="true" ng-model="title" placeholder="untitled" type="text" />\n</div>\n<div class="wrapper dark">\n  <a class="button" ui-sref="write">Back</a>\n  <div class="stream-actions">\n    <a class="button" ng-click="save()">{{saving?\'Saving...\':\'Done\'}}</a>\n  </div>\n</div>\n');
    $templateCache.put("features/write/_write.html", '<div class="wrapper">\n  <p class="faded">\n    {{prev}}\n  </p>\n  <textarea autofocus="" ng-change="updateWords()" ng-focus="abandon_confirm=false; complete_confirm=false" ng-model="stream.writing" ng-paste="preventPaste($event)" overflow="stream.written" placeholder="Just write it down" previousLine="prev"></textarea>\n  <div class="stream-actions">\n    <a class="button minor" id="abandon" ng-click="abandon()">{{abandon_confirm?\'Sure?\':\'Abandon\'}}</a><a class="button" id="confirm" ng-class="{&#39;disabled&#39;: !words}" ng-click="complete()">Complete</a>\n  </div>\n  <div class="stream-meta center">\n    <div class="left">\n      <span>{{words}} </span><ng-pluralize class="faded" count="words" when="{&#39;one&#39;: &#39;word&#39;, &#39;other&#39;: &#39;words&#39;}"></ng-pluralize>\n    </div>\n    <span class="faded right"> {{created | amCalendar}}</span>\n  </div>\n</div>\n');
    $templateCache.put("patterns/_pattern/_pattern.html", "");
} ]);
angular.module("services", []).value("Endpoint", "https://joyce.firebaseio.com").factory("Auth", function($firebaseAuth) {
    var ref = new Firebase("https://joyce.firebaseio.com");
    return $firebaseAuth(ref);
}).factory("User", function($firebaseObject, Auth) {
    var ref = new Firebase("https://joyce.firebaseio.com/users/" + Auth.$getAuth().uid);
    return $firebaseObject(ref);
}).service("Stream", function($firebaseObject, Endpoint, User, $q) {
    var service = {};
    service.new = function() {
        var deferred = $q.defer(), streamsRef = new Firebase(Endpoint + "/streams"), streamRef = streamsRef.push(), date = new Date().getTime();
        if (!User.streams) User.streams = {};
        User.streams[streamRef.key()] = false;
        User.$save();
        streamRef.set({
            owner: User.$id,
            frozen: false,
            created: date,
            written: "",
            writing: "",
            tags: []
        });
        return streamRef.key();
    };
    service.get = function(uid) {
        ref = new Firebase(Endpoint + "/streams/" + uid);
        return $firebaseObject(ref);
    };
    service.getLatest = function() {
        var deferred = $q.defer();
        User.$loaded().then(function() {
            if (User.latest) deferred.resolve(service.get(User.latest)); else {
                var id = service.new();
                User.latest = id;
                $q.all([ User.$save(), service.get(id) ]).then(function(proms) {
                    deferred.resolve(proms[1]);
                });
            }
        });
        return deferred.promise;
    };
    service.abandon = function(streamObj) {
        if (User.streams) delete User.streams[User.latest];
        delete User.latest;
        return $q.all([ streamObj.$remove(), User.$save() ]);
    };
    return service;
}).factory("Alchemy", function($resource) {
    return function(text) {
        return $resource("https://access.alchemyapi.com/calls/text/TextGetRankedTaxonomy", {
            apikey: "e60e2344a23b3ebfe425e5792d8e203b906e235d",
            text: text,
            outputMode: "json"
        });
    };
});
angular.module("states", []).run(function($rootScope, $state) {
    $rootScope.$on("$stateChangeError", function(event, toState, toParams, fromState, fromParams, error) {
        if (error == "AUTH_REQUIRED") {
            $state.go("login");
        }
    });
}).config(function($stateProvider, $stickyStateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $httpProvider.interceptors.push(function($q, $rootScope, $location) {
        return {
            request: function(config) {
                $rootScope.$broadcast("ajaxStart", config);
                return config;
            },
            response: function(config) {
                $rootScope.$broadcast("ajaxEnd", config);
                return config;
            },
            responseError: function(config) {
                $rootScope.$broadcast("ajaxEnd", config);
                return config;
            }
        };
    });
    $urlRouterProvider.otherwise("/");
    $locationProvider.html5Mode(true);
    function templater(page, child) {
        if (angular.isUndefined(child)) child = page;
        return "features/" + page + "/_" + child + ".html";
    }
    $stateProvider.state("login", {
        url: "/login",
        templateUrl: templater("login"),
        controller: "loginController",
        resolve: {
            currentAuth: [ "Auth", function(Auth) {
                return Auth.$waitForAuth();
            } ]
        }
    }).state("home", {
        url: "/",
        templateUrl: templater("home"),
        controller: "homeController",
        resolve: {
            currentAuth: [ "Auth", function(Auth) {
                return Auth.$requireAuth();
            } ]
        }
    }).state("write", {
        url: "/write",
        templateUrl: templater("write"),
        controller: "writeController",
        resolve: {
            currentAuth: [ "Auth", function(Auth) {
                return Auth.$requireAuth();
            } ]
        }
    }).state("title", {
        url: "/title",
        templateUrl: templater("title"),
        controller: "titleController",
        params: {
            text: null
        },
        resolve: {
            currentAuth: [ "Auth", function(Auth) {
                return Auth.$requireAuth();
            } ]
        }
    }).state("stream", {
        url: "/stream/:id",
        templateUrl: templater("stream"),
        controller: "streamController",
        resolve: {
            currentAuth: [ "Auth", function(Auth) {
                return Auth.$requireAuth();
            } ]
        }
    }).state("logout", {
        url: "/logout",
        controller: [ "Auth", "$state", function(Auth, $state) {
            Auth.$unauth();
            $state.go("login");
        } ]
    });
});
angular.module("<%= name%>", []).controller("<%= name%>Controller", function($scope) {});
angular.module("home", []).controller("homeController", function($scope, User) {
    User.$bindTo($scope, "user");
});
angular.module("login", []).controller("loginController", function($scope, $state, Auth, currentAuth, Endpoint, $firebaseObject) {
    if (currentAuth) $state.go("home");
    $scope.login = function() {
        $scope.authData = null;
        $scope.error = null;
        Auth.$authWithOAuthPopup("twitter").then(function(authData) {
            var ref = new Firebase(Endpoint + "/users/" + authData.uid), user = $firebaseObject(ref);
            user.$loaded().then(function() {
                if (!user.name) {
                    user.name = authData.twitter.displayName;
                    user.handle = authData.twitter.username;
                    user.avatar = authData.twitter.cachedUserProfile.profile_image_url.replace(/_[^./]*\./, "_bigger.");
                    user.latest = false;
                    user.$save().then(function() {
                        $state.go("home");
                    });
                } else {
                    $state.go("home");
                }
            });
        });
    };
});
angular.module("stream", []).controller("streamController", function($scope) {});
angular.module("title", []).controller("titleController", function($scope, $state, $stateParams, $q, User, Stream, Alchemy) {
    if (!User.latest) {
        $state.go("write");
    } else {
        var stream = Stream.get(User.latest);
        Alchemy($stateParams.text).get().$promise.then(function(response) {
            stream.tags = [];
            response.taxonomy.filter(function(current) {
                return !current.confident || current.confident != "no";
            }).forEach(function(current) {
                stream.tags.push(current.label.split("/")[1]);
            });
        });
        $scope.title = "";
    }
    $scope.save = function() {
        if (!$scope.title) $scope.title = "untitled";
        $scope.saving = true;
        var completed = new Date().getTime();
        delete User.latest;
        User.streams[stream.$id] = {
            completed: completed,
            title: $scope.title
        };
        var userProm = User.$save();
        stream.written = stream.written + stream.writing;
        delete stream.writing;
        stream.frozen = true;
        stream.title = $scope.title;
        stream.completed = completed;
        var streamProm = stream.$save();
        $q.all([ userProm, streamProm ]).then(function() {
            $state.go("home");
        });
    };
});
angular.module("write", []).controller("writeController", function($scope, Stream, $state) {
    $scope.words = 0;
    $scope.stream = false;
    $scope.title = "";
    $scope.abandon_confirm = false;
    $scope.complete_confirm = false;
    var streamRef;
    Stream.getLatest().then(function(streamObj) {
        streamRef = streamObj;
        streamObj.$bindTo($scope, "stream").then(function() {
            $scope.updateWords();
            $scope.created = new Date(parseInt(streamObj.created));
        });
    });
    $scope.preventPaste = function(e) {
        e.preventDefault();
        return false;
    };
    $scope.updateWords = function(e) {
        var text = $scope.stream.writen + $scope.stream.writing;
        text = text == "undefined" ? "" : text;
        var spaces = text ? text.split(" ") : [], lines = [];
        for (var i = 0; i < spaces.length; i++) {
            lines = lines.concat(spaces[i].split("\n"));
        }
        $scope.words = lines.length == 1 && lines[0] === "" ? 0 : lines.length;
    };
    $scope.abandon = function() {
        if (!$scope.abandon_confirm) $scope.abandon_confirm = true; else Stream.abandon(streamRef).then(function() {
            $state.go("home");
        });
    };
    $scope.complete = function() {
        $state.go("title", {
            text: $scope.stream.written + $scope.stream.writing
        });
    };
}).directive("overflow", function($timeout) {
    return {
        restrict: "A",
        require: "?ngModel",
        scope: {
            overflow: "=",
            previousLine: "="
        },
        link: function(scope, element, attrs) {
            var origHeight = element[0].scrollHeight, lineheight = parseInt($(element[0]).css("line-height"));
            element.on("blur keyup change", function() {
                var text = element.val(), scrollHeight = element[0].scrollHeight;
                if (scrollHeight > origHeight) {
                    var lines = scrollHeight / lineheight, len = Math.round(text.length / 3), third = text.substr(0, len);
                    var newLines = third.split("\n"), over, remainder;
                    if (newLines.length > 1) {
                        over = newLines[0] + "\n";
                        remainder = text.substr(newLines[0].length + 1);
                    } else {
                        for (var i = len; i >= 0; i--) {
                            if (text[i] == " ") {
                                break;
                            }
                        }
                        if (i) {
                            over = text.substr(0, i + 1);
                            remainder = text.substr(i + 1);
                        }
                    }
                    scope.overflow += over;
                    previousLine = over;
                    element.val(remainder);
                }
            });
        }
    };
});
angular.module("<%= name%>", []).directive("go<%= bigname%>", function() {
    return {
        restrict: "E",
        scope: {},
        controller: "<%= name%>Controller as <%= name%>Ctrl",
        templateUrl: "patterns/<%= name%>/_<%= name%>.html"
    };
}).controller("<%= name%>Controller", function($scope, $element) {});
angular.module("app", [ "ui.router", "templates", "breakpointApp", "ct.ui.router.extras", "ngAnimate", "ngResource", "ngSanitize", "states", "anim-in-out", "services", "firebase", "angularMoment", "home", "write", "login", "title" ]).run(function() {
    moment.locale("en", {
        calendar: {
            lastDay: "[Yesterday at] h:mma",
            sameDay: "[Today at] h:mma",
            nextDay: "[Tomorrow at] h:mma",
            lastWeek: "[last] dddd [at] h:mma",
            nextWeek: "dddd [at] h:mma",
            sameElse: "ll [at] h:mma"
        }
    });
}).controller("appController", function($scope, Auth, $state) {
    $scope.title = "Joyce";
    Auth.$onAuth(function(authData) {
        if (authData) {
            $scope.name = authData.twitter.displayName;
            $scope.avatar = authData.twitter.cachedUserProfile.profile_image_url.replace(/_[^./]*\./, "_bigger.");
        } else {
            $scope.name = false;
            $scope.avatar = false;
        }
    });
    $scope.$on("$stateChangeSuccess", function(e, toState) {
        $scope.title = toState.title ? toState.title : "Joyce";
    });
});